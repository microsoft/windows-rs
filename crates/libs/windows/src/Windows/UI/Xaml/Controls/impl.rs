#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IAnchorRequestedEventArgsImpl: Sized {
    fn Anchor(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetAnchor(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn AnchorCandidates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::UIElement>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAnchorRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAnchorRequestedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IAnchorRequestedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAnchorRequestedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAnchorRequestedEventArgsVtbl {
        unsafe extern "system" fn Anchor<Impl: IAnchorRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Anchor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAnchor<Impl: IAnchorRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAnchor(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AnchorCandidates<Impl: IAnchorRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnchorCandidates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAnchorRequestedEventArgs, BASE_OFFSET>(),
            Anchor: Anchor::<Impl, IMPL_OFFSET>,
            SetAnchor: SetAnchor::<Impl, IMPL_OFFSET>,
            AnchorCandidates: AnchorCandidates::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAnchorRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IAppBarImpl: Sized {
    fn IsOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSticky(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSticky(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IAppBarVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarVtbl {
        unsafe extern "system" fn IsOpen<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOpen<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOpen(value).into()
        }
        unsafe extern "system" fn IsSticky<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSticky() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSticky<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSticky(value).into()
        }
        unsafe extern "system" fn Opened<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IAppBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar, BASE_OFFSET>(),
            IsOpen: IsOpen::<Impl, IMPL_OFFSET>,
            SetIsOpen: SetIsOpen::<Impl, IMPL_OFFSET>,
            IsSticky: IsSticky::<Impl, IMPL_OFFSET>,
            SetIsSticky: SetIsSticky::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBar2Impl: Sized {
    fn ClosedDisplayMode(&mut self) -> ::windows::core::Result<AppBarClosedDisplayMode>;
    fn SetClosedDisplayMode(&mut self, value: AppBarClosedDisplayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar2";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBar2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBar2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBar2Vtbl {
        unsafe extern "system" fn ClosedDisplayMode<Impl: IAppBar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut AppBarClosedDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClosedDisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClosedDisplayMode<Impl: IAppBar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: AppBarClosedDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClosedDisplayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar2, BASE_OFFSET>(),
            ClosedDisplayMode: ClosedDisplayMode::<Impl, IMPL_OFFSET>,
            SetClosedDisplayMode: SetClosedDisplayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IAppBar3Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::AppBarTemplateSettings>;
    fn Opening(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar3";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IAppBar3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBar3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBar3Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Opening<Impl: IAppBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opening(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpening<Impl: IAppBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closing<Impl: IAppBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closing(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosing<Impl: IAppBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar3, BASE_OFFSET>(),
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            Opening: Opening::<Impl, IMPL_OFFSET>,
            RemoveOpening: RemoveOpening::<Impl, IMPL_OFFSET>,
            Closing: Closing::<Impl, IMPL_OFFSET>,
            RemoveClosing: RemoveClosing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBar4Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBar4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBar4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBar4Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IAppBar4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IAppBar4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar4, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonImpl: Sized {
    fn Label(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetLabel(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonVtbl {
        unsafe extern "system" fn Label<Impl: IAppBarButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Label() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IAppBarButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabel(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Icon<Impl: IAppBarButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IAppBarButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton, BASE_OFFSET>(),
            Label: Label::<Impl, IMPL_OFFSET>,
            SetLabel: SetLabel::<Impl, IMPL_OFFSET>,
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton3Impl: Sized {
    fn LabelPosition(&mut self) -> ::windows::core::Result<CommandBarLabelPosition>;
    fn SetLabelPosition(&mut self, value: CommandBarLabelPosition) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButton3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButton3Vtbl {
        unsafe extern "system" fn LabelPosition<Impl: IAppBarButton3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabelPosition<Impl: IAppBarButton3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabelPosition(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton3, BASE_OFFSET>(),
            LabelPosition: LabelPosition::<Impl, IMPL_OFFSET>,
            SetLabelPosition: SetLabelPosition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton4Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButton4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButton4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IAppBarButton4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IAppBarButton4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverride: KeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            SetKeyboardAcceleratorTextOverride: SetKeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IAppBarButton5Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::AppBarButtonTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBarButton5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton5";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IAppBarButton5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButton5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButton5Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBarButton5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton5, BASE_OFFSET>(), TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStaticsImpl: Sized {
    fn LabelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonStaticsVtbl {
        unsafe extern "system" fn LabelProperty<Impl: IAppBarButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconProperty<Impl: IAppBarButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonStatics, BASE_OFFSET>(),
            LabelProperty: LabelProperty::<Impl, IMPL_OFFSET>,
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStatics3Impl: Sized {
    fn LabelPositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonStatics3Vtbl {
        unsafe extern "system" fn LabelPositionProperty<Impl: IAppBarButtonStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarButtonStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarButtonStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonStatics3, BASE_OFFSET>(),
            LabelPositionProperty: LabelPositionProperty::<Impl, IMPL_OFFSET>,
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStatics4Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonStatics4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IAppBarButtonStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonStatics4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverrideProperty: KeyboardAcceleratorTextOverrideProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainer";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarElementContainerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarElementContainerVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarElementContainer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarElementContainer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarElementContainer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarElementContainerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarElementContainerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarElementContainerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarElementContainerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarElementContainerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerStaticsImpl: Sized {
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarElementContainerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarElementContainerStaticsVtbl {
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarElementContainerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarElementContainerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarElementContainerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarElementContainerStatics, BASE_OFFSET>(),
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarElementContainerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarOverridesImpl: Sized {
    fn OnClosed(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOpened(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarOverridesVtbl {
        unsafe extern "system" fn OnClosed<Impl: IAppBarOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClosed(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOpened<Impl: IAppBarOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOpened(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarOverrides, BASE_OFFSET>(),
            OnClosed: OnClosed::<Impl, IMPL_OFFSET>,
            OnOpened: OnOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarOverrides3Impl: Sized {
    fn OnClosing(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOpening(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarOverrides3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarOverrides3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarOverrides3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarOverrides3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarOverrides3Vtbl {
        unsafe extern "system" fn OnClosing<Impl: IAppBarOverrides3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClosing(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOpening<Impl: IAppBarOverrides3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOpening(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarOverrides3, BASE_OFFSET>(),
            OnClosing: OnClosing::<Impl, IMPL_OFFSET>,
            OnOpening: OnOpening::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarOverrides3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparatorImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparatorVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparator, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparatorFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparatorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarSeparatorFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparatorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparatorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorStaticsImpl: Sized {
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparatorStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparatorStaticsVtbl {
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarSeparatorStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparatorStatics, BASE_OFFSET>(),
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparatorStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorStatics3Impl: Sized {
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparatorStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparatorStatics3Vtbl {
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarSeparatorStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarSeparatorStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparatorStatics3, BASE_OFFSET>(),
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparatorStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStaticsImpl: Sized {
    fn IsOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStickyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarStaticsVtbl {
        unsafe extern "system" fn IsOpenProperty<Impl: IAppBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStickyProperty<Impl: IAppBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStickyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarStatics, BASE_OFFSET>(),
            IsOpenProperty: IsOpenProperty::<Impl, IMPL_OFFSET>,
            IsStickyProperty: IsStickyProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStatics2Impl: Sized {
    fn ClosedDisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarStatics2Vtbl {
        unsafe extern "system" fn ClosedDisplayModeProperty<Impl: IAppBarStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClosedDisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarStatics2, BASE_OFFSET>(),
            ClosedDisplayModeProperty: ClosedDisplayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStatics4Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarStatics4Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IAppBarStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarStatics4, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonImpl: Sized {
    fn Label(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetLabel(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonVtbl {
        unsafe extern "system" fn Label<Impl: IAppBarToggleButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Label() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IAppBarToggleButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabel(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Icon<Impl: IAppBarToggleButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IAppBarToggleButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton, BASE_OFFSET>(),
            Label: Label::<Impl, IMPL_OFFSET>,
            SetLabel: SetLabel::<Impl, IMPL_OFFSET>,
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton3Impl: Sized {
    fn LabelPosition(&mut self) -> ::windows::core::Result<CommandBarLabelPosition>;
    fn SetLabelPosition(&mut self, value: CommandBarLabelPosition) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButton3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButton3Vtbl {
        unsafe extern "system" fn LabelPosition<Impl: IAppBarToggleButton3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabelPosition<Impl: IAppBarToggleButton3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabelPosition(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton3, BASE_OFFSET>(),
            LabelPosition: LabelPosition::<Impl, IMPL_OFFSET>,
            SetLabelPosition: SetLabelPosition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton4Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButton4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButton4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IAppBarToggleButton4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IAppBarToggleButton4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverride: KeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            SetKeyboardAcceleratorTextOverride: SetKeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IAppBarToggleButton5Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::AppBarToggleButtonTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBarToggleButton5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton5";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IAppBarToggleButton5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButton5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButton5Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBarToggleButton5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton5, BASE_OFFSET>(),
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarToggleButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarToggleButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStaticsImpl: Sized {
    fn LabelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonStaticsVtbl {
        unsafe extern "system" fn LabelProperty<Impl: IAppBarToggleButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconProperty<Impl: IAppBarToggleButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarToggleButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonStatics, BASE_OFFSET>(),
            LabelProperty: LabelProperty::<Impl, IMPL_OFFSET>,
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStatics3Impl: Sized {
    fn LabelPositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonStatics3Vtbl {
        unsafe extern "system" fn LabelPositionProperty<Impl: IAppBarToggleButtonStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarToggleButtonStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarToggleButtonStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonStatics3, BASE_OFFSET>(),
            LabelPositionProperty: LabelPositionProperty::<Impl, IMPL_OFFSET>,
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStatics4Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonStatics4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IAppBarToggleButtonStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonStatics4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverrideProperty: KeyboardAcceleratorTextOverrideProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IAutoSuggestBoxImpl: Sized {
    fn MaxSuggestionListHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxSuggestionListHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsSuggestionListOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSuggestionListOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextMemberPath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTextMemberPath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn UpdateTextOnSelect(&mut self) -> ::windows::core::Result<bool>;
    fn SetUpdateTextOnSelect(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AutoMaximizeSuggestionArea(&mut self) -> ::windows::core::Result<bool>;
    fn SetAutoMaximizeSuggestionArea(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextBoxStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetTextBoxStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SuggestionChosen(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSuggestionChosen(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAutoSuggestBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IAutoSuggestBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxVtbl {
        unsafe extern "system" fn MaxSuggestionListHeight<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSuggestionListHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSuggestionListHeight<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxSuggestionListHeight(value).into()
        }
        unsafe extern "system" fn IsSuggestionListOpen<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSuggestionListOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSuggestionListOpen<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSuggestionListOpen(value).into()
        }
        unsafe extern "system" fn TextMemberPath<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextMemberPath<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Text<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UpdateTextOnSelect<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UpdateTextOnSelect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUpdateTextOnSelect<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUpdateTextOnSelect(value).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AutoMaximizeSuggestionArea<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoMaximizeSuggestionArea() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoMaximizeSuggestionArea<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoMaximizeSuggestionArea(value).into()
        }
        unsafe extern "system" fn TextBoxStyle<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextBoxStyle<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextBoxStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SuggestionChosen<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SuggestionChosen(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSuggestionChosen<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSuggestionChosen(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: IAutoSuggestBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox, BASE_OFFSET>(),
            MaxSuggestionListHeight: MaxSuggestionListHeight::<Impl, IMPL_OFFSET>,
            SetMaxSuggestionListHeight: SetMaxSuggestionListHeight::<Impl, IMPL_OFFSET>,
            IsSuggestionListOpen: IsSuggestionListOpen::<Impl, IMPL_OFFSET>,
            SetIsSuggestionListOpen: SetIsSuggestionListOpen::<Impl, IMPL_OFFSET>,
            TextMemberPath: TextMemberPath::<Impl, IMPL_OFFSET>,
            SetTextMemberPath: SetTextMemberPath::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            UpdateTextOnSelect: UpdateTextOnSelect::<Impl, IMPL_OFFSET>,
            SetUpdateTextOnSelect: SetUpdateTextOnSelect::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            AutoMaximizeSuggestionArea: AutoMaximizeSuggestionArea::<Impl, IMPL_OFFSET>,
            SetAutoMaximizeSuggestionArea: SetAutoMaximizeSuggestionArea::<Impl, IMPL_OFFSET>,
            TextBoxStyle: TextBoxStyle::<Impl, IMPL_OFFSET>,
            SetTextBoxStyle: SetTextBoxStyle::<Impl, IMPL_OFFSET>,
            SuggestionChosen: SuggestionChosen::<Impl, IMPL_OFFSET>,
            RemoveSuggestionChosen: RemoveSuggestionChosen::<Impl, IMPL_OFFSET>,
            TextChanged: TextChanged::<Impl, IMPL_OFFSET>,
            RemoveTextChanged: RemoveTextChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IAutoSuggestBox2Impl: Sized {
    fn QueryIcon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetQueryIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
    fn QuerySubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQuerySubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAutoSuggestBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IAutoSuggestBox2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBox2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBox2Vtbl {
        unsafe extern "system" fn QueryIcon<Impl: IAutoSuggestBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryIcon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQueryIcon<Impl: IAutoSuggestBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetQueryIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QuerySubmitted<Impl: IAutoSuggestBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QuerySubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQuerySubmitted<Impl: IAutoSuggestBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveQuerySubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox2, BASE_OFFSET>(),
            QueryIcon: QueryIcon::<Impl, IMPL_OFFSET>,
            SetQueryIcon: SetQueryIcon::<Impl, IMPL_OFFSET>,
            QuerySubmitted: QuerySubmitted::<Impl, IMPL_OFFSET>,
            RemoveQuerySubmitted: RemoveQuerySubmitted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBox3Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBox3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBox3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBox3Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IAutoSuggestBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IAutoSuggestBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox3, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBox4Impl: Sized {
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBox4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBox4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBox4Vtbl {
        unsafe extern "system" fn Description<Impl: IAutoSuggestBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IAutoSuggestBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox4, BASE_OFFSET>(),
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxQuerySubmittedEventArgsImpl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ChosenSuggestion(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxQuerySubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxQuerySubmittedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxQuerySubmittedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxQuerySubmittedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: IAutoSuggestBoxQuerySubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChosenSuggestion<Impl: IAutoSuggestBoxQuerySubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChosenSuggestion() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxQuerySubmittedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            ChosenSuggestion: ChosenSuggestion::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxQuerySubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStaticsImpl: Sized {
    fn MaxSuggestionListHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSuggestionListOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextMemberPathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UpdateTextOnSelectProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoMaximizeSuggestionAreaProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextBoxStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStaticsVtbl {
        unsafe extern "system" fn MaxSuggestionListHeightProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSuggestionListHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSuggestionListOpenProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSuggestionListOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextMemberPathProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateTextOnSelectProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UpdateTextOnSelectProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoMaximizeSuggestionAreaProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoMaximizeSuggestionAreaProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextBoxStyleProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics, BASE_OFFSET>(),
            MaxSuggestionListHeightProperty: MaxSuggestionListHeightProperty::<Impl, IMPL_OFFSET>,
            IsSuggestionListOpenProperty: IsSuggestionListOpenProperty::<Impl, IMPL_OFFSET>,
            TextMemberPathProperty: TextMemberPathProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            UpdateTextOnSelectProperty: UpdateTextOnSelectProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            AutoMaximizeSuggestionAreaProperty: AutoMaximizeSuggestionAreaProperty::<Impl, IMPL_OFFSET>,
            TextBoxStyleProperty: TextBoxStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics2Impl: Sized {
    fn QueryIconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStatics2Vtbl {
        unsafe extern "system" fn QueryIconProperty<Impl: IAutoSuggestBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryIconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics2, BASE_OFFSET>(),
            QueryIconProperty: QueryIconProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics3Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStatics3Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IAutoSuggestBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics3, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics4Impl: Sized {
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStatics4Vtbl {
        unsafe extern "system" fn DescriptionProperty<Impl: IAutoSuggestBoxStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics4, BASE_OFFSET>(),
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxSuggestionChosenEventArgsImpl: Sized {
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxSuggestionChosenEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxSuggestionChosenEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxSuggestionChosenEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxSuggestionChosenEventArgsVtbl {
        unsafe extern "system" fn SelectedItem<Impl: IAutoSuggestBoxSuggestionChosenEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxSuggestionChosenEventArgs, BASE_OFFSET>(),
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxSuggestionChosenEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxTextChangedEventArgsImpl: Sized {
    fn Reason(&mut self) -> ::windows::core::Result<AutoSuggestionBoxTextChangeReason>;
    fn SetReason(&mut self, value: AutoSuggestionBoxTextChangeReason) -> ::windows::core::Result<()>;
    fn CheckCurrent(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxTextChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxTextChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxTextChangedEventArgsVtbl {
        unsafe extern "system" fn Reason<Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut AutoSuggestionBoxTextChangeReason) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Reason() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReason<Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: AutoSuggestionBoxTextChangeReason) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetReason(value).into()
        }
        unsafe extern "system" fn CheckCurrent<Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CheckCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxTextChangedEventArgs, BASE_OFFSET>(),
            Reason: Reason::<Impl, IMPL_OFFSET>,
            SetReason: SetReason::<Impl, IMPL_OFFSET>,
            CheckCurrent: CheckCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxTextChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxTextChangedEventArgsStaticsImpl: Sized {
    fn ReasonProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxTextChangedEventArgsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxTextChangedEventArgsStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxTextChangedEventArgsStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxTextChangedEventArgsStaticsVtbl {
        unsafe extern "system" fn ReasonProperty<Impl: IAutoSuggestBoxTextChangedEventArgsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReasonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxTextChangedEventArgsStatics, BASE_OFFSET>(),
            ReasonProperty: ReasonProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxTextChangedEventArgsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBackClickEventArgsImpl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBackClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBackClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IBackClickEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBackClickEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBackClickEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: IBackClickEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IBackClickEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBackClickEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBackClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IBitmapIconImpl: Sized {
    fn UriSource(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetUriSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IBitmapIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIcon";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IBitmapIconVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconVtbl {
        unsafe extern "system" fn UriSource<Impl: IBitmapIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUriSource<Impl: IBitmapIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUriSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIcon, BASE_OFFSET>(),
            UriSource: UriSource::<Impl, IMPL_OFFSET>,
            SetUriSource: SetUriSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIcon2Impl: Sized {
    fn ShowAsMonochrome(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowAsMonochrome(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIcon2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIcon2";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIcon2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIcon2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIcon2Vtbl {
        unsafe extern "system" fn ShowAsMonochrome<Impl: IBitmapIcon2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochrome() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAsMonochrome<Impl: IBitmapIcon2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowAsMonochrome(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIcon2, BASE_OFFSET>(),
            ShowAsMonochrome: ShowAsMonochrome::<Impl, IMPL_OFFSET>,
            SetShowAsMonochrome: SetShowAsMonochrome::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIcon2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<BitmapIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IBitmapIconFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IBitmapIconSourceImpl: Sized {
    fn UriSource(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetUriSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn ShowAsMonochrome(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowAsMonochrome(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IBitmapIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSource";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IBitmapIconSourceVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconSourceImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconSourceVtbl {
        unsafe extern "system" fn UriSource<Impl: IBitmapIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUriSource<Impl: IBitmapIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUriSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAsMonochrome<Impl: IBitmapIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochrome() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAsMonochrome<Impl: IBitmapIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowAsMonochrome(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconSource, BASE_OFFSET>(),
            UriSource: UriSource::<Impl, IMPL_OFFSET>,
            SetUriSource: SetUriSource::<Impl, IMPL_OFFSET>,
            ShowAsMonochrome: ShowAsMonochrome::<Impl, IMPL_OFFSET>,
            SetShowAsMonochrome: SetShowAsMonochrome::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconSourceFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<BitmapIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconSourceFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconSourceFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IBitmapIconSourceFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconSourceStaticsImpl: Sized {
    fn UriSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowAsMonochromeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconSourceStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconSourceStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconSourceStaticsVtbl {
        unsafe extern "system" fn UriSourceProperty<Impl: IBitmapIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowAsMonochromeProperty<Impl: IBitmapIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochromeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconSourceStatics, BASE_OFFSET>(),
            UriSourceProperty: UriSourceProperty::<Impl, IMPL_OFFSET>,
            ShowAsMonochromeProperty: ShowAsMonochromeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconStaticsImpl: Sized {
    fn UriSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconStaticsVtbl {
        unsafe extern "system" fn UriSourceProperty<Impl: IBitmapIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconStatics, BASE_OFFSET>(),
            UriSourceProperty: UriSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconStatics2Impl: Sized {
    fn ShowAsMonochromeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconStatics2Vtbl {
        unsafe extern "system" fn ShowAsMonochromeProperty<Impl: IBitmapIconStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochromeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconStatics2, BASE_OFFSET>(),
            ShowAsMonochromeProperty: ShowAsMonochromeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IBorderImpl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Child(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ChildTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetChildTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IBorder {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorder";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IBorderVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorderImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorderVtbl {
        unsafe extern "system" fn BorderBrush<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Child<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChildTransitions<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChildTransitions<Impl: IBorderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChildTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorder, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            Child: Child::<Impl, IMPL_OFFSET>,
            SetChild: SetChild::<Impl, IMPL_OFFSET>,
            ChildTransitions: ChildTransitions::<Impl, IMPL_OFFSET>,
            SetChildTransitions: SetChildTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorder as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorder2Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
    fn BackgroundTransition(&mut self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&mut self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorder2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorder2";
}
#[cfg(feature = "implement_exclusive")]
impl IBorder2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorder2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorder2Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IBorder2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IBorder2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        unsafe extern "system" fn BackgroundTransition<Impl: IBorder2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IBorder2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorder2, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
            BackgroundTransition: BackgroundTransition::<Impl, IMPL_OFFSET>,
            SetBackgroundTransition: SetBackgroundTransition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorder2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorderStaticsImpl: Sized {
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorderStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorderStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBorderStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorderStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorderStaticsVtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IBorderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IBorderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IBorderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IBorderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IBorderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildTransitionsProperty<Impl: IBorderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorderStatics, BASE_OFFSET>(),
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            ChildTransitionsProperty: ChildTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorderStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorderStatics2Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorderStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorderStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IBorderStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorderStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorderStatics2Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IBorderStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorderStatics2, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorderStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButton";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButtonVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Button>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IButtonFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonStaticsWithFlyoutImpl: Sized {
    fn FlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButtonStaticsWithFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonStaticsWithFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonStaticsWithFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButtonStaticsWithFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButtonStaticsWithFlyoutVtbl {
        unsafe extern "system" fn FlyoutProperty<Impl: IButtonStaticsWithFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IButtonStaticsWithFlyout, BASE_OFFSET>(),
            FlyoutProperty: FlyoutProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButtonStaticsWithFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IButtonWithFlyoutImpl: Sized {
    fn Flyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IButtonWithFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonWithFlyout";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IButtonWithFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButtonWithFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButtonWithFlyoutVtbl {
        unsafe extern "system" fn Flyout<Impl: IButtonWithFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Flyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyout<Impl: IButtonWithFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IButtonWithFlyout, BASE_OFFSET>(),
            Flyout: Flyout::<Impl, IMPL_OFFSET>,
            SetFlyout: SetFlyout::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButtonWithFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Globalization", feature = "implement_exclusive"))]
pub trait ICalendarDatePickerImpl: Sized {
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn SetDate(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>) -> ::windows::core::Result<()>;
    fn IsCalendarOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCalendarOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DateFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDateFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn CalendarViewStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCalendarViewStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn MinDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn IsTodayHighlighted(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTodayHighlighted(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<CalendarViewDisplayMode>;
    fn SetDisplayMode(&mut self, value: CalendarViewDisplayMode) -> ::windows::core::Result<()>;
    fn FirstDayOfWeek(&mut self) -> ::windows::core::Result<super::super::super::Globalization::DayOfWeek>;
    fn SetFirstDayOfWeek(&mut self, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::Result<()>;
    fn DayOfWeekFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayOfWeekFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsOutOfScopeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOutOfScopeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsGroupLabelVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsGroupLabelVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemChanging(&mut self, handler: &::core::option::Option<CalendarViewDayItemChangingEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCalendarViewDayItemChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDisplayDate(&mut self, date: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn SetYearDecadeDisplayDimensions(&mut self, columns: i32, rows: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Globalization", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarDatePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker";
}
#[cfg(all(feature = "Foundation", feature = "Globalization", feature = "implement_exclusive"))]
impl ICalendarDatePickerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerVtbl {
        unsafe extern "system" fn Date<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsCalendarOpen<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCalendarOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCalendarOpen<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCalendarOpen(value).into()
        }
        unsafe extern "system" fn DateFormat<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDateFormat<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDateFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewStyle<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarViewStyle<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarViewStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinDate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinDate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxDate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTodayHighlighted<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTodayHighlighted<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTodayHighlighted(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn FirstDayOfWeek<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstDayOfWeek<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstDayOfWeek(value).into()
        }
        unsafe extern "system" fn DayOfWeekFormat<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayOfWeekFormat<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayOfWeekFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarIdentifier<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsOutOfScopeEnabled<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOutOfScopeEnabled<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOutOfScopeEnabled(value).into()
        }
        unsafe extern "system" fn IsGroupLabelVisible<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroupLabelVisible<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsGroupLabelVisible(value).into()
        }
        unsafe extern "system" fn CalendarViewDayItemChanging<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemChanging(&*(&handler as *const <CalendarViewDayItemChangingEventHandler as ::windows::core::Abi>::Abi as *const <CalendarViewDayItemChangingEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCalendarViewDayItemChanging<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCalendarViewDayItemChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DateChanged<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDateChanged<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDisplayDate<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, date: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayDate(&*(&date as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetYearDecadeDisplayDimensions<Impl: ICalendarDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, columns: i32, rows: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearDecadeDisplayDimensions(columns, rows).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePicker, BASE_OFFSET>(),
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDate: SetDate::<Impl, IMPL_OFFSET>,
            IsCalendarOpen: IsCalendarOpen::<Impl, IMPL_OFFSET>,
            SetIsCalendarOpen: SetIsCalendarOpen::<Impl, IMPL_OFFSET>,
            DateFormat: DateFormat::<Impl, IMPL_OFFSET>,
            SetDateFormat: SetDateFormat::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            CalendarViewStyle: CalendarViewStyle::<Impl, IMPL_OFFSET>,
            SetCalendarViewStyle: SetCalendarViewStyle::<Impl, IMPL_OFFSET>,
            MinDate: MinDate::<Impl, IMPL_OFFSET>,
            SetMinDate: SetMinDate::<Impl, IMPL_OFFSET>,
            MaxDate: MaxDate::<Impl, IMPL_OFFSET>,
            SetMaxDate: SetMaxDate::<Impl, IMPL_OFFSET>,
            IsTodayHighlighted: IsTodayHighlighted::<Impl, IMPL_OFFSET>,
            SetIsTodayHighlighted: SetIsTodayHighlighted::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            SetDisplayMode: SetDisplayMode::<Impl, IMPL_OFFSET>,
            FirstDayOfWeek: FirstDayOfWeek::<Impl, IMPL_OFFSET>,
            SetFirstDayOfWeek: SetFirstDayOfWeek::<Impl, IMPL_OFFSET>,
            DayOfWeekFormat: DayOfWeekFormat::<Impl, IMPL_OFFSET>,
            SetDayOfWeekFormat: SetDayOfWeekFormat::<Impl, IMPL_OFFSET>,
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabled: IsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            SetIsOutOfScopeEnabled: SetIsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisible: IsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            SetIsGroupLabelVisible: SetIsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemChanging: CalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            RemoveCalendarViewDayItemChanging: RemoveCalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            DateChanged: DateChanged::<Impl, IMPL_OFFSET>,
            RemoveDateChanged: RemoveDateChanged::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            SetDisplayDate: SetDisplayDate::<Impl, IMPL_OFFSET>,
            SetYearDecadeDisplayDimensions: SetYearDecadeDisplayDimensions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePicker2Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePicker2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePicker2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePicker2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ICalendarDatePicker2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ICalendarDatePicker2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePicker2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePicker2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePicker3Impl: Sized {
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker3";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePicker3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePicker3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePicker3Vtbl {
        unsafe extern "system" fn Description<Impl: ICalendarDatePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: ICalendarDatePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePicker3, BASE_OFFSET>(),
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePicker3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICalendarDatePickerDateChangedEventArgsImpl: Sized {
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarDatePickerDateChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerDateChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICalendarDatePickerDateChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerDateChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerDateChangedEventArgsVtbl {
        unsafe extern "system" fn NewDate<Impl: ICalendarDatePickerDateChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OldDate<Impl: ICalendarDatePickerDateChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerDateChangedEventArgs, BASE_OFFSET>(),
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerDateChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarDatePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarDatePickerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStaticsImpl: Sized {
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCalendarOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarViewStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTodayHighlightedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstDayOfWeekProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayOfWeekFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOutOfScopeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupLabelVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerStaticsVtbl {
        unsafe extern "system" fn DateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCalendarOpenProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCalendarOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateFormatProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarViewStyleProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinDateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTodayHighlightedProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlightedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstDayOfWeekProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayOfWeekFormatProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOutOfScopeEnabledProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupLabelVisibleProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerStatics, BASE_OFFSET>(),
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
            IsCalendarOpenProperty: IsCalendarOpenProperty::<Impl, IMPL_OFFSET>,
            DateFormatProperty: DateFormatProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            CalendarViewStyleProperty: CalendarViewStyleProperty::<Impl, IMPL_OFFSET>,
            MinDateProperty: MinDateProperty::<Impl, IMPL_OFFSET>,
            MaxDateProperty: MaxDateProperty::<Impl, IMPL_OFFSET>,
            IsTodayHighlightedProperty: IsTodayHighlightedProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            FirstDayOfWeekProperty: FirstDayOfWeekProperty::<Impl, IMPL_OFFSET>,
            DayOfWeekFormatProperty: DayOfWeekFormatProperty::<Impl, IMPL_OFFSET>,
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabledProperty: IsOutOfScopeEnabledProperty::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisibleProperty: IsGroupLabelVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ICalendarDatePickerStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStatics3Impl: Sized {
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerStatics3Vtbl {
        unsafe extern "system" fn DescriptionProperty<Impl: ICalendarDatePickerStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerStatics3, BASE_OFFSET>(),
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Globalization", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ICalendarViewImpl: Sized {
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn DayOfWeekFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayOfWeekFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsGroupLabelVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsGroupLabelVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<CalendarViewDisplayMode>;
    fn SetDisplayMode(&mut self, value: CalendarViewDisplayMode) -> ::windows::core::Result<()>;
    fn FirstDayOfWeek(&mut self) -> ::windows::core::Result<super::super::super::Globalization::DayOfWeek>;
    fn SetFirstDayOfWeek(&mut self, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::Result<()>;
    fn IsOutOfScopeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOutOfScopeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsTodayHighlighted(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTodayHighlighted(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MinDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn NumberOfWeeksInView(&mut self) -> ::windows::core::Result<i32>;
    fn SetNumberOfWeeksInView(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedDates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::DateTime>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<CalendarViewSelectionMode>;
    fn SetSelectionMode(&mut self, value: CalendarViewSelectionMode) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::CalendarViewTemplateSettings>;
    fn FocusBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetFocusBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedHoverBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedHoverBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedPressedBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedPressedBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HoverBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHoverBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PressedBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPressedBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PressedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPressedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DayItemFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetDayItemFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn DayItemFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetDayItemFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn DayItemFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetDayItemFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn DayItemFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetDayItemFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn TodayFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetTodayFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFirstOfMonthLabelFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFirstOfMonthLabelFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFirstOfMonthLabelFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFirstOfMonthLabelFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn MonthYearItemFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetMonthYearItemFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn MonthYearItemFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetMonthYearItemFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MonthYearItemFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetMonthYearItemFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn MonthYearItemFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetMonthYearItemFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFirstOfYearDecadeLabelFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFirstOfYearDecadeLabelFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFirstOfYearDecadeLabelFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFirstOfYearDecadeLabelFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn HorizontalDayItemAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalDayItemAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalDayItemAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalDayItemAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn HorizontalFirstOfMonthLabelAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalFirstOfMonthLabelAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalFirstOfMonthLabelAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalFirstOfMonthLabelAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn CalendarItemBorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetCalendarItemBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCalendarViewDayItemStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCalendarViewDayItemChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectedDatesChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedDatesChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDisplayDate(&mut self, date: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn SetYearDecadeDisplayDimensions(&mut self, columns: i32, rows: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Globalization", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarView";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Globalization", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ICalendarViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewVtbl {
        unsafe extern "system" fn CalendarIdentifier<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayOfWeekFormat<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayOfWeekFormat<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayOfWeekFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGroupLabelVisible<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroupLabelVisible<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsGroupLabelVisible(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn FirstDayOfWeek<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstDayOfWeek<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstDayOfWeek(value).into()
        }
        unsafe extern "system" fn IsOutOfScopeEnabled<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOutOfScopeEnabled<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOutOfScopeEnabled(value).into()
        }
        unsafe extern "system" fn IsTodayHighlighted<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTodayHighlighted<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTodayHighlighted(value).into()
        }
        unsafe extern "system" fn MaxDate<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDate<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinDate<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinDate<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NumberOfWeeksInView<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumberOfWeeksInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNumberOfWeeksInView<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNumberOfWeeksInView(value).into()
        }
        unsafe extern "system" fn SelectedDates<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CalendarViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocusBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedHoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedHoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedHoverBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedPressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedPressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedPressedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HoverBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHoverBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPressedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBorderBrush<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeBackground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeBackground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemBackground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBackground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PressedForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPressedForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlackoutForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemForeground<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontSize(value).into()
        }
        unsafe extern "system" fn DayItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontStyle(value).into()
        }
        unsafe extern "system" fn DayItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontSize(value).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontStyle(value).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontSize(value).into()
        }
        unsafe extern "system" fn MonthYearItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontStyle(value).into()
        }
        unsafe extern "system" fn MonthYearItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontSize(value).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontStyle(value).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalDayItemAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalDayItemAlignment(value).into()
        }
        unsafe extern "system" fn VerticalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalDayItemAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalDayItemAlignment(value).into()
        }
        unsafe extern "system" fn HorizontalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalFirstOfMonthLabelAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalFirstOfMonthLabelAlignment(value).into()
        }
        unsafe extern "system" fn VerticalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalFirstOfMonthLabelAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalFirstOfMonthLabelAlignment(value).into()
        }
        unsafe extern "system" fn CalendarItemBorderThickness<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBorderThickness<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewDayItemStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarViewDayItemStyle<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarViewDayItemStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewDayItemChanging<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCalendarViewDayItemChanging<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCalendarViewDayItemChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDatesChanged<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDatesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedDatesChanged<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectedDatesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDisplayDate<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, date: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayDate(&*(&date as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetYearDecadeDisplayDimensions<Impl: ICalendarViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, columns: i32, rows: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearDecadeDisplayDimensions(columns, rows).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarView, BASE_OFFSET>(),
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            DayOfWeekFormat: DayOfWeekFormat::<Impl, IMPL_OFFSET>,
            SetDayOfWeekFormat: SetDayOfWeekFormat::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisible: IsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            SetIsGroupLabelVisible: SetIsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            SetDisplayMode: SetDisplayMode::<Impl, IMPL_OFFSET>,
            FirstDayOfWeek: FirstDayOfWeek::<Impl, IMPL_OFFSET>,
            SetFirstDayOfWeek: SetFirstDayOfWeek::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabled: IsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            SetIsOutOfScopeEnabled: SetIsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            IsTodayHighlighted: IsTodayHighlighted::<Impl, IMPL_OFFSET>,
            SetIsTodayHighlighted: SetIsTodayHighlighted::<Impl, IMPL_OFFSET>,
            MaxDate: MaxDate::<Impl, IMPL_OFFSET>,
            SetMaxDate: SetMaxDate::<Impl, IMPL_OFFSET>,
            MinDate: MinDate::<Impl, IMPL_OFFSET>,
            SetMinDate: SetMinDate::<Impl, IMPL_OFFSET>,
            NumberOfWeeksInView: NumberOfWeeksInView::<Impl, IMPL_OFFSET>,
            SetNumberOfWeeksInView: SetNumberOfWeeksInView::<Impl, IMPL_OFFSET>,
            SelectedDates: SelectedDates::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            FocusBorderBrush: FocusBorderBrush::<Impl, IMPL_OFFSET>,
            SetFocusBorderBrush: SetFocusBorderBrush::<Impl, IMPL_OFFSET>,
            SelectedHoverBorderBrush: SelectedHoverBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedHoverBorderBrush: SetSelectedHoverBorderBrush::<Impl, IMPL_OFFSET>,
            SelectedPressedBorderBrush: SelectedPressedBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedPressedBorderBrush: SetSelectedPressedBorderBrush::<Impl, IMPL_OFFSET>,
            SelectedBorderBrush: SelectedBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedBorderBrush: SetSelectedBorderBrush::<Impl, IMPL_OFFSET>,
            HoverBorderBrush: HoverBorderBrush::<Impl, IMPL_OFFSET>,
            SetHoverBorderBrush: SetHoverBorderBrush::<Impl, IMPL_OFFSET>,
            PressedBorderBrush: PressedBorderBrush::<Impl, IMPL_OFFSET>,
            SetPressedBorderBrush: SetPressedBorderBrush::<Impl, IMPL_OFFSET>,
            CalendarItemBorderBrush: CalendarItemBorderBrush::<Impl, IMPL_OFFSET>,
            SetCalendarItemBorderBrush: SetCalendarItemBorderBrush::<Impl, IMPL_OFFSET>,
            OutOfScopeBackground: OutOfScopeBackground::<Impl, IMPL_OFFSET>,
            SetOutOfScopeBackground: SetOutOfScopeBackground::<Impl, IMPL_OFFSET>,
            CalendarItemBackground: CalendarItemBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemBackground: SetCalendarItemBackground::<Impl, IMPL_OFFSET>,
            PressedForeground: PressedForeground::<Impl, IMPL_OFFSET>,
            SetPressedForeground: SetPressedForeground::<Impl, IMPL_OFFSET>,
            TodayForeground: TodayForeground::<Impl, IMPL_OFFSET>,
            SetTodayForeground: SetTodayForeground::<Impl, IMPL_OFFSET>,
            BlackoutForeground: BlackoutForeground::<Impl, IMPL_OFFSET>,
            SetBlackoutForeground: SetBlackoutForeground::<Impl, IMPL_OFFSET>,
            SelectedForeground: SelectedForeground::<Impl, IMPL_OFFSET>,
            SetSelectedForeground: SetSelectedForeground::<Impl, IMPL_OFFSET>,
            OutOfScopeForeground: OutOfScopeForeground::<Impl, IMPL_OFFSET>,
            SetOutOfScopeForeground: SetOutOfScopeForeground::<Impl, IMPL_OFFSET>,
            CalendarItemForeground: CalendarItemForeground::<Impl, IMPL_OFFSET>,
            SetCalendarItemForeground: SetCalendarItemForeground::<Impl, IMPL_OFFSET>,
            DayItemFontFamily: DayItemFontFamily::<Impl, IMPL_OFFSET>,
            SetDayItemFontFamily: SetDayItemFontFamily::<Impl, IMPL_OFFSET>,
            DayItemFontSize: DayItemFontSize::<Impl, IMPL_OFFSET>,
            SetDayItemFontSize: SetDayItemFontSize::<Impl, IMPL_OFFSET>,
            DayItemFontStyle: DayItemFontStyle::<Impl, IMPL_OFFSET>,
            SetDayItemFontStyle: SetDayItemFontStyle::<Impl, IMPL_OFFSET>,
            DayItemFontWeight: DayItemFontWeight::<Impl, IMPL_OFFSET>,
            SetDayItemFontWeight: SetDayItemFontWeight::<Impl, IMPL_OFFSET>,
            TodayFontWeight: TodayFontWeight::<Impl, IMPL_OFFSET>,
            SetTodayFontWeight: SetTodayFontWeight::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontFamily: FirstOfMonthLabelFontFamily::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontFamily: SetFirstOfMonthLabelFontFamily::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontSize: FirstOfMonthLabelFontSize::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontSize: SetFirstOfMonthLabelFontSize::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontStyle: FirstOfMonthLabelFontStyle::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontStyle: SetFirstOfMonthLabelFontStyle::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontWeight: FirstOfMonthLabelFontWeight::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontWeight: SetFirstOfMonthLabelFontWeight::<Impl, IMPL_OFFSET>,
            MonthYearItemFontFamily: MonthYearItemFontFamily::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontFamily: SetMonthYearItemFontFamily::<Impl, IMPL_OFFSET>,
            MonthYearItemFontSize: MonthYearItemFontSize::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontSize: SetMonthYearItemFontSize::<Impl, IMPL_OFFSET>,
            MonthYearItemFontStyle: MonthYearItemFontStyle::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontStyle: SetMonthYearItemFontStyle::<Impl, IMPL_OFFSET>,
            MonthYearItemFontWeight: MonthYearItemFontWeight::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontWeight: SetMonthYearItemFontWeight::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontFamily: FirstOfYearDecadeLabelFontFamily::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontFamily: SetFirstOfYearDecadeLabelFontFamily::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontSize: FirstOfYearDecadeLabelFontSize::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontSize: SetFirstOfYearDecadeLabelFontSize::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontStyle: FirstOfYearDecadeLabelFontStyle::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontStyle: SetFirstOfYearDecadeLabelFontStyle::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontWeight: FirstOfYearDecadeLabelFontWeight::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontWeight: SetFirstOfYearDecadeLabelFontWeight::<Impl, IMPL_OFFSET>,
            HorizontalDayItemAlignment: HorizontalDayItemAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalDayItemAlignment: SetHorizontalDayItemAlignment::<Impl, IMPL_OFFSET>,
            VerticalDayItemAlignment: VerticalDayItemAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalDayItemAlignment: SetVerticalDayItemAlignment::<Impl, IMPL_OFFSET>,
            HorizontalFirstOfMonthLabelAlignment: HorizontalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalFirstOfMonthLabelAlignment: SetHorizontalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            VerticalFirstOfMonthLabelAlignment: VerticalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalFirstOfMonthLabelAlignment: SetVerticalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            CalendarItemBorderThickness: CalendarItemBorderThickness::<Impl, IMPL_OFFSET>,
            SetCalendarItemBorderThickness: SetCalendarItemBorderThickness::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemStyle: CalendarViewDayItemStyle::<Impl, IMPL_OFFSET>,
            SetCalendarViewDayItemStyle: SetCalendarViewDayItemStyle::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemChanging: CalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            RemoveCalendarViewDayItemChanging: RemoveCalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            SelectedDatesChanged: SelectedDatesChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectedDatesChanged: RemoveSelectedDatesChanged::<Impl, IMPL_OFFSET>,
            SetDisplayDate: SetDisplayDate::<Impl, IMPL_OFFSET>,
            SetYearDecadeDisplayDimensions: SetYearDecadeDisplayDimensions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ICalendarView2Impl: Sized {
    fn SelectedDisabledBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedDisabledBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodaySelectedInnerBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodaySelectedInnerBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutStrikethroughBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutStrikethroughBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemHoverBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemHoverBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemPressedBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemPressedBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemDisabledBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemDisabledBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBlackoutBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBlackoutBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayHoverBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayHoverBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayPressedBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayPressedBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayDisabledBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayDisabledBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBlackoutForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBlackoutForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedHoverForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedHoverForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedPressedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedPressedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedDisabledForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedDisabledForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeHoverForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeHoverForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopePressedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopePressedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DisabledForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetDisabledForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DayItemMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetDayItemMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn MonthYearItemMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetMonthYearItemMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetFirstOfMonthLabelMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetFirstOfYearDecadeLabelMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CalendarItemCornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCalendarItemCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarView2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ICalendarView2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarView2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarView2Vtbl {
        unsafe extern "system" fn SelectedDisabledBorderBrush<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDisabledBorderBrush<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedDisabledBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodaySelectedInnerBorderBrush<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodaySelectedInnerBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodaySelectedInnerBorderBrush<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodaySelectedInnerBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutStrikethroughBrush<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutStrikethroughBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutStrikethroughBrush<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlackoutStrikethroughBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlackoutBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemHoverBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemHoverBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemHoverBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemHoverBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemPressedBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemPressedBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemPressedBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemPressedBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemDisabledBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemDisabledBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayBlackoutBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayHoverBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayHoverBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayHoverBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayHoverBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayPressedBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayPressedBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayPressedBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayPressedBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayDisabledBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayDisabledBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBlackoutForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBlackoutForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayBlackoutForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedHoverForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedHoverForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedHoverForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedPressedForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedPressedForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedPressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDisabledForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDisabledForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedDisabledForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeHoverForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeHoverForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeHoverForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeHoverForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopePressedForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopePressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopePressedForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopePressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisabledForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledForeground<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelMargin<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemCornerRadius<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemCornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemCornerRadius<Impl: ICalendarView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarView2, BASE_OFFSET>(),
            SelectedDisabledBorderBrush: SelectedDisabledBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedDisabledBorderBrush: SetSelectedDisabledBorderBrush::<Impl, IMPL_OFFSET>,
            TodaySelectedInnerBorderBrush: TodaySelectedInnerBorderBrush::<Impl, IMPL_OFFSET>,
            SetTodaySelectedInnerBorderBrush: SetTodaySelectedInnerBorderBrush::<Impl, IMPL_OFFSET>,
            BlackoutStrikethroughBrush: BlackoutStrikethroughBrush::<Impl, IMPL_OFFSET>,
            SetBlackoutStrikethroughBrush: SetBlackoutStrikethroughBrush::<Impl, IMPL_OFFSET>,
            BlackoutBackground: BlackoutBackground::<Impl, IMPL_OFFSET>,
            SetBlackoutBackground: SetBlackoutBackground::<Impl, IMPL_OFFSET>,
            CalendarItemHoverBackground: CalendarItemHoverBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemHoverBackground: SetCalendarItemHoverBackground::<Impl, IMPL_OFFSET>,
            CalendarItemPressedBackground: CalendarItemPressedBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemPressedBackground: SetCalendarItemPressedBackground::<Impl, IMPL_OFFSET>,
            CalendarItemDisabledBackground: CalendarItemDisabledBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemDisabledBackground: SetCalendarItemDisabledBackground::<Impl, IMPL_OFFSET>,
            TodayBackground: TodayBackground::<Impl, IMPL_OFFSET>,
            SetTodayBackground: SetTodayBackground::<Impl, IMPL_OFFSET>,
            TodayBlackoutBackground: TodayBlackoutBackground::<Impl, IMPL_OFFSET>,
            SetTodayBlackoutBackground: SetTodayBlackoutBackground::<Impl, IMPL_OFFSET>,
            TodayHoverBackground: TodayHoverBackground::<Impl, IMPL_OFFSET>,
            SetTodayHoverBackground: SetTodayHoverBackground::<Impl, IMPL_OFFSET>,
            TodayPressedBackground: TodayPressedBackground::<Impl, IMPL_OFFSET>,
            SetTodayPressedBackground: SetTodayPressedBackground::<Impl, IMPL_OFFSET>,
            TodayDisabledBackground: TodayDisabledBackground::<Impl, IMPL_OFFSET>,
            SetTodayDisabledBackground: SetTodayDisabledBackground::<Impl, IMPL_OFFSET>,
            TodayBlackoutForeground: TodayBlackoutForeground::<Impl, IMPL_OFFSET>,
            SetTodayBlackoutForeground: SetTodayBlackoutForeground::<Impl, IMPL_OFFSET>,
            SelectedHoverForeground: SelectedHoverForeground::<Impl, IMPL_OFFSET>,
            SetSelectedHoverForeground: SetSelectedHoverForeground::<Impl, IMPL_OFFSET>,
            SelectedPressedForeground: SelectedPressedForeground::<Impl, IMPL_OFFSET>,
            SetSelectedPressedForeground: SetSelectedPressedForeground::<Impl, IMPL_OFFSET>,
            SelectedDisabledForeground: SelectedDisabledForeground::<Impl, IMPL_OFFSET>,
            SetSelectedDisabledForeground: SetSelectedDisabledForeground::<Impl, IMPL_OFFSET>,
            OutOfScopeHoverForeground: OutOfScopeHoverForeground::<Impl, IMPL_OFFSET>,
            SetOutOfScopeHoverForeground: SetOutOfScopeHoverForeground::<Impl, IMPL_OFFSET>,
            OutOfScopePressedForeground: OutOfScopePressedForeground::<Impl, IMPL_OFFSET>,
            SetOutOfScopePressedForeground: SetOutOfScopePressedForeground::<Impl, IMPL_OFFSET>,
            DisabledForeground: DisabledForeground::<Impl, IMPL_OFFSET>,
            SetDisabledForeground: SetDisabledForeground::<Impl, IMPL_OFFSET>,
            DayItemMargin: DayItemMargin::<Impl, IMPL_OFFSET>,
            SetDayItemMargin: SetDayItemMargin::<Impl, IMPL_OFFSET>,
            MonthYearItemMargin: MonthYearItemMargin::<Impl, IMPL_OFFSET>,
            SetMonthYearItemMargin: SetMonthYearItemMargin::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelMargin: FirstOfMonthLabelMargin::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelMargin: SetFirstOfMonthLabelMargin::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelMargin: FirstOfYearDecadeLabelMargin::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelMargin: SetFirstOfYearDecadeLabelMargin::<Impl, IMPL_OFFSET>,
            CalendarItemCornerRadius: CalendarItemCornerRadius::<Impl, IMPL_OFFSET>,
            SetCalendarItemCornerRadius: SetCalendarItemCornerRadius::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICalendarViewDayItemImpl: Sized {
    fn IsBlackout(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsBlackout(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDensityColors(&mut self, colors: &::core::option::Option<super::super::super::Foundation::Collections::IIterable<super::super::Color>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarViewDayItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItem";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICalendarViewDayItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItemVtbl {
        unsafe extern "system" fn IsBlackout<Impl: ICalendarViewDayItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBlackout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBlackout<Impl: ICalendarViewDayItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsBlackout(value).into()
        }
        unsafe extern "system" fn Date<Impl: ICalendarViewDayItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDensityColors<Impl: ICalendarViewDayItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, colors: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDensityColors(&*(&colors as *const <super::super::super::Foundation::Collections::IIterable<super::super::Color> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IIterable<super::super::Color> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItem, BASE_OFFSET>(),
            IsBlackout: IsBlackout::<Impl, IMPL_OFFSET>,
            SetIsBlackout: SetIsBlackout::<Impl, IMPL_OFFSET>,
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDensityColors: SetDensityColors::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItem as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICalendarViewDayItemChangingEventArgsImpl: Sized {
    fn InRecycleQueue(&mut self) -> ::windows::core::Result<bool>;
    fn Item(&mut self) -> ::windows::core::Result<CalendarViewDayItem>;
    fn Phase(&mut self) -> ::windows::core::Result<u32>;
    fn RegisterUpdateCallback(&mut self, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallbackWithPhase(&mut self, callbackphase: u32, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarViewDayItemChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemChangingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICalendarViewDayItemChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItemChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItemChangingEventArgsVtbl {
        unsafe extern "system" fn InRecycleQueue<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InRecycleQueue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Phase<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Phase() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterUpdateCallback<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallback(&*(&callback as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RegisterUpdateCallbackWithPhase<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callbackphase: u32, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallbackWithPhase(callbackphase, &*(&callback as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItemChangingEventArgs, BASE_OFFSET>(),
            InRecycleQueue: InRecycleQueue::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Phase: Phase::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallback: RegisterUpdateCallback::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallbackWithPhase: RegisterUpdateCallbackWithPhase::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItemChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarViewDayItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarViewDayItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemStaticsImpl: Sized {
    fn IsBlackoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItemStaticsVtbl {
        unsafe extern "system" fn IsBlackoutProperty<Impl: ICalendarViewDayItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBlackoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: ICalendarViewDayItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItemStatics, BASE_OFFSET>(),
            IsBlackoutProperty: IsBlackoutProperty::<Impl, IMPL_OFFSET>,
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICalendarViewSelectedDatesChangedEventArgsImpl: Sized {
    fn AddedDates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::super::super::Foundation::DateTime>>;
    fn RemovedDates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::super::super::Foundation::DateTime>>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarViewSelectedDatesChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewSelectedDatesChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICalendarViewSelectedDatesChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewSelectedDatesChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewSelectedDatesChangedEventArgsVtbl {
        unsafe extern "system" fn AddedDates<Impl: ICalendarViewSelectedDatesChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedDates<Impl: ICalendarViewSelectedDatesChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewSelectedDatesChangedEventArgs, BASE_OFFSET>(),
            AddedDates: AddedDates::<Impl, IMPL_OFFSET>,
            RemovedDates: RemovedDates::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewSelectedDatesChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewStaticsImpl: Sized {
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayOfWeekFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupLabelVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstDayOfWeekProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOutOfScopeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTodayHighlightedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NumberOfWeeksInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedDatesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedHoverBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedPressedBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HoverBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PressedBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PressedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalDayItemAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalDayItemAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalFirstOfMonthLabelAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalFirstOfMonthLabelAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarViewDayItemStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewStaticsVtbl {
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayOfWeekFormatProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupLabelVisibleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstDayOfWeekProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOutOfScopeEnabledProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTodayHighlightedProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlightedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDateProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinDateProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumberOfWeeksInViewProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumberOfWeeksInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedDatesProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDatesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionModeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedHoverBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedPressedBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HoverBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HoverBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PressedBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeBackgroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBackgroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PressedForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalDayItemAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalDayItemAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalDayItemAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalDayItemAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalFirstOfMonthLabelAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalFirstOfMonthLabelAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalFirstOfMonthLabelAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalFirstOfMonthLabelAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBorderThicknessProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarViewDayItemStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewStatics, BASE_OFFSET>(),
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            DayOfWeekFormatProperty: DayOfWeekFormatProperty::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisibleProperty: IsGroupLabelVisibleProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            FirstDayOfWeekProperty: FirstDayOfWeekProperty::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabledProperty: IsOutOfScopeEnabledProperty::<Impl, IMPL_OFFSET>,
            IsTodayHighlightedProperty: IsTodayHighlightedProperty::<Impl, IMPL_OFFSET>,
            MaxDateProperty: MaxDateProperty::<Impl, IMPL_OFFSET>,
            MinDateProperty: MinDateProperty::<Impl, IMPL_OFFSET>,
            NumberOfWeeksInViewProperty: NumberOfWeeksInViewProperty::<Impl, IMPL_OFFSET>,
            SelectedDatesProperty: SelectedDatesProperty::<Impl, IMPL_OFFSET>,
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
            TemplateSettingsProperty: TemplateSettingsProperty::<Impl, IMPL_OFFSET>,
            FocusBorderBrushProperty: FocusBorderBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedHoverBorderBrushProperty: SelectedHoverBorderBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedPressedBorderBrushProperty: SelectedPressedBorderBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedBorderBrushProperty: SelectedBorderBrushProperty::<Impl, IMPL_OFFSET>,
            HoverBorderBrushProperty: HoverBorderBrushProperty::<Impl, IMPL_OFFSET>,
            PressedBorderBrushProperty: PressedBorderBrushProperty::<Impl, IMPL_OFFSET>,
            CalendarItemBorderBrushProperty: CalendarItemBorderBrushProperty::<Impl, IMPL_OFFSET>,
            OutOfScopeBackgroundProperty: OutOfScopeBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemBackgroundProperty: CalendarItemBackgroundProperty::<Impl, IMPL_OFFSET>,
            PressedForegroundProperty: PressedForegroundProperty::<Impl, IMPL_OFFSET>,
            TodayForegroundProperty: TodayForegroundProperty::<Impl, IMPL_OFFSET>,
            BlackoutForegroundProperty: BlackoutForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedForegroundProperty: SelectedForegroundProperty::<Impl, IMPL_OFFSET>,
            OutOfScopeForegroundProperty: OutOfScopeForegroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemForegroundProperty: CalendarItemForegroundProperty::<Impl, IMPL_OFFSET>,
            DayItemFontFamilyProperty: DayItemFontFamilyProperty::<Impl, IMPL_OFFSET>,
            DayItemFontSizeProperty: DayItemFontSizeProperty::<Impl, IMPL_OFFSET>,
            DayItemFontStyleProperty: DayItemFontStyleProperty::<Impl, IMPL_OFFSET>,
            DayItemFontWeightProperty: DayItemFontWeightProperty::<Impl, IMPL_OFFSET>,
            TodayFontWeightProperty: TodayFontWeightProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontFamilyProperty: FirstOfMonthLabelFontFamilyProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontSizeProperty: FirstOfMonthLabelFontSizeProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontStyleProperty: FirstOfMonthLabelFontStyleProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontWeightProperty: FirstOfMonthLabelFontWeightProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontFamilyProperty: MonthYearItemFontFamilyProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontSizeProperty: MonthYearItemFontSizeProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontStyleProperty: MonthYearItemFontStyleProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontWeightProperty: MonthYearItemFontWeightProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontFamilyProperty: FirstOfYearDecadeLabelFontFamilyProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontSizeProperty: FirstOfYearDecadeLabelFontSizeProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontStyleProperty: FirstOfYearDecadeLabelFontStyleProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontWeightProperty: FirstOfYearDecadeLabelFontWeightProperty::<Impl, IMPL_OFFSET>,
            HorizontalDayItemAlignmentProperty: HorizontalDayItemAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalDayItemAlignmentProperty: VerticalDayItemAlignmentProperty::<Impl, IMPL_OFFSET>,
            HorizontalFirstOfMonthLabelAlignmentProperty: HorizontalFirstOfMonthLabelAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalFirstOfMonthLabelAlignmentProperty: VerticalFirstOfMonthLabelAlignmentProperty::<Impl, IMPL_OFFSET>,
            CalendarItemBorderThicknessProperty: CalendarItemBorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemStyleProperty: CalendarViewDayItemStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewStatics2Impl: Sized {
    fn SelectedDisabledBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodaySelectedInnerBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutStrikethroughBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemHoverBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemPressedBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemDisabledBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBlackoutBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayHoverBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayPressedBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayDisabledBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBlackoutForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedHoverForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedPressedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedDisabledForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeHoverForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopePressedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisabledForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemCornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewStatics2Vtbl {
        unsafe extern "system" fn SelectedDisabledBorderBrushProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodaySelectedInnerBorderBrushProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodaySelectedInnerBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutStrikethroughBrushProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutStrikethroughBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemHoverBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemHoverBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemPressedBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemPressedBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemDisabledBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemDisabledBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBlackoutBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayHoverBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayHoverBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayPressedBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayPressedBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayDisabledBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayDisabledBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBlackoutForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedHoverForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedPressedForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedDisabledForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeHoverForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeHoverForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopePressedForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopePressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisabledForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemCornerRadiusProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemCornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewStatics2, BASE_OFFSET>(),
            SelectedDisabledBorderBrushProperty: SelectedDisabledBorderBrushProperty::<Impl, IMPL_OFFSET>,
            TodaySelectedInnerBorderBrushProperty: TodaySelectedInnerBorderBrushProperty::<Impl, IMPL_OFFSET>,
            BlackoutStrikethroughBrushProperty: BlackoutStrikethroughBrushProperty::<Impl, IMPL_OFFSET>,
            BlackoutBackgroundProperty: BlackoutBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemHoverBackgroundProperty: CalendarItemHoverBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemPressedBackgroundProperty: CalendarItemPressedBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemDisabledBackgroundProperty: CalendarItemDisabledBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayBackgroundProperty: TodayBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayBlackoutBackgroundProperty: TodayBlackoutBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayHoverBackgroundProperty: TodayHoverBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayPressedBackgroundProperty: TodayPressedBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayDisabledBackgroundProperty: TodayDisabledBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayBlackoutForegroundProperty: TodayBlackoutForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedHoverForegroundProperty: SelectedHoverForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedPressedForegroundProperty: SelectedPressedForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedDisabledForegroundProperty: SelectedDisabledForegroundProperty::<Impl, IMPL_OFFSET>,
            OutOfScopeHoverForegroundProperty: OutOfScopeHoverForegroundProperty::<Impl, IMPL_OFFSET>,
            OutOfScopePressedForegroundProperty: OutOfScopePressedForegroundProperty::<Impl, IMPL_OFFSET>,
            DisabledForegroundProperty: DisabledForegroundProperty::<Impl, IMPL_OFFSET>,
            DayItemMarginProperty: DayItemMarginProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemMarginProperty: MonthYearItemMarginProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelMarginProperty: FirstOfMonthLabelMarginProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelMarginProperty: FirstOfYearDecadeLabelMarginProperty::<Impl, IMPL_OFFSET>,
            CalendarItemCornerRadiusProperty: CalendarItemCornerRadiusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICandidateWindowBoundsChangedEventArgsImpl: Sized {
    fn Bounds(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICandidateWindowBoundsChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICandidateWindowBoundsChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICandidateWindowBoundsChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICandidateWindowBoundsChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICandidateWindowBoundsChangedEventArgsVtbl {
        unsafe extern "system" fn Bounds<Impl: ICandidateWindowBoundsChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Bounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICandidateWindowBoundsChangedEventArgs, BASE_OFFSET>(),
            Bounds: Bounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICandidateWindowBoundsChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvas {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvas";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICanvasImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICanvasVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICanvas, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICanvas as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Canvas>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvasFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvasFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICanvasFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICanvasFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICanvasFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICanvasFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICanvasFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasStaticsImpl: Sized {
    fn LeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetLeft(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<f64>;
    fn SetLeft(&mut self, element: &::core::option::Option<super::UIElement>, length: f64) -> ::windows::core::Result<()>;
    fn TopProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetTop(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<f64>;
    fn SetTop(&mut self, element: &::core::option::Option<super::UIElement>, length: f64) -> ::windows::core::Result<()>;
    fn ZIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetZIndex(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetZIndex(&mut self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvasStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvasStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICanvasStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICanvasStaticsVtbl {
        unsafe extern "system" fn LeftProperty<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeft<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLeft(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeft<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, length: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeft(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), length).into()
        }
        unsafe extern "system" fn TopProperty<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTop<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTop(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTop<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, length: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTop(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), length).into()
        }
        unsafe extern "system" fn ZIndexProperty<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZIndex<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetZIndex(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZIndex<Impl: ICanvasStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZIndex(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICanvasStatics, BASE_OFFSET>(),
            LeftProperty: LeftProperty::<Impl, IMPL_OFFSET>,
            GetLeft: GetLeft::<Impl, IMPL_OFFSET>,
            SetLeft: SetLeft::<Impl, IMPL_OFFSET>,
            TopProperty: TopProperty::<Impl, IMPL_OFFSET>,
            GetTop: GetTop::<Impl, IMPL_OFFSET>,
            SetTop: SetTop::<Impl, IMPL_OFFSET>,
            ZIndexProperty: ZIndexProperty::<Impl, IMPL_OFFSET>,
            GetZIndex: GetZIndex::<Impl, IMPL_OFFSET>,
            SetZIndex: SetZIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICanvasStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Capture", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ICaptureElementImpl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Media::Capture::MediaCapture>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Media::Capture::MediaCapture>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Media_Capture", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICaptureElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICaptureElement";
}
#[cfg(all(feature = "Media_Capture", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ICaptureElementVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICaptureElementImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICaptureElementVtbl {
        unsafe extern "system" fn Source<Impl: ICaptureElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: ICaptureElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Media::Capture::MediaCapture as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Capture::MediaCapture as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: ICaptureElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: ICaptureElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICaptureElement, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICaptureElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICaptureElementStaticsImpl: Sized {
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICaptureElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICaptureElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICaptureElementStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICaptureElementStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICaptureElementStaticsVtbl {
        unsafe extern "system" fn SourceProperty<Impl: ICaptureElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: ICaptureElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICaptureElementStatics, BASE_OFFSET>(),
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICaptureElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICheckBoxImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICheckBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICheckBox";
}
#[cfg(feature = "implement_exclusive")]
impl ICheckBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICheckBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICheckBoxVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICheckBox, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICheckBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICheckBoxFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CheckBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICheckBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICheckBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICheckBoxFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICheckBoxFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICheckBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICheckBoxFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICheckBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICheckBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IChoosingGroupHeaderContainerEventArgsImpl: Sized {
    fn GroupHeaderContainer(&mut self) -> ::windows::core::Result<ListViewBaseHeaderItem>;
    fn SetGroupHeaderContainer(&mut self, value: &::core::option::Option<ListViewBaseHeaderItem>) -> ::windows::core::Result<()>;
    fn GroupIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Group(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IChoosingGroupHeaderContainerEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IChoosingGroupHeaderContainerEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IChoosingGroupHeaderContainerEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IChoosingGroupHeaderContainerEventArgsVtbl {
        unsafe extern "system" fn GroupHeaderContainer<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderContainer<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderContainer(&*(&value as *const <ListViewBaseHeaderItem as ::windows::core::Abi>::Abi as *const <ListViewBaseHeaderItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GroupIndex<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Group<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Group() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IChoosingGroupHeaderContainerEventArgs, BASE_OFFSET>(),
            GroupHeaderContainer: GroupHeaderContainer::<Impl, IMPL_OFFSET>,
            SetGroupHeaderContainer: SetGroupHeaderContainer::<Impl, IMPL_OFFSET>,
            GroupIndex: GroupIndex::<Impl, IMPL_OFFSET>,
            Group: Group::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IChoosingGroupHeaderContainerEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IChoosingItemContainerEventArgsImpl: Sized {
    fn ItemIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ItemContainer(&mut self) -> ::windows::core::Result<Primitives::SelectorItem>;
    fn SetItemContainer(&mut self, value: &::core::option::Option<Primitives::SelectorItem>) -> ::windows::core::Result<()>;
    fn IsContainerPrepared(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsContainerPrepared(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IChoosingItemContainerEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IChoosingItemContainerEventArgs";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IChoosingItemContainerEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IChoosingItemContainerEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IChoosingItemContainerEventArgsVtbl {
        unsafe extern "system" fn ItemIndex<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainer<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainer<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainer(&*(&value as *const <Primitives::SelectorItem as ::windows::core::Abi>::Abi as *const <Primitives::SelectorItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsContainerPrepared<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContainerPrepared() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsContainerPrepared<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsContainerPrepared(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IChoosingItemContainerEventArgs, BASE_OFFSET>(),
            ItemIndex: ItemIndex::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            ItemContainer: ItemContainer::<Impl, IMPL_OFFSET>,
            SetItemContainer: SetItemContainer::<Impl, IMPL_OFFSET>,
            IsContainerPrepared: IsContainerPrepared::<Impl, IMPL_OFFSET>,
            SetIsContainerPrepared: SetIsContainerPrepared::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IChoosingItemContainerEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICleanUpVirtualizedItemEventArgsImpl: Sized {
    fn Value(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn UIElement(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICleanUpVirtualizedItemEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICleanUpVirtualizedItemEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ICleanUpVirtualizedItemEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICleanUpVirtualizedItemEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICleanUpVirtualizedItemEventArgsVtbl {
        unsafe extern "system" fn Value<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UIElement<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UIElement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICleanUpVirtualizedItemEventArgs, BASE_OFFSET>(),
            Value: Value::<Impl, IMPL_OFFSET>,
            UIElement: UIElement::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICleanUpVirtualizedItemEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorChangedEventArgsImpl: Sized {
    fn OldColor(&mut self) -> ::windows::core::Result<super::super::Color>;
    fn NewColor(&mut self) -> ::windows::core::Result<super::super::Color>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IColorChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorChangedEventArgsVtbl {
        unsafe extern "system" fn OldColor<Impl: IColorChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewColor<Impl: IColorChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorChangedEventArgs, BASE_OFFSET>(),
            OldColor: OldColor::<Impl, IMPL_OFFSET>,
            NewColor: NewColor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IColorPickerImpl: Sized {
    fn Color(&mut self) -> ::windows::core::Result<super::super::Color>;
    fn SetColor(&mut self, value: &super::super::Color) -> ::windows::core::Result<()>;
    fn PreviousColor(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::Color>>;
    fn SetPreviousColor(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::Color>>) -> ::windows::core::Result<()>;
    fn IsAlphaEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorSpectrumVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorSpectrumVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorPreviewVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorPreviewVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorSliderVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorSliderVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsAlphaSliderVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaSliderVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsMoreButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsMoreButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorChannelTextInputVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorChannelTextInputVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsAlphaTextInputVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaTextInputVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsHexInputVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHexInputVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MinHue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinHue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxHue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxHue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MinSaturation(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinSaturation(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxSaturation(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxSaturation(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MinValue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinValue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxValue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxValue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn ColorSpectrumShape(&mut self) -> ::windows::core::Result<ColorSpectrumShape>;
    fn SetColorSpectrumShape(&mut self, value: ColorSpectrumShape) -> ::windows::core::Result<()>;
    fn ColorSpectrumComponents(&mut self) -> ::windows::core::Result<ColorSpectrumComponents>;
    fn SetColorSpectrumComponents(&mut self, value: ColorSpectrumComponents) -> ::windows::core::Result<()>;
    fn ColorChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveColorChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IColorPicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPicker";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IColorPickerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorPickerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorPickerVtbl {
        unsafe extern "system" fn Color<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Color() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColor<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColor(&*(&value as *const <super::super::Color as ::windows::core::Abi>::Abi as *const <super::super::Color as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreviousColor<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreviousColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreviousColor<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreviousColor(&*(&value as *const <super::super::super::Foundation::IReference<super::super::Color> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::Color> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsAlphaEnabled<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaEnabled<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsAlphaEnabled(value).into()
        }
        unsafe extern "system" fn IsColorSpectrumVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSpectrumVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorSpectrumVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorSpectrumVisible(value).into()
        }
        unsafe extern "system" fn IsColorPreviewVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorPreviewVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorPreviewVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorPreviewVisible(value).into()
        }
        unsafe extern "system" fn IsColorSliderVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSliderVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorSliderVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorSliderVisible(value).into()
        }
        unsafe extern "system" fn IsAlphaSliderVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaSliderVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaSliderVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsAlphaSliderVisible(value).into()
        }
        unsafe extern "system" fn IsMoreButtonVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMoreButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMoreButtonVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsMoreButtonVisible(value).into()
        }
        unsafe extern "system" fn IsColorChannelTextInputVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorChannelTextInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorChannelTextInputVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorChannelTextInputVisible(value).into()
        }
        unsafe extern "system" fn IsAlphaTextInputVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaTextInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaTextInputVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsAlphaTextInputVisible(value).into()
        }
        unsafe extern "system" fn IsHexInputVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHexInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHexInputVisible<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHexInputVisible(value).into()
        }
        unsafe extern "system" fn MinHue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinHue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinHue(value).into()
        }
        unsafe extern "system" fn MaxHue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxHue(value).into()
        }
        unsafe extern "system" fn MinSaturation<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinSaturation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinSaturation<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinSaturation(value).into()
        }
        unsafe extern "system" fn MaxSaturation<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSaturation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSaturation<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxSaturation(value).into()
        }
        unsafe extern "system" fn MinValue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinValue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinValue(value).into()
        }
        unsafe extern "system" fn MaxValue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxValue<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxValue(value).into()
        }
        unsafe extern "system" fn ColorSpectrumShape<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ColorSpectrumShape) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumShape() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorSpectrumShape<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ColorSpectrumShape) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorSpectrumShape(value).into()
        }
        unsafe extern "system" fn ColorSpectrumComponents<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ColorSpectrumComponents) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumComponents() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorSpectrumComponents<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ColorSpectrumComponents) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorSpectrumComponents(value).into()
        }
        unsafe extern "system" fn ColorChanged<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveColorChanged<Impl: IColorPickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveColorChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorPicker, BASE_OFFSET>(),
            Color: Color::<Impl, IMPL_OFFSET>,
            SetColor: SetColor::<Impl, IMPL_OFFSET>,
            PreviousColor: PreviousColor::<Impl, IMPL_OFFSET>,
            SetPreviousColor: SetPreviousColor::<Impl, IMPL_OFFSET>,
            IsAlphaEnabled: IsAlphaEnabled::<Impl, IMPL_OFFSET>,
            SetIsAlphaEnabled: SetIsAlphaEnabled::<Impl, IMPL_OFFSET>,
            IsColorSpectrumVisible: IsColorSpectrumVisible::<Impl, IMPL_OFFSET>,
            SetIsColorSpectrumVisible: SetIsColorSpectrumVisible::<Impl, IMPL_OFFSET>,
            IsColorPreviewVisible: IsColorPreviewVisible::<Impl, IMPL_OFFSET>,
            SetIsColorPreviewVisible: SetIsColorPreviewVisible::<Impl, IMPL_OFFSET>,
            IsColorSliderVisible: IsColorSliderVisible::<Impl, IMPL_OFFSET>,
            SetIsColorSliderVisible: SetIsColorSliderVisible::<Impl, IMPL_OFFSET>,
            IsAlphaSliderVisible: IsAlphaSliderVisible::<Impl, IMPL_OFFSET>,
            SetIsAlphaSliderVisible: SetIsAlphaSliderVisible::<Impl, IMPL_OFFSET>,
            IsMoreButtonVisible: IsMoreButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsMoreButtonVisible: SetIsMoreButtonVisible::<Impl, IMPL_OFFSET>,
            IsColorChannelTextInputVisible: IsColorChannelTextInputVisible::<Impl, IMPL_OFFSET>,
            SetIsColorChannelTextInputVisible: SetIsColorChannelTextInputVisible::<Impl, IMPL_OFFSET>,
            IsAlphaTextInputVisible: IsAlphaTextInputVisible::<Impl, IMPL_OFFSET>,
            SetIsAlphaTextInputVisible: SetIsAlphaTextInputVisible::<Impl, IMPL_OFFSET>,
            IsHexInputVisible: IsHexInputVisible::<Impl, IMPL_OFFSET>,
            SetIsHexInputVisible: SetIsHexInputVisible::<Impl, IMPL_OFFSET>,
            MinHue: MinHue::<Impl, IMPL_OFFSET>,
            SetMinHue: SetMinHue::<Impl, IMPL_OFFSET>,
            MaxHue: MaxHue::<Impl, IMPL_OFFSET>,
            SetMaxHue: SetMaxHue::<Impl, IMPL_OFFSET>,
            MinSaturation: MinSaturation::<Impl, IMPL_OFFSET>,
            SetMinSaturation: SetMinSaturation::<Impl, IMPL_OFFSET>,
            MaxSaturation: MaxSaturation::<Impl, IMPL_OFFSET>,
            SetMaxSaturation: SetMaxSaturation::<Impl, IMPL_OFFSET>,
            MinValue: MinValue::<Impl, IMPL_OFFSET>,
            SetMinValue: SetMinValue::<Impl, IMPL_OFFSET>,
            MaxValue: MaxValue::<Impl, IMPL_OFFSET>,
            SetMaxValue: SetMaxValue::<Impl, IMPL_OFFSET>,
            ColorSpectrumShape: ColorSpectrumShape::<Impl, IMPL_OFFSET>,
            SetColorSpectrumShape: SetColorSpectrumShape::<Impl, IMPL_OFFSET>,
            ColorSpectrumComponents: ColorSpectrumComponents::<Impl, IMPL_OFFSET>,
            SetColorSpectrumComponents: SetColorSpectrumComponents::<Impl, IMPL_OFFSET>,
            ColorChanged: ColorChanged::<Impl, IMPL_OFFSET>,
            RemoveColorChanged: RemoveColorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorPicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorPickerFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ColorPicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorPickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IColorPickerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorPickerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorPickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IColorPickerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorPickerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorPickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorPickerStaticsImpl: Sized {
    fn ColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreviousColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorSpectrumVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorPreviewVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorSliderVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaSliderVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsMoreButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorChannelTextInputVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaTextInputVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHexInputVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinHueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinSaturationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxSaturationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColorSpectrumShapeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColorSpectrumComponentsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorPickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IColorPickerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorPickerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorPickerStaticsVtbl {
        unsafe extern "system" fn ColorProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreviousColorProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreviousColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaEnabledProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorSpectrumVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSpectrumVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorPreviewVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorPreviewVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorSliderVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSliderVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaSliderVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaSliderVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMoreButtonVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMoreButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorChannelTextInputVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorChannelTextInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaTextInputVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaTextInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHexInputVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHexInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinHueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinSaturationProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinSaturationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxSaturationProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSaturationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinValueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxValueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorSpectrumShapeProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumShapeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorSpectrumComponentsProperty<Impl: IColorPickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumComponentsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorPickerStatics, BASE_OFFSET>(),
            ColorProperty: ColorProperty::<Impl, IMPL_OFFSET>,
            PreviousColorProperty: PreviousColorProperty::<Impl, IMPL_OFFSET>,
            IsAlphaEnabledProperty: IsAlphaEnabledProperty::<Impl, IMPL_OFFSET>,
            IsColorSpectrumVisibleProperty: IsColorSpectrumVisibleProperty::<Impl, IMPL_OFFSET>,
            IsColorPreviewVisibleProperty: IsColorPreviewVisibleProperty::<Impl, IMPL_OFFSET>,
            IsColorSliderVisibleProperty: IsColorSliderVisibleProperty::<Impl, IMPL_OFFSET>,
            IsAlphaSliderVisibleProperty: IsAlphaSliderVisibleProperty::<Impl, IMPL_OFFSET>,
            IsMoreButtonVisibleProperty: IsMoreButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsColorChannelTextInputVisibleProperty: IsColorChannelTextInputVisibleProperty::<Impl, IMPL_OFFSET>,
            IsAlphaTextInputVisibleProperty: IsAlphaTextInputVisibleProperty::<Impl, IMPL_OFFSET>,
            IsHexInputVisibleProperty: IsHexInputVisibleProperty::<Impl, IMPL_OFFSET>,
            MinHueProperty: MinHueProperty::<Impl, IMPL_OFFSET>,
            MaxHueProperty: MaxHueProperty::<Impl, IMPL_OFFSET>,
            MinSaturationProperty: MinSaturationProperty::<Impl, IMPL_OFFSET>,
            MaxSaturationProperty: MaxSaturationProperty::<Impl, IMPL_OFFSET>,
            MinValueProperty: MinValueProperty::<Impl, IMPL_OFFSET>,
            MaxValueProperty: MaxValueProperty::<Impl, IMPL_OFFSET>,
            ColorSpectrumShapeProperty: ColorSpectrumShapeProperty::<Impl, IMPL_OFFSET>,
            ColorSpectrumComponentsProperty: ColorSpectrumComponentsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorPickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColumnDefinitionImpl: Sized {
    fn Width(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetWidth(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn MaxWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MinWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ActualWidth(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColumnDefinition {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColumnDefinition";
}
#[cfg(feature = "implement_exclusive")]
impl IColumnDefinitionVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColumnDefinitionImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColumnDefinitionVtbl {
        unsafe extern "system" fn Width<Impl: IColumnDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Width() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWidth<Impl: IColumnDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWidth(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxWidth<Impl: IColumnDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxWidth<Impl: IColumnDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxWidth(value).into()
        }
        unsafe extern "system" fn MinWidth<Impl: IColumnDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinWidth<Impl: IColumnDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinWidth(value).into()
        }
        unsafe extern "system" fn ActualWidth<Impl: IColumnDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColumnDefinition, BASE_OFFSET>(),
            Width: Width::<Impl, IMPL_OFFSET>,
            SetWidth: SetWidth::<Impl, IMPL_OFFSET>,
            MaxWidth: MaxWidth::<Impl, IMPL_OFFSET>,
            SetMaxWidth: SetMaxWidth::<Impl, IMPL_OFFSET>,
            MinWidth: MinWidth::<Impl, IMPL_OFFSET>,
            SetMinWidth: SetMinWidth::<Impl, IMPL_OFFSET>,
            ActualWidth: ActualWidth::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColumnDefinition as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColumnDefinitionStaticsImpl: Sized {
    fn WidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColumnDefinitionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColumnDefinitionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IColumnDefinitionStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColumnDefinitionStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColumnDefinitionStaticsVtbl {
        unsafe extern "system" fn WidthProperty<Impl: IColumnDefinitionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxWidthProperty<Impl: IColumnDefinitionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinWidthProperty<Impl: IColumnDefinitionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColumnDefinitionStatics, BASE_OFFSET>(),
            WidthProperty: WidthProperty::<Impl, IMPL_OFFSET>,
            MaxWidthProperty: MaxWidthProperty::<Impl, IMPL_OFFSET>,
            MinWidthProperty: MinWidthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColumnDefinitionStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IComboBoxImpl: Sized {
    fn IsDropDownOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDropDownOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsEditable(&mut self) -> ::windows::core::Result<bool>;
    fn IsSelectionBoxHighlighted(&mut self) -> ::windows::core::Result<bool>;
    fn MaxDropDownHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxDropDownHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn SelectionBoxItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SelectionBoxItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ComboBoxTemplateSettings>;
    fn DropDownClosed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDropDownClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DropDownOpened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDropDownOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IComboBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IComboBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxVtbl {
        unsafe extern "system" fn IsDropDownOpen<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDropDownOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDropDownOpen<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDropDownOpen(value).into()
        }
        unsafe extern "system" fn IsEditable<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEditable() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSelectionBoxHighlighted<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSelectionBoxHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDropDownHeight<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDropDownHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDropDownHeight<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxDropDownHeight(value).into()
        }
        unsafe extern "system" fn SelectionBoxItem<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionBoxItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionBoxItemTemplate<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionBoxItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettings<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropDownClosed<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropDownClosed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDropDownClosed<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDropDownClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DropDownOpened<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropDownOpened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDropDownOpened<Impl: IComboBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDropDownOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox, BASE_OFFSET>(),
            IsDropDownOpen: IsDropDownOpen::<Impl, IMPL_OFFSET>,
            SetIsDropDownOpen: SetIsDropDownOpen::<Impl, IMPL_OFFSET>,
            IsEditable: IsEditable::<Impl, IMPL_OFFSET>,
            IsSelectionBoxHighlighted: IsSelectionBoxHighlighted::<Impl, IMPL_OFFSET>,
            MaxDropDownHeight: MaxDropDownHeight::<Impl, IMPL_OFFSET>,
            SetMaxDropDownHeight: SetMaxDropDownHeight::<Impl, IMPL_OFFSET>,
            SelectionBoxItem: SelectionBoxItem::<Impl, IMPL_OFFSET>,
            SelectionBoxItemTemplate: SelectionBoxItemTemplate::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            DropDownClosed: DropDownClosed::<Impl, IMPL_OFFSET>,
            RemoveDropDownClosed: RemoveDropDownClosed::<Impl, IMPL_OFFSET>,
            DropDownOpened: DropDownOpened::<Impl, IMPL_OFFSET>,
            RemoveDropDownOpened: RemoveDropDownOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox2Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox2Vtbl {
        unsafe extern "system" fn Header<Impl: IComboBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IComboBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IComboBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IComboBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IComboBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IComboBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox3Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
    fn IsTextSearchEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextSearchEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox3Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IComboBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IComboBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        unsafe extern "system" fn IsTextSearchEnabled<Impl: IComboBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSearchEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSearchEnabled<Impl: IComboBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextSearchEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox3, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            IsTextSearchEnabled: IsTextSearchEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextSearchEnabled: SetIsTextSearchEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox4Impl: Sized {
    fn SelectionChangedTrigger(&mut self) -> ::windows::core::Result<ComboBoxSelectionChangedTrigger>;
    fn SetSelectionChangedTrigger(&mut self, value: ComboBoxSelectionChangedTrigger) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox4Vtbl {
        unsafe extern "system" fn SelectionChangedTrigger<Impl: IComboBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ComboBoxSelectionChangedTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChangedTrigger() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionChangedTrigger<Impl: IComboBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ComboBoxSelectionChangedTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionChangedTrigger(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox4, BASE_OFFSET>(),
            SelectionChangedTrigger: SelectionChangedTrigger::<Impl, IMPL_OFFSET>,
            SetSelectionChangedTrigger: SetSelectionChangedTrigger::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IComboBox5Impl: Sized {
    fn PlaceholderForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPlaceholderForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IComboBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox5";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IComboBox5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox5Vtbl {
        unsafe extern "system" fn PlaceholderForeground<Impl: IComboBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderForeground<Impl: IComboBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox5, BASE_OFFSET>(),
            PlaceholderForeground: PlaceholderForeground::<Impl, IMPL_OFFSET>,
            SetPlaceholderForeground: SetPlaceholderForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IComboBox6Impl: Sized {
    fn SetIsEditable(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn TextBoxStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetTextBoxStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TextSubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextSubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IComboBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox6";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IComboBox6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox6Vtbl {
        unsafe extern "system" fn SetIsEditable<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsEditable(value).into()
        }
        unsafe extern "system" fn Text<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextBoxStyle<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextBoxStyle<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextBoxStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Description<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextSubmitted<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextSubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextSubmitted<Impl: IComboBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextSubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox6, BASE_OFFSET>(),
            SetIsEditable: SetIsEditable::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            TextBoxStyle: TextBoxStyle::<Impl, IMPL_OFFSET>,
            SetTextBoxStyle: SetTextBoxStyle::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            TextSubmitted: TextSubmitted::<Impl, IMPL_OFFSET>,
            RemoveTextSubmitted: RemoveTextSubmitted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ComboBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IComboBoxFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxItem";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxItemVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ComboBoxItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IComboBoxItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxOverridesImpl: Sized {
    fn OnDropDownClosed(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnDropDownOpened(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxOverridesVtbl {
        unsafe extern "system" fn OnDropDownClosed<Impl: IComboBoxOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDropDownClosed(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDropDownOpened<Impl: IComboBoxOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDropDownOpened(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxOverrides, BASE_OFFSET>(),
            OnDropDownClosed: OnDropDownClosed::<Impl, IMPL_OFFSET>,
            OnDropDownOpened: OnDropDownOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStaticsImpl: Sized {
    fn IsDropDownOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDropDownHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStaticsVtbl {
        unsafe extern "system" fn IsDropDownOpenProperty<Impl: IComboBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDropDownOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDropDownHeightProperty<Impl: IComboBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDropDownHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics, BASE_OFFSET>(),
            IsDropDownOpenProperty: IsDropDownOpenProperty::<Impl, IMPL_OFFSET>,
            MaxDropDownHeightProperty: MaxDropDownHeightProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics2Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IComboBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IComboBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IComboBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics3Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSearchEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics3Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IComboBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSearchEnabledProperty<Impl: IComboBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSearchEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics3, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
            IsTextSearchEnabledProperty: IsTextSearchEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics4Impl: Sized {
    fn SelectionChangedTriggerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics4Vtbl {
        unsafe extern "system" fn SelectionChangedTriggerProperty<Impl: IComboBoxStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChangedTriggerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics4, BASE_OFFSET>(),
            SelectionChangedTriggerProperty: SelectionChangedTriggerProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics5Impl: Sized {
    fn PlaceholderForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics5Vtbl {
        unsafe extern "system" fn PlaceholderForegroundProperty<Impl: IComboBoxStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics5, BASE_OFFSET>(),
            PlaceholderForegroundProperty: PlaceholderForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics6Impl: Sized {
    fn IsEditableProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextBoxStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics6Vtbl {
        unsafe extern "system" fn IsEditableProperty<Impl: IComboBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEditableProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: IComboBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextBoxStyleProperty<Impl: IComboBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IComboBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics6, BASE_OFFSET>(),
            IsEditableProperty: IsEditableProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            TextBoxStyleProperty: TextBoxStyleProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxTextSubmittedEventArgsImpl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxTextSubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxTextSubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxTextSubmittedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxTextSubmittedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxTextSubmittedEventArgsVtbl {
        unsafe extern "system" fn Text<Impl: IComboBoxTextSubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IComboBoxTextSubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IComboBoxTextSubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxTextSubmittedEventArgs, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxTextSubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICommandBarImpl: Sized {
    fn PrimaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
    fn SecondaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICommandBarVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarVtbl {
        unsafe extern "system" fn PrimaryCommands<Impl: ICommandBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommands<Impl: ICommandBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBar, BASE_OFFSET>(),
            PrimaryCommands: PrimaryCommands::<Impl, IMPL_OFFSET>,
            SecondaryCommands: SecondaryCommands::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBar as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait ICommandBar2Impl: Sized {
    fn CommandBarOverflowPresenterStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCommandBarOverflowPresenterStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CommandBarTemplateSettings(&mut self) -> ::windows::core::Result<Primitives::CommandBarTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar2";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ICommandBar2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBar2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBar2Vtbl {
        unsafe extern "system" fn CommandBarOverflowPresenterStyle<Impl: ICommandBar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandBarOverflowPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandBarOverflowPresenterStyle<Impl: ICommandBar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandBarOverflowPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandBarTemplateSettings<Impl: ICommandBar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandBarTemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBar2, BASE_OFFSET>(),
            CommandBarOverflowPresenterStyle: CommandBarOverflowPresenterStyle::<Impl, IMPL_OFFSET>,
            SetCommandBarOverflowPresenterStyle: SetCommandBarOverflowPresenterStyle::<Impl, IMPL_OFFSET>,
            CommandBarTemplateSettings: CommandBarTemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBar2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICommandBar3Impl: Sized {
    fn DefaultLabelPosition(&mut self) -> ::windows::core::Result<CommandBarDefaultLabelPosition>;
    fn SetDefaultLabelPosition(&mut self, value: CommandBarDefaultLabelPosition) -> ::windows::core::Result<()>;
    fn OverflowButtonVisibility(&mut self) -> ::windows::core::Result<CommandBarOverflowButtonVisibility>;
    fn SetOverflowButtonVisibility(&mut self, value: CommandBarOverflowButtonVisibility) -> ::windows::core::Result<()>;
    fn IsDynamicOverflowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDynamicOverflowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DynamicOverflowItemsChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDynamicOverflowItemsChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICommandBar3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBar3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBar3Vtbl {
        unsafe extern "system" fn DefaultLabelPosition<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarDefaultLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultLabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultLabelPosition<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarDefaultLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultLabelPosition(value).into()
        }
        unsafe extern "system" fn OverflowButtonVisibility<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarOverflowButtonVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowButtonVisibility<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarOverflowButtonVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowButtonVisibility(value).into()
        }
        unsafe extern "system" fn IsDynamicOverflowEnabled<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDynamicOverflowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDynamicOverflowEnabled<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDynamicOverflowEnabled(value).into()
        }
        unsafe extern "system" fn DynamicOverflowItemsChanging<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowItemsChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDynamicOverflowItemsChanging<Impl: ICommandBar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDynamicOverflowItemsChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBar3, BASE_OFFSET>(),
            DefaultLabelPosition: DefaultLabelPosition::<Impl, IMPL_OFFSET>,
            SetDefaultLabelPosition: SetDefaultLabelPosition::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibility: OverflowButtonVisibility::<Impl, IMPL_OFFSET>,
            SetOverflowButtonVisibility: SetOverflowButtonVisibility::<Impl, IMPL_OFFSET>,
            IsDynamicOverflowEnabled: IsDynamicOverflowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDynamicOverflowEnabled: SetIsDynamicOverflowEnabled::<Impl, IMPL_OFFSET>,
            DynamicOverflowItemsChanging: DynamicOverflowItemsChanging::<Impl, IMPL_OFFSET>,
            RemoveDynamicOverflowItemsChanging: RemoveDynamicOverflowItemsChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBar3 as ::windows::core::Interface>::IID
    }
}
pub trait ICommandBarElementImpl: Sized {
    fn IsCompact(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompact(&mut self, value: bool) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ICommandBarElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarElement";
}
impl ICommandBarElementVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarElementImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarElementVtbl {
        unsafe extern "system" fn IsCompact<Impl: ICommandBarElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompact<Impl: ICommandBarElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompact(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarElement, BASE_OFFSET>(),
            IsCompact: IsCompact::<Impl, IMPL_OFFSET>,
            SetIsCompact: SetIsCompact::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarElement as ::windows::core::Interface>::IID
    }
}
pub trait ICommandBarElement2Impl: Sized {
    fn IsInOverflow(&mut self) -> ::windows::core::Result<bool>;
    fn DynamicOverflowOrder(&mut self) -> ::windows::core::Result<i32>;
    fn SetDynamicOverflowOrder(&mut self, value: i32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ICommandBarElement2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarElement2";
}
impl ICommandBarElement2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarElement2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarElement2Vtbl {
        unsafe extern "system" fn IsInOverflow<Impl: ICommandBarElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrder<Impl: ICommandBarElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDynamicOverflowOrder<Impl: ICommandBarElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDynamicOverflowOrder(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarElement2, BASE_OFFSET>(),
            IsInOverflow: IsInOverflow::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrder: DynamicOverflowOrder::<Impl, IMPL_OFFSET>,
            SetDynamicOverflowOrder: SetDynamicOverflowOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarElement2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICommandBarFlyoutImpl: Sized {
    fn PrimaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
    fn SecondaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBarFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFlyout";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICommandBarFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarFlyoutVtbl {
        unsafe extern "system" fn PrimaryCommands<Impl: ICommandBarFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommands<Impl: ICommandBarFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarFlyout, BASE_OFFSET>(),
            PrimaryCommands: PrimaryCommands::<Impl, IMPL_OFFSET>,
            SecondaryCommands: SecondaryCommands::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarFlyoutFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBarFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarFlyoutFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarFlyoutFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarFlyoutFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarOverflowPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarOverflowPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarOverflowPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarOverflowPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarOverflowPresenterVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarOverflowPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarOverflowPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarOverflowPresenterFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBarOverflowPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarOverflowPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarOverflowPresenterFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarOverflowPresenterFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarOverflowPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarOverflowPresenterFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarOverflowPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarOverflowPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStaticsImpl: Sized {
    fn PrimaryCommandsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryCommandsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarStaticsVtbl {
        unsafe extern "system" fn PrimaryCommandsProperty<Impl: ICommandBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryCommandsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommandsProperty<Impl: ICommandBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryCommandsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarStatics, BASE_OFFSET>(),
            PrimaryCommandsProperty: PrimaryCommandsProperty::<Impl, IMPL_OFFSET>,
            SecondaryCommandsProperty: SecondaryCommandsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStatics2Impl: Sized {
    fn CommandBarOverflowPresenterStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarStatics2Vtbl {
        unsafe extern "system" fn CommandBarOverflowPresenterStyleProperty<Impl: ICommandBarStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandBarOverflowPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarStatics2, BASE_OFFSET>(),
            CommandBarOverflowPresenterStyleProperty: CommandBarOverflowPresenterStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStatics3Impl: Sized {
    fn DefaultLabelPositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsDynamicOverflowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarStatics3Vtbl {
        unsafe extern "system" fn DefaultLabelPositionProperty<Impl: ICommandBarStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultLabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibilityProperty<Impl: ICommandBarStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDynamicOverflowEnabledProperty<Impl: ICommandBarStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDynamicOverflowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarStatics3, BASE_OFFSET>(),
            DefaultLabelPositionProperty: DefaultLabelPositionProperty::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibilityProperty: OverflowButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            IsDynamicOverflowEnabledProperty: IsDynamicOverflowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IContainerContentChangingEventArgsImpl: Sized {
    fn ItemContainer(&mut self) -> ::windows::core::Result<Primitives::SelectorItem>;
    fn InRecycleQueue(&mut self) -> ::windows::core::Result<bool>;
    fn ItemIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn Phase(&mut self) -> ::windows::core::Result<u32>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallback(&mut self, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallbackWithPhase(&mut self, callbackphase: u32, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContainerContentChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContainerContentChangingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IContainerContentChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContainerContentChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContainerContentChangingEventArgsVtbl {
        unsafe extern "system" fn ItemContainer<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InRecycleQueue<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InRecycleQueue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemIndex<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Phase<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Phase() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn RegisterUpdateCallback<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallback(&*(&callback as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RegisterUpdateCallbackWithPhase<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callbackphase: u32, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallbackWithPhase(callbackphase, &*(&callback as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContainerContentChangingEventArgs, BASE_OFFSET>(),
            ItemContainer: ItemContainer::<Impl, IMPL_OFFSET>,
            InRecycleQueue: InRecycleQueue::<Impl, IMPL_OFFSET>,
            ItemIndex: ItemIndex::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Phase: Phase::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallback: RegisterUpdateCallback::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallbackWithPhase: RegisterUpdateCallbackWithPhase::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContainerContentChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IContentControlImpl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetContentTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ContentTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetContentTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControl";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IContentControlVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControlImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControlVtbl {
        unsafe extern "system" fn Content<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplateSelector<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplateSelector<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTransitions<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTransitions<Impl: IContentControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControl, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            ContentTemplate: ContentTemplate::<Impl, IMPL_OFFSET>,
            SetContentTemplate: SetContentTemplate::<Impl, IMPL_OFFSET>,
            ContentTemplateSelector: ContentTemplateSelector::<Impl, IMPL_OFFSET>,
            SetContentTemplateSelector: SetContentTemplateSelector::<Impl, IMPL_OFFSET>,
            ContentTransitions: ContentTransitions::<Impl, IMPL_OFFSET>,
            SetContentTransitions: SetContentTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControl2Impl: Sized {
    fn ContentTemplateRoot(&mut self) -> ::windows::core::Result<super::UIElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControl2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControl2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControl2Vtbl {
        unsafe extern "system" fn ContentTemplateRoot<Impl: IContentControl2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateRoot() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControl2, BASE_OFFSET>(),
            ContentTemplateRoot: ContentTemplateRoot::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControlFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentControlFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlOverridesImpl: Sized {
    fn OnContentChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnContentTemplateChanged(&mut self, oldcontenttemplate: &::core::option::Option<super::DataTemplate>, newcontenttemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContentTemplateSelectorChanged(&mut self, oldcontenttemplateselector: &::core::option::Option<DataTemplateSelector>, newcontenttemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControlOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControlOverridesVtbl {
        unsafe extern "system" fn OnContentChanged<Impl: IContentControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateChanged<Impl: IContentControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplate: ::windows::core::RawPtr, newcontenttemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateChanged(&*(&oldcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateSelectorChanged<Impl: IContentControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplateselector: ::windows::core::RawPtr, newcontenttemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateSelectorChanged(&*(&oldcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControlOverrides, BASE_OFFSET>(),
            OnContentChanged: OnContentChanged::<Impl, IMPL_OFFSET>,
            OnContentTemplateChanged: OnContentTemplateChanged::<Impl, IMPL_OFFSET>,
            OnContentTemplateSelectorChanged: OnContentTemplateSelectorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControlOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlStaticsImpl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControlStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControlStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IContentControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IContentControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateSelectorProperty<Impl: IContentControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTransitionsProperty<Impl: IContentControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControlStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateProperty: ContentTemplateProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateSelectorProperty: ContentTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ContentTransitionsProperty: ContentTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IContentDialogImpl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetTitle(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TitleTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetTitleTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FullSizeDesired(&mut self) -> ::windows::core::Result<bool>;
    fn SetFullSizeDesired(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PrimaryButtonText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPrimaryButtonText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SecondaryButtonText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSecondaryButtonText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PrimaryButtonCommand(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetPrimaryButtonCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn SecondaryButtonCommand(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetSecondaryButtonCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn PrimaryButtonCommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetPrimaryButtonCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SecondaryButtonCommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSecondaryButtonCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn IsPrimaryButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPrimaryButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSecondaryButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSecondaryButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Closing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PrimaryButtonClick(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePrimaryButtonClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SecondaryButtonClick(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSecondaryButtonClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Hide(&mut self) -> ::windows::core::Result<()>;
    fn ShowAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<ContentDialogResult>>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentDialog {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IContentDialogVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogVtbl {
        unsafe extern "system" fn Title<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TitleTemplate<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitleTemplate<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitleTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FullSizeDesired<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FullSizeDesired() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullSizeDesired<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFullSizeDesired(value).into()
        }
        unsafe extern "system" fn PrimaryButtonText<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonText<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonText<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonText<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPrimaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPrimaryButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPrimaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPrimaryButtonEnabled(value).into()
        }
        unsafe extern "system" fn IsSecondaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSecondaryButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSecondaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSecondaryButtonEnabled(value).into()
        }
        unsafe extern "system" fn Closing<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosing<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonClick<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePrimaryButtonClick<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePrimaryButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonClick<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSecondaryButtonClick<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSecondaryButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Hide<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        unsafe extern "system" fn ShowAsync<Impl: IContentDialogImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialog, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            TitleTemplate: TitleTemplate::<Impl, IMPL_OFFSET>,
            SetTitleTemplate: SetTitleTemplate::<Impl, IMPL_OFFSET>,
            FullSizeDesired: FullSizeDesired::<Impl, IMPL_OFFSET>,
            SetFullSizeDesired: SetFullSizeDesired::<Impl, IMPL_OFFSET>,
            PrimaryButtonText: PrimaryButtonText::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonText: SetPrimaryButtonText::<Impl, IMPL_OFFSET>,
            SecondaryButtonText: SecondaryButtonText::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonText: SetSecondaryButtonText::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommand: PrimaryButtonCommand::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonCommand: SetPrimaryButtonCommand::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommand: SecondaryButtonCommand::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonCommand: SetSecondaryButtonCommand::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommandParameter: PrimaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonCommandParameter: SetPrimaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommandParameter: SecondaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonCommandParameter: SetSecondaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            IsPrimaryButtonEnabled: IsPrimaryButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsPrimaryButtonEnabled: SetIsPrimaryButtonEnabled::<Impl, IMPL_OFFSET>,
            IsSecondaryButtonEnabled: IsSecondaryButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsSecondaryButtonEnabled: SetIsSecondaryButtonEnabled::<Impl, IMPL_OFFSET>,
            Closing: Closing::<Impl, IMPL_OFFSET>,
            RemoveClosing: RemoveClosing::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            PrimaryButtonClick: PrimaryButtonClick::<Impl, IMPL_OFFSET>,
            RemovePrimaryButtonClick: RemovePrimaryButtonClick::<Impl, IMPL_OFFSET>,
            SecondaryButtonClick: SecondaryButtonClick::<Impl, IMPL_OFFSET>,
            RemoveSecondaryButtonClick: RemoveSecondaryButtonClick::<Impl, IMPL_OFFSET>,
            Hide: Hide::<Impl, IMPL_OFFSET>,
            ShowAsync: ShowAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialog as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IContentDialog2Impl: Sized {
    fn CloseButtonText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCloseButtonText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CloseButtonCommand(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCloseButtonCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CloseButtonCommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCloseButtonCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PrimaryButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetPrimaryButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SecondaryButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetSecondaryButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CloseButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCloseButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn DefaultButton(&mut self) -> ::windows::core::Result<ContentDialogButton>;
    fn SetDefaultButton(&mut self, value: ContentDialogButton) -> ::windows::core::Result<()>;
    fn CloseButtonClick(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCloseButtonClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentDialog2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IContentDialog2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialog2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialog2Vtbl {
        unsafe extern "system" fn CloseButtonText<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonText<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonCommand<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonCommand<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonCommandParameter<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonCommandParameter<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonStyle<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonStyle<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DefaultButton<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogButton) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultButton<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ContentDialogButton) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultButton(value).into()
        }
        unsafe extern "system" fn CloseButtonClick<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCloseButtonClick<Impl: IContentDialog2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCloseButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialog2, BASE_OFFSET>(),
            CloseButtonText: CloseButtonText::<Impl, IMPL_OFFSET>,
            SetCloseButtonText: SetCloseButtonText::<Impl, IMPL_OFFSET>,
            CloseButtonCommand: CloseButtonCommand::<Impl, IMPL_OFFSET>,
            SetCloseButtonCommand: SetCloseButtonCommand::<Impl, IMPL_OFFSET>,
            CloseButtonCommandParameter: CloseButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SetCloseButtonCommandParameter: SetCloseButtonCommandParameter::<Impl, IMPL_OFFSET>,
            PrimaryButtonStyle: PrimaryButtonStyle::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonStyle: SetPrimaryButtonStyle::<Impl, IMPL_OFFSET>,
            SecondaryButtonStyle: SecondaryButtonStyle::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonStyle: SetSecondaryButtonStyle::<Impl, IMPL_OFFSET>,
            CloseButtonStyle: CloseButtonStyle::<Impl, IMPL_OFFSET>,
            SetCloseButtonStyle: SetCloseButtonStyle::<Impl, IMPL_OFFSET>,
            DefaultButton: DefaultButton::<Impl, IMPL_OFFSET>,
            SetDefaultButton: SetDefaultButton::<Impl, IMPL_OFFSET>,
            CloseButtonClick: CloseButtonClick::<Impl, IMPL_OFFSET>,
            RemoveCloseButtonClick: RemoveCloseButtonClick::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialog2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IContentDialog3Impl: Sized {
    fn ShowAsyncWithPlacement(&mut self, placement: ContentDialogPlacement) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<ContentDialogResult>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentDialog3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IContentDialog3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialog3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialog3Vtbl {
        unsafe extern "system" fn ShowAsyncWithPlacement<Impl: IContentDialog3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, placement: ContentDialogPlacement, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsyncWithPlacement(placement) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialog3, BASE_OFFSET>(),
            ShowAsyncWithPlacement: ShowAsyncWithPlacement::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialog3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogButtonClickDeferralImpl: Sized {
    fn Complete(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogButtonClickDeferral {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogButtonClickDeferral";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogButtonClickDeferralVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogButtonClickDeferralImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogButtonClickDeferralVtbl {
        unsafe extern "system" fn Complete<Impl: IContentDialogButtonClickDeferralImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Complete().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogButtonClickDeferral, BASE_OFFSET>(),
            Complete: Complete::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogButtonClickDeferral as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogButtonClickEventArgsImpl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn GetDeferral(&mut self) -> ::windows::core::Result<ContentDialogButtonClickDeferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogButtonClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogButtonClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogButtonClickEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogButtonClickEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogButtonClickEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: IContentDialogButtonClickEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IContentDialogButtonClickEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IContentDialogButtonClickEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogButtonClickEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogButtonClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosedEventArgsImpl: Sized {
    fn Result(&mut self) -> ::windows::core::Result<ContentDialogResult>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogClosedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogClosedEventArgsVtbl {
        unsafe extern "system" fn Result<Impl: IContentDialogClosedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogResult) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Result() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogClosedEventArgs, BASE_OFFSET>(), Result: Result::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogClosedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosingDeferralImpl: Sized {
    fn Complete(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosingDeferral {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosingDeferral";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosingDeferralVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogClosingDeferralImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogClosingDeferralVtbl {
        unsafe extern "system" fn Complete<Impl: IContentDialogClosingDeferralImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Complete().into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogClosingDeferral, BASE_OFFSET>(), Complete: Complete::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogClosingDeferral as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosingEventArgsImpl: Sized {
    fn Result(&mut self) -> ::windows::core::Result<ContentDialogResult>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn GetDeferral(&mut self) -> ::windows::core::Result<ContentDialogClosingDeferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogClosingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogClosingEventArgsVtbl {
        unsafe extern "system" fn Result<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogResult) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Result() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogClosingEventArgs, BASE_OFFSET>(),
            Result: Result::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogClosingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentDialog>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentDialogFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogOpenedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogOpenedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogOpenedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogOpenedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogOpenedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogOpenedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogOpenedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogOpenedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogStaticsImpl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TitleTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FullSizeDesiredProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonCommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonCommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonCommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonCommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPrimaryButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSecondaryButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitleTemplateProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FullSizeDesiredProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FullSizeDesiredProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonTextProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonTextProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonCommandProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonCommandProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonCommandParameterProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonCommandParameterProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPrimaryButtonEnabledProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPrimaryButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSecondaryButtonEnabledProperty<Impl: IContentDialogStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSecondaryButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            TitleTemplateProperty: TitleTemplateProperty::<Impl, IMPL_OFFSET>,
            FullSizeDesiredProperty: FullSizeDesiredProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonTextProperty: PrimaryButtonTextProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonTextProperty: SecondaryButtonTextProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommandProperty: PrimaryButtonCommandProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommandProperty: SecondaryButtonCommandProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommandParameterProperty: PrimaryButtonCommandParameterProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommandParameterProperty: SecondaryButtonCommandParameterProperty::<Impl, IMPL_OFFSET>,
            IsPrimaryButtonEnabledProperty: IsPrimaryButtonEnabledProperty::<Impl, IMPL_OFFSET>,
            IsSecondaryButtonEnabledProperty: IsSecondaryButtonEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogStatics2Impl: Sized {
    fn CloseButtonTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonCommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonCommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultButtonProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogStatics2Vtbl {
        unsafe extern "system" fn CloseButtonTextProperty<Impl: IContentDialogStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonCommandProperty<Impl: IContentDialogStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonCommandParameterProperty<Impl: IContentDialogStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonStyleProperty<Impl: IContentDialogStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonStyleProperty<Impl: IContentDialogStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonStyleProperty<Impl: IContentDialogStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultButtonProperty<Impl: IContentDialogStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultButtonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogStatics2, BASE_OFFSET>(),
            CloseButtonTextProperty: CloseButtonTextProperty::<Impl, IMPL_OFFSET>,
            CloseButtonCommandProperty: CloseButtonCommandProperty::<Impl, IMPL_OFFSET>,
            CloseButtonCommandParameterProperty: CloseButtonCommandParameterProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonStyleProperty: PrimaryButtonStyleProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonStyleProperty: SecondaryButtonStyleProperty::<Impl, IMPL_OFFSET>,
            CloseButtonStyleProperty: CloseButtonStyleProperty::<Impl, IMPL_OFFSET>,
            DefaultButtonProperty: DefaultButtonProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait IContentLinkChangedEventArgsImpl: Sized {
    fn ChangeKind(&mut self) -> ::windows::core::Result<ContentLinkChangeKind>;
    fn ContentLinkInfo(&mut self) -> ::windows::core::Result<super::super::Text::ContentLinkInfo>;
    fn TextRange(&mut self) -> ::windows::core::Result<super::Documents::TextRange>;
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentLinkChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentLinkChangedEventArgs";
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl IContentLinkChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentLinkChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentLinkChangedEventArgsVtbl {
        unsafe extern "system" fn ChangeKind<Impl: IContentLinkChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentLinkChangeKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChangeKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkInfo<Impl: IContentLinkChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextRange<Impl: IContentLinkChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Documents::TextRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextRange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentLinkChangedEventArgs, BASE_OFFSET>(),
            ChangeKind: ChangeKind::<Impl, IMPL_OFFSET>,
            ContentLinkInfo: ContentLinkInfo::<Impl, IMPL_OFFSET>,
            TextRange: TextRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentLinkChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IContentPresenterImpl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetContentTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ContentTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetContentTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IContentPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterVtbl {
        unsafe extern "system" fn Content<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplateSelector<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplateSelector<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTransitions<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTransitions<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            ContentTemplate: ContentTemplate::<Impl, IMPL_OFFSET>,
            SetContentTemplate: SetContentTemplate::<Impl, IMPL_OFFSET>,
            ContentTemplateSelector: ContentTemplateSelector::<Impl, IMPL_OFFSET>,
            SetContentTemplateSelector: SetContentTemplateSelector::<Impl, IMPL_OFFSET>,
            ContentTransitions: ContentTransitions::<Impl, IMPL_OFFSET>,
            SetContentTransitions: SetContentTransitions::<Impl, IMPL_OFFSET>,
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter2Impl: Sized {
    fn OpticalMarginAlignment(&mut self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&mut self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn TextLineBounds(&mut self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&mut self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter2Vtbl {
        unsafe extern "system" fn OpticalMarginAlignment<Impl: IContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: IContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: IContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: IContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter2, BASE_OFFSET>(),
            OpticalMarginAlignment: OpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            SetOpticalMarginAlignment: SetOpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            TextLineBounds: TextLineBounds::<Impl, IMPL_OFFSET>,
            SetTextLineBounds: SetTextLineBounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter3Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter3";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IContentPresenter3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IContentPresenter3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter3, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IContentPresenter4Impl: Sized {
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&mut self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&mut self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn LineHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HorizontalContentAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalContentAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalContentAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalContentAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentPresenter4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter4";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IContentPresenter4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter4Vtbl {
        unsafe extern "system" fn TextWrapping<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn MaxLines<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn LineHeight<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn BorderBrush<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalContentAlignment(value).into()
        }
        unsafe extern "system" fn VerticalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalContentAlignment(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter4, BASE_OFFSET>(),
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
            LineStackingStrategy: LineStackingStrategy::<Impl, IMPL_OFFSET>,
            SetLineStackingStrategy: SetLineStackingStrategy::<Impl, IMPL_OFFSET>,
            LineHeight: LineHeight::<Impl, IMPL_OFFSET>,
            SetLineHeight: SetLineHeight::<Impl, IMPL_OFFSET>,
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignment: HorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalContentAlignment: SetHorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            VerticalContentAlignment: VerticalContentAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalContentAlignment: SetVerticalContentAlignment::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter5Impl: Sized {
    fn BackgroundTransition(&mut self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&mut self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter5";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter5Vtbl {
        unsafe extern "system" fn BackgroundTransition<Impl: IContentPresenter5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IContentPresenter5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackgroundSizing<Impl: IContentPresenter5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IContentPresenter5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter5, BASE_OFFSET>(),
            BackgroundTransition: BackgroundTransition::<Impl, IMPL_OFFSET>,
            SetBackgroundTransition: SetBackgroundTransition::<Impl, IMPL_OFFSET>,
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentPresenterFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterOverridesImpl: Sized {
    fn OnContentTemplateChanged(&mut self, oldcontenttemplate: &::core::option::Option<super::DataTemplate>, newcontenttemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContentTemplateSelectorChanged(&mut self, oldcontenttemplateselector: &::core::option::Option<DataTemplateSelector>, newcontenttemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterOverridesVtbl {
        unsafe extern "system" fn OnContentTemplateChanged<Impl: IContentPresenterOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplate: ::windows::core::RawPtr, newcontenttemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateChanged(&*(&oldcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateSelectorChanged<Impl: IContentPresenterOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplateselector: ::windows::core::RawPtr, newcontenttemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateSelectorChanged(&*(&oldcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterOverrides, BASE_OFFSET>(),
            OnContentTemplateChanged: OnContentTemplateChanged::<Impl, IMPL_OFFSET>,
            OnContentTemplateSelectorChanged: OnContentTemplateSelectorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStaticsImpl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateSelectorProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTransitionsProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateProperty: ContentTemplateProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateSelectorProperty: ContentTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ContentTransitionsProperty: ContentTransitionsProperty::<Impl, IMPL_OFFSET>,
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics2Impl: Sized {
    fn OpticalMarginAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics2Vtbl {
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: IContentPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: IContentPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics2, BASE_OFFSET>(),
            OpticalMarginAlignmentProperty: OpticalMarginAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextLineBoundsProperty: TextLineBoundsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics3Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IContentPresenterStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics3, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics4Impl: Sized {
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics4Vtbl {
        unsafe extern "system" fn TextWrappingProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLinesProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalContentAlignmentProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalContentAlignmentProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics4, BASE_OFFSET>(),
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
            LineStackingStrategyProperty: LineStackingStrategyProperty::<Impl, IMPL_OFFSET>,
            LineHeightProperty: LineHeightProperty::<Impl, IMPL_OFFSET>,
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignmentProperty: HorizontalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalContentAlignmentProperty: VerticalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics5Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics5Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IContentPresenterStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics5, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContextMenuEventArgsImpl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CursorLeft(&mut self) -> ::windows::core::Result<f64>;
    fn CursorTop(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContextMenuEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContextMenuEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContextMenuEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContextMenuEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContextMenuEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: IContextMenuEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IContextMenuEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn CursorLeft<Impl: IContextMenuEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CursorLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CursorTop<Impl: IContextMenuEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CursorTop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContextMenuEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
            CursorLeft: CursorLeft::<Impl, IMPL_OFFSET>,
            CursorTop: CursorTop::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContextMenuEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IControlImpl: Sized {
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IsTabStop(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTabStop(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TabIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetTabIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TabNavigation(&mut self) -> ::windows::core::Result<super::Input::KeyboardNavigationMode>;
    fn SetTabNavigation(&mut self, value: super::Input::KeyboardNavigationMode) -> ::windows::core::Result<()>;
    fn Template(&mut self) -> ::windows::core::Result<ControlTemplate>;
    fn SetTemplate(&mut self, value: &::core::option::Option<ControlTemplate>) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn HorizontalContentAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalContentAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalContentAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalContentAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn FocusState(&mut self) -> ::windows::core::Result<super::FocusState>;
    fn IsEnabledChanged(&mut self, handler: &::core::option::Option<super::DependencyPropertyChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsEnabledChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ApplyTemplate(&mut self) -> ::windows::core::Result<bool>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl";
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IControlVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlVtbl {
        unsafe extern "system" fn FontSize<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTabStop<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTabStop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTabStop<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTabStop(value).into()
        }
        unsafe extern "system" fn IsEnabled<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsEnabled<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsEnabled(value).into()
        }
        unsafe extern "system" fn TabIndex<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabIndex<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTabIndex(value).into()
        }
        unsafe extern "system" fn TabNavigation<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Input::KeyboardNavigationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabNavigation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabNavigation<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Input::KeyboardNavigationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTabNavigation(value).into()
        }
        unsafe extern "system" fn Template<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Template() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTemplate<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTemplate(&*(&value as *const <ControlTemplate as ::windows::core::Abi>::Abi as *const <ControlTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalContentAlignment<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalContentAlignment<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalContentAlignment(value).into()
        }
        unsafe extern "system" fn VerticalContentAlignment<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalContentAlignment<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalContentAlignment(value).into()
        }
        unsafe extern "system" fn Background<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderBrush<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusState<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::FocusState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnabledChanged<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEnabledChanged(&*(&handler as *const <super::DependencyPropertyChangedEventHandler as ::windows::core::Abi>::Abi as *const <super::DependencyPropertyChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsEnabledChanged<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsEnabledChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ApplyTemplate<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ApplyTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl, BASE_OFFSET>(),
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            IsTabStop: IsTabStop::<Impl, IMPL_OFFSET>,
            SetIsTabStop: SetIsTabStop::<Impl, IMPL_OFFSET>,
            IsEnabled: IsEnabled::<Impl, IMPL_OFFSET>,
            SetIsEnabled: SetIsEnabled::<Impl, IMPL_OFFSET>,
            TabIndex: TabIndex::<Impl, IMPL_OFFSET>,
            SetTabIndex: SetTabIndex::<Impl, IMPL_OFFSET>,
            TabNavigation: TabNavigation::<Impl, IMPL_OFFSET>,
            SetTabNavigation: SetTabNavigation::<Impl, IMPL_OFFSET>,
            Template: Template::<Impl, IMPL_OFFSET>,
            SetTemplate: SetTemplate::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignment: HorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalContentAlignment: SetHorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            VerticalContentAlignment: VerticalContentAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalContentAlignment: SetVerticalContentAlignment::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            FocusState: FocusState::<Impl, IMPL_OFFSET>,
            IsEnabledChanged: IsEnabledChanged::<Impl, IMPL_OFFSET>,
            RemoveIsEnabledChanged: RemoveIsEnabledChanged::<Impl, IMPL_OFFSET>,
            ApplyTemplate: ApplyTemplate::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl2Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IControl2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IControl2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IControl2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl2, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl3Impl: Sized {
    fn UseSystemFocusVisuals(&mut self) -> ::windows::core::Result<bool>;
    fn SetUseSystemFocusVisuals(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl3";
}
#[cfg(feature = "implement_exclusive")]
impl IControl3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl3Vtbl {
        unsafe extern "system" fn UseSystemFocusVisuals<Impl: IControl3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseSystemFocusVisuals() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseSystemFocusVisuals<Impl: IControl3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseSystemFocusVisuals(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl3, BASE_OFFSET>(),
            UseSystemFocusVisuals: UseSystemFocusVisuals::<Impl, IMPL_OFFSET>,
            SetUseSystemFocusVisuals: SetUseSystemFocusVisuals::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IControl4Impl: Sized {
    fn IsFocusEngagementEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFocusEngagementEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFocusEngaged(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFocusEngaged(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn RequiresPointer(&mut self) -> ::windows::core::Result<RequiresPointer>;
    fn SetRequiresPointer(&mut self, value: RequiresPointer) -> ::windows::core::Result<()>;
    fn XYFocusLeft(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusLeft(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusRight(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusRight(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusUp(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusUp(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusDown(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusDown(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn ElementSoundMode(&mut self) -> ::windows::core::Result<super::ElementSoundMode>;
    fn SetElementSoundMode(&mut self, value: super::ElementSoundMode) -> ::windows::core::Result<()>;
    fn FocusEngaged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFocusEngaged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FocusDisengaged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFocusDisengaged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RemoveFocusEngagement(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControl4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IControl4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl4Vtbl {
        unsafe extern "system" fn IsFocusEngagementEnabled<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagementEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFocusEngagementEnabled<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFocusEngagementEnabled(value).into()
        }
        unsafe extern "system" fn IsFocusEngaged<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngaged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFocusEngaged<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFocusEngaged(value).into()
        }
        unsafe extern "system" fn RequiresPointer<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RequiresPointer) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RequiresPointer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRequiresPointer<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RequiresPointer) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRequiresPointer(value).into()
        }
        unsafe extern "system" fn XYFocusLeft<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusLeft<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusLeft(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusRight<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusRight<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusRight(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusUp<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusUp<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusUp(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusDown<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusDown<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusDown(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ElementSoundMode<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::ElementSoundMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ElementSoundMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetElementSoundMode<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::ElementSoundMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetElementSoundMode(value).into()
        }
        unsafe extern "system" fn FocusEngaged<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusEngaged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFocusEngaged<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFocusEngaged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusDisengaged<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusDisengaged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFocusDisengaged<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFocusDisengaged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveFocusEngagement<Impl: IControl4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFocusEngagement().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl4, BASE_OFFSET>(),
            IsFocusEngagementEnabled: IsFocusEngagementEnabled::<Impl, IMPL_OFFSET>,
            SetIsFocusEngagementEnabled: SetIsFocusEngagementEnabled::<Impl, IMPL_OFFSET>,
            IsFocusEngaged: IsFocusEngaged::<Impl, IMPL_OFFSET>,
            SetIsFocusEngaged: SetIsFocusEngaged::<Impl, IMPL_OFFSET>,
            RequiresPointer: RequiresPointer::<Impl, IMPL_OFFSET>,
            SetRequiresPointer: SetRequiresPointer::<Impl, IMPL_OFFSET>,
            XYFocusLeft: XYFocusLeft::<Impl, IMPL_OFFSET>,
            SetXYFocusLeft: SetXYFocusLeft::<Impl, IMPL_OFFSET>,
            XYFocusRight: XYFocusRight::<Impl, IMPL_OFFSET>,
            SetXYFocusRight: SetXYFocusRight::<Impl, IMPL_OFFSET>,
            XYFocusUp: XYFocusUp::<Impl, IMPL_OFFSET>,
            SetXYFocusUp: SetXYFocusUp::<Impl, IMPL_OFFSET>,
            XYFocusDown: XYFocusDown::<Impl, IMPL_OFFSET>,
            SetXYFocusDown: SetXYFocusDown::<Impl, IMPL_OFFSET>,
            ElementSoundMode: ElementSoundMode::<Impl, IMPL_OFFSET>,
            SetElementSoundMode: SetElementSoundMode::<Impl, IMPL_OFFSET>,
            FocusEngaged: FocusEngaged::<Impl, IMPL_OFFSET>,
            RemoveFocusEngaged: RemoveFocusEngaged::<Impl, IMPL_OFFSET>,
            FocusDisengaged: FocusDisengaged::<Impl, IMPL_OFFSET>,
            RemoveFocusDisengaged: RemoveFocusDisengaged::<Impl, IMPL_OFFSET>,
            RemoveFocusEngagement: RemoveFocusEngagement::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IControl5Impl: Sized {
    fn DefaultStyleResourceUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetDefaultStyleResourceUri(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControl5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl5";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IControl5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl5Vtbl {
        unsafe extern "system" fn DefaultStyleResourceUri<Impl: IControl5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleResourceUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultStyleResourceUri<Impl: IControl5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultStyleResourceUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl5, BASE_OFFSET>(),
            DefaultStyleResourceUri: DefaultStyleResourceUri::<Impl, IMPL_OFFSET>,
            SetDefaultStyleResourceUri: SetDefaultStyleResourceUri::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl7Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl7";
}
#[cfg(feature = "implement_exclusive")]
impl IControl7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl7Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IControl7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IControl7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IControl7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IControl7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl7, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Control>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IControlFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IControlFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IControlFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IControlOverridesImpl: Sized {
    fn OnPointerEntered(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerPressed(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerMoved(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerReleased(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerExited(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerCaptureLost(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerCanceled(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerWheelChanged(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnTapped(&mut self, e: &::core::option::Option<super::Input::TappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnDoubleTapped(&mut self, e: &::core::option::Option<super::Input::DoubleTappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnHolding(&mut self, e: &::core::option::Option<super::Input::HoldingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnRightTapped(&mut self, e: &::core::option::Option<super::Input::RightTappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationStarting(&mut self, e: &::core::option::Option<super::Input::ManipulationStartingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationInertiaStarting(&mut self, e: &::core::option::Option<super::Input::ManipulationInertiaStartingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationStarted(&mut self, e: &::core::option::Option<super::Input::ManipulationStartedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationDelta(&mut self, e: &::core::option::Option<super::Input::ManipulationDeltaRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationCompleted(&mut self, e: &::core::option::Option<super::Input::ManipulationCompletedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnKeyUp(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnKeyDown(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnGotFocus(&mut self, e: &::core::option::Option<super::RoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnLostFocus(&mut self, e: &::core::option::Option<super::RoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragEnter(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragLeave(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragOver(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDrop(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlOverrides";
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IControlOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlOverridesVtbl {
        unsafe extern "system" fn OnPointerEntered<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerEntered(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerPressed<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerPressed(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerMoved<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerMoved(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerReleased<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerReleased(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerExited<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerExited(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerCaptureLost<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerCaptureLost(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerCanceled<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerCanceled(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerWheelChanged<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerWheelChanged(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnTapped<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnTapped(&*(&e as *const <super::Input::TappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::TappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDoubleTapped<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDoubleTapped(&*(&e as *const <super::Input::DoubleTappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::DoubleTappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnHolding<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnHolding(&*(&e as *const <super::Input::HoldingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::HoldingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnRightTapped<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnRightTapped(&*(&e as *const <super::Input::RightTappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::RightTappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationStarting<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationStarting(&*(&e as *const <super::Input::ManipulationStartingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationStartingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationInertiaStarting<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationInertiaStarting(&*(&e as *const <super::Input::ManipulationInertiaStartingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationInertiaStartingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationStarted<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationStarted(&*(&e as *const <super::Input::ManipulationStartedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationStartedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationDelta<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationDelta(&*(&e as *const <super::Input::ManipulationDeltaRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationDeltaRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationCompleted<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationCompleted(&*(&e as *const <super::Input::ManipulationCompletedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationCompletedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnKeyUp<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnKeyUp(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnKeyDown<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnKeyDown(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnGotFocus<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnGotFocus(&*(&e as *const <super::RoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::RoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnLostFocus<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnLostFocus(&*(&e as *const <super::RoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::RoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragEnter<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDragEnter(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragLeave<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDragLeave(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragOver<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDragOver(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDrop<Impl: IControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDrop(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlOverrides, BASE_OFFSET>(),
            OnPointerEntered: OnPointerEntered::<Impl, IMPL_OFFSET>,
            OnPointerPressed: OnPointerPressed::<Impl, IMPL_OFFSET>,
            OnPointerMoved: OnPointerMoved::<Impl, IMPL_OFFSET>,
            OnPointerReleased: OnPointerReleased::<Impl, IMPL_OFFSET>,
            OnPointerExited: OnPointerExited::<Impl, IMPL_OFFSET>,
            OnPointerCaptureLost: OnPointerCaptureLost::<Impl, IMPL_OFFSET>,
            OnPointerCanceled: OnPointerCanceled::<Impl, IMPL_OFFSET>,
            OnPointerWheelChanged: OnPointerWheelChanged::<Impl, IMPL_OFFSET>,
            OnTapped: OnTapped::<Impl, IMPL_OFFSET>,
            OnDoubleTapped: OnDoubleTapped::<Impl, IMPL_OFFSET>,
            OnHolding: OnHolding::<Impl, IMPL_OFFSET>,
            OnRightTapped: OnRightTapped::<Impl, IMPL_OFFSET>,
            OnManipulationStarting: OnManipulationStarting::<Impl, IMPL_OFFSET>,
            OnManipulationInertiaStarting: OnManipulationInertiaStarting::<Impl, IMPL_OFFSET>,
            OnManipulationStarted: OnManipulationStarted::<Impl, IMPL_OFFSET>,
            OnManipulationDelta: OnManipulationDelta::<Impl, IMPL_OFFSET>,
            OnManipulationCompleted: OnManipulationCompleted::<Impl, IMPL_OFFSET>,
            OnKeyUp: OnKeyUp::<Impl, IMPL_OFFSET>,
            OnKeyDown: OnKeyDown::<Impl, IMPL_OFFSET>,
            OnGotFocus: OnGotFocus::<Impl, IMPL_OFFSET>,
            OnLostFocus: OnLostFocus::<Impl, IMPL_OFFSET>,
            OnDragEnter: OnDragEnter::<Impl, IMPL_OFFSET>,
            OnDragLeave: OnDragLeave::<Impl, IMPL_OFFSET>,
            OnDragOver: OnDragOver::<Impl, IMPL_OFFSET>,
            OnDrop: OnDrop::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IControlOverrides6Impl: Sized {
    fn OnPreviewKeyDown(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPreviewKeyUp(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnCharacterReceived(&mut self, e: &::core::option::Option<super::Input::CharacterReceivedRoutedEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControlOverrides6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlOverrides6";
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IControlOverrides6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlOverrides6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlOverrides6Vtbl {
        unsafe extern "system" fn OnPreviewKeyDown<Impl: IControlOverrides6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPreviewKeyDown(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPreviewKeyUp<Impl: IControlOverrides6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPreviewKeyUp(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnCharacterReceived<Impl: IControlOverrides6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnCharacterReceived(&*(&e as *const <super::Input::CharacterReceivedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::CharacterReceivedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlOverrides6, BASE_OFFSET>(),
            OnPreviewKeyDown: OnPreviewKeyDown::<Impl, IMPL_OFFSET>,
            OnPreviewKeyUp: OnPreviewKeyUp::<Impl, IMPL_OFFSET>,
            OnCharacterReceived: OnCharacterReceived::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlOverrides6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlProtectedImpl: Sized {
    fn DefaultStyleKey(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDefaultStyleKey(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn GetTemplateChild(&mut self, childname: &::windows::core::HSTRING) -> ::windows::core::Result<super::DependencyObject>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlProtected {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlProtected";
}
#[cfg(feature = "implement_exclusive")]
impl IControlProtectedVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlProtectedImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlProtectedVtbl {
        unsafe extern "system" fn DefaultStyleKey<Impl: IControlProtectedImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleKey() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultStyleKey<Impl: IControlProtectedImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultStyleKey(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetTemplateChild<Impl: IControlProtectedImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, childname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTemplateChild(&*(&childname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlProtected, BASE_OFFSET>(),
            DefaultStyleKey: DefaultStyleKey::<Impl, IMPL_OFFSET>,
            SetDefaultStyleKey: SetDefaultStyleKey::<Impl, IMPL_OFFSET>,
            GetTemplateChild: GetTemplateChild::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlProtected as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStaticsImpl: Sized {
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTabStopProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TabIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TabNavigationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultStyleKeyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusStateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStaticsVtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTabStopProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTabStopProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnabledProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TabIndexProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TabNavigationProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabNavigationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalContentAlignmentProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalContentAlignmentProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultStyleKeyProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleKeyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusStateProperty<Impl: IControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusStateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics, BASE_OFFSET>(),
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            IsTabStopProperty: IsTabStopProperty::<Impl, IMPL_OFFSET>,
            IsEnabledProperty: IsEnabledProperty::<Impl, IMPL_OFFSET>,
            TabIndexProperty: TabIndexProperty::<Impl, IMPL_OFFSET>,
            TabNavigationProperty: TabNavigationProperty::<Impl, IMPL_OFFSET>,
            TemplateProperty: TemplateProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignmentProperty: HorizontalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalContentAlignmentProperty: VerticalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            DefaultStyleKeyProperty: DefaultStyleKeyProperty::<Impl, IMPL_OFFSET>,
            FocusStateProperty: FocusStateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics2Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IControlStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics2, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics3Impl: Sized {
    fn UseSystemFocusVisualsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTemplateFocusTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsTemplateFocusTarget(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<bool>;
    fn SetIsTemplateFocusTarget(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics3Vtbl {
        unsafe extern "system" fn UseSystemFocusVisualsProperty<Impl: IControlStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseSystemFocusVisualsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTemplateFocusTargetProperty<Impl: IControlStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTemplateFocusTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsTemplateFocusTarget<Impl: IControlStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsTemplateFocusTarget(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTemplateFocusTarget<Impl: IControlStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTemplateFocusTarget(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics3, BASE_OFFSET>(),
            UseSystemFocusVisualsProperty: UseSystemFocusVisualsProperty::<Impl, IMPL_OFFSET>,
            IsTemplateFocusTargetProperty: IsTemplateFocusTargetProperty::<Impl, IMPL_OFFSET>,
            GetIsTemplateFocusTarget: GetIsTemplateFocusTarget::<Impl, IMPL_OFFSET>,
            SetIsTemplateFocusTarget: SetIsTemplateFocusTarget::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics4Impl: Sized {
    fn IsFocusEngagementEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFocusEngagedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RequiresPointerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusRightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusUpProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusDownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ElementSoundModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics4Vtbl {
        unsafe extern "system" fn IsFocusEngagementEnabledProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagementEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFocusEngagedProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequiresPointerProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RequiresPointerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusLeftProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusRightProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusUpProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUpProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusDownProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ElementSoundModeProperty<Impl: IControlStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ElementSoundModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics4, BASE_OFFSET>(),
            IsFocusEngagementEnabledProperty: IsFocusEngagementEnabledProperty::<Impl, IMPL_OFFSET>,
            IsFocusEngagedProperty: IsFocusEngagedProperty::<Impl, IMPL_OFFSET>,
            RequiresPointerProperty: RequiresPointerProperty::<Impl, IMPL_OFFSET>,
            XYFocusLeftProperty: XYFocusLeftProperty::<Impl, IMPL_OFFSET>,
            XYFocusRightProperty: XYFocusRightProperty::<Impl, IMPL_OFFSET>,
            XYFocusUpProperty: XYFocusUpProperty::<Impl, IMPL_OFFSET>,
            XYFocusDownProperty: XYFocusDownProperty::<Impl, IMPL_OFFSET>,
            ElementSoundModeProperty: ElementSoundModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics5Impl: Sized {
    fn DefaultStyleResourceUriProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTemplateKeyTipTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsTemplateKeyTipTarget(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsTemplateKeyTipTarget(&mut self, element: &::core::option::Option<super::DependencyObject>, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics5Vtbl {
        unsafe extern "system" fn DefaultStyleResourceUriProperty<Impl: IControlStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleResourceUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTemplateKeyTipTargetProperty<Impl: IControlStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTemplateKeyTipTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsTemplateKeyTipTarget<Impl: IControlStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsTemplateKeyTipTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTemplateKeyTipTarget<Impl: IControlStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTemplateKeyTipTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics5, BASE_OFFSET>(),
            DefaultStyleResourceUriProperty: DefaultStyleResourceUriProperty::<Impl, IMPL_OFFSET>,
            IsTemplateKeyTipTargetProperty: IsTemplateKeyTipTargetProperty::<Impl, IMPL_OFFSET>,
            GetIsTemplateKeyTipTarget: GetIsTemplateKeyTipTarget::<Impl, IMPL_OFFSET>,
            SetIsTemplateKeyTipTarget: SetIsTemplateKeyTipTarget::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics7Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics7Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IControlStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IControlStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics7, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "implement_exclusive"))]
pub trait IControlTemplateImpl: Sized {
    fn TargetType(&mut self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SetTargetType(&mut self, value: &super::Interop::TypeName) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControlTemplate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlTemplate";
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "implement_exclusive"))]
impl IControlTemplateVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlTemplateImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlTemplateVtbl {
        unsafe extern "system" fn TargetType<Impl: IControlTemplateImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetType<Impl: IControlTemplateImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTargetType(&*(&value as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlTemplate, BASE_OFFSET>(),
            TargetType: TargetType::<Impl, IMPL_OFFSET>,
            SetTargetType: SetTargetType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlTemplate as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorImpl: Sized {
    fn SelectTemplate(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelectorImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelectorVtbl {
        unsafe extern "system" fn SelectTemplate<Impl: IDataTemplateSelectorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplate(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelector, BASE_OFFSET>(),
            SelectTemplate: SelectTemplate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelector as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelector2Impl: Sized {
    fn SelectTemplateForItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelector2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelector2";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelector2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelector2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelector2Vtbl {
        unsafe extern "system" fn SelectTemplateForItem<Impl: IDataTemplateSelector2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplateForItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelector2, BASE_OFFSET>(),
            SelectTemplateForItem: SelectTemplateForItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelector2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DataTemplateSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelectorFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelectorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDataTemplateSelectorFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelectorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelectorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorOverridesImpl: Sized {
    fn SelectTemplateCore(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelectorOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelectorOverridesVtbl {
        unsafe extern "system" fn SelectTemplateCore<Impl: IDataTemplateSelectorOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplateCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelectorOverrides, BASE_OFFSET>(),
            SelectTemplateCore: SelectTemplateCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelectorOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorOverrides2Impl: Sized {
    fn SelectTemplateForItemCore(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorOverrides2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides2";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorOverrides2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelectorOverrides2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelectorOverrides2Vtbl {
        unsafe extern "system" fn SelectTemplateForItemCore<Impl: IDataTemplateSelectorOverrides2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplateForItemCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelectorOverrides2, BASE_OFFSET>(),
            SelectTemplateForItemCore: SelectTemplateForItemCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelectorOverrides2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickedEventArgsImpl: Sized {
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickedEventArgsVtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickedEventArgs, BASE_OFFSET>(),
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickerImpl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DayVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetDayVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MonthVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetMonthVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn YearVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetYearVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DayFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MonthFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetMonthFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn YearFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetYearFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MinYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn DateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerVtbl {
        unsafe extern "system" fn Header<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarIdentifier<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Date<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayVisible<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayVisible<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayVisible(value).into()
        }
        unsafe extern "system" fn MonthVisible<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthVisible<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthVisible(value).into()
        }
        unsafe extern "system" fn YearVisible<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearVisible<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearVisible(value).into()
        }
        unsafe extern "system" fn DayFormat<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayFormat<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthFormat<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthFormat<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn YearFormat<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearFormat<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinYear<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinYear<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxYear<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxYear<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn DateChanged<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDateChanged<Impl: IDatePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePicker, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDate: SetDate::<Impl, IMPL_OFFSET>,
            DayVisible: DayVisible::<Impl, IMPL_OFFSET>,
            SetDayVisible: SetDayVisible::<Impl, IMPL_OFFSET>,
            MonthVisible: MonthVisible::<Impl, IMPL_OFFSET>,
            SetMonthVisible: SetMonthVisible::<Impl, IMPL_OFFSET>,
            YearVisible: YearVisible::<Impl, IMPL_OFFSET>,
            SetYearVisible: SetYearVisible::<Impl, IMPL_OFFSET>,
            DayFormat: DayFormat::<Impl, IMPL_OFFSET>,
            SetDayFormat: SetDayFormat::<Impl, IMPL_OFFSET>,
            MonthFormat: MonthFormat::<Impl, IMPL_OFFSET>,
            SetMonthFormat: SetMonthFormat::<Impl, IMPL_OFFSET>,
            YearFormat: YearFormat::<Impl, IMPL_OFFSET>,
            SetYearFormat: SetYearFormat::<Impl, IMPL_OFFSET>,
            MinYear: MinYear::<Impl, IMPL_OFFSET>,
            SetMinYear: SetMinYear::<Impl, IMPL_OFFSET>,
            MaxYear: MaxYear::<Impl, IMPL_OFFSET>,
            SetMaxYear: SetMaxYear::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            DateChanged: DateChanged::<Impl, IMPL_OFFSET>,
            RemoveDateChanged: RemoveDateChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePicker2Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePicker2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePicker2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePicker2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IDatePicker2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IDatePicker2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePicker2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePicker2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePicker3Impl: Sized {
    fn SelectedDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn SetSelectedDate(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>) -> ::windows::core::Result<()>;
    fn SelectedDateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedDateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePicker3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePicker3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePicker3Vtbl {
        unsafe extern "system" fn SelectedDate<Impl: IDatePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDate<Impl: IDatePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedDate(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDateChanged<Impl: IDatePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedDateChanged<Impl: IDatePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectedDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePicker3, BASE_OFFSET>(),
            SelectedDate: SelectedDate::<Impl, IMPL_OFFSET>,
            SetSelectedDate: SetSelectedDate::<Impl, IMPL_OFFSET>,
            SelectedDateChanged: SelectedDateChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectedDateChanged: RemoveSelectedDateChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePicker3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DatePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDatePickerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickerFlyoutImpl: Sized {
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DayVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetDayVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MonthVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetMonthVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn YearVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetYearVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MinYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DatePicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDatePicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickerFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutVtbl {
        unsafe extern "system" fn CalendarIdentifier<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Date<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayVisible(value).into()
        }
        unsafe extern "system" fn MonthVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthVisible(value).into()
        }
        unsafe extern "system" fn YearVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearVisible(value).into()
        }
        unsafe extern "system" fn MinYear<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinYear<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxYear<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxYear<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DatePicked<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DatePicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDatePicked<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDatePicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IDatePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyout, BASE_OFFSET>(),
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDate: SetDate::<Impl, IMPL_OFFSET>,
            DayVisible: DayVisible::<Impl, IMPL_OFFSET>,
            SetDayVisible: SetDayVisible::<Impl, IMPL_OFFSET>,
            MonthVisible: MonthVisible::<Impl, IMPL_OFFSET>,
            SetMonthVisible: SetMonthVisible::<Impl, IMPL_OFFSET>,
            YearVisible: YearVisible::<Impl, IMPL_OFFSET>,
            SetYearVisible: SetYearVisible::<Impl, IMPL_OFFSET>,
            MinYear: MinYear::<Impl, IMPL_OFFSET>,
            SetMinYear: SetMinYear::<Impl, IMPL_OFFSET>,
            MaxYear: MaxYear::<Impl, IMPL_OFFSET>,
            SetMaxYear: SetMaxYear::<Impl, IMPL_OFFSET>,
            DatePicked: DatePicked::<Impl, IMPL_OFFSET>,
            RemoveDatePicked: RemoveDatePicked::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyout2Impl: Sized {
    fn DayFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MonthFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetMonthFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn YearFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetYearFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyout2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyout2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyout2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyout2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyout2Vtbl {
        unsafe extern "system" fn DayFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn YearFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyout2, BASE_OFFSET>(),
            DayFormat: DayFormat::<Impl, IMPL_OFFSET>,
            SetDayFormat: SetDayFormat::<Impl, IMPL_OFFSET>,
            MonthFormat: MonthFormat::<Impl, IMPL_OFFSET>,
            SetMonthFormat: SetMonthFormat::<Impl, IMPL_OFFSET>,
            YearFormat: YearFormat::<Impl, IMPL_OFFSET>,
            SetYearFormat: SetYearFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyout2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutItemImpl: Sized {
    fn PrimaryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPrimaryText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SecondaryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSecondaryText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutItemVtbl {
        unsafe extern "system" fn PrimaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutItem, BASE_OFFSET>(),
            PrimaryText: PrimaryText::<Impl, IMPL_OFFSET>,
            SetPrimaryText: SetPrimaryText::<Impl, IMPL_OFFSET>,
            SecondaryText: SecondaryText::<Impl, IMPL_OFFSET>,
            SetSecondaryText: SetSecondaryText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutItemStaticsImpl: Sized {
    fn PrimaryTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutItemStaticsVtbl {
        unsafe extern "system" fn PrimaryTextProperty<Impl: IDatePickerFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryTextProperty<Impl: IDatePickerFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutItemStatics, BASE_OFFSET>(),
            PrimaryTextProperty: PrimaryTextProperty::<Impl, IMPL_OFFSET>,
            SecondaryTextProperty: SecondaryTextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutPresenterVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenter2Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenter2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutPresenter2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutPresenter2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IDatePickerFlyoutPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IDatePickerFlyoutPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutPresenter2, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenterStatics2Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenterStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutPresenterStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutPresenterStatics2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IDatePickerFlyoutPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutPresenterStatics2, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutStaticsImpl: Sized {
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutStaticsVtbl {
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayVisibleProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthVisibleProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearVisibleProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinYearProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxYearProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutStatics, BASE_OFFSET>(),
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
            DayVisibleProperty: DayVisibleProperty::<Impl, IMPL_OFFSET>,
            MonthVisibleProperty: MonthVisibleProperty::<Impl, IMPL_OFFSET>,
            YearVisibleProperty: YearVisibleProperty::<Impl, IMPL_OFFSET>,
            MinYearProperty: MinYearProperty::<Impl, IMPL_OFFSET>,
            MaxYearProperty: MaxYearProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutStatics2Impl: Sized {
    fn DayFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutStatics2Vtbl {
        unsafe extern "system" fn DayFormatProperty<Impl: IDatePickerFlyoutStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthFormatProperty<Impl: IDatePickerFlyoutStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearFormatProperty<Impl: IDatePickerFlyoutStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutStatics2, BASE_OFFSET>(),
            DayFormatProperty: DayFormatProperty::<Impl, IMPL_OFFSET>,
            MonthFormatProperty: MonthFormatProperty::<Impl, IMPL_OFFSET>,
            YearFormatProperty: YearFormatProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickerSelectedValueChangedEventArgsImpl: Sized {
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickerSelectedValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerSelectedValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickerSelectedValueChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerSelectedValueChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerSelectedValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickerSelectedValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickerSelectedValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerSelectedValueChangedEventArgs, BASE_OFFSET>(),
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerSelectedValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStaticsImpl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayVisibleProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthVisibleProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearVisibleProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayFormatProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthFormatProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearFormatProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinYearProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxYearProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IDatePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
            DayVisibleProperty: DayVisibleProperty::<Impl, IMPL_OFFSET>,
            MonthVisibleProperty: MonthVisibleProperty::<Impl, IMPL_OFFSET>,
            YearVisibleProperty: YearVisibleProperty::<Impl, IMPL_OFFSET>,
            DayFormatProperty: DayFormatProperty::<Impl, IMPL_OFFSET>,
            MonthFormatProperty: MonthFormatProperty::<Impl, IMPL_OFFSET>,
            YearFormatProperty: YearFormatProperty::<Impl, IMPL_OFFSET>,
            MinYearProperty: MinYearProperty::<Impl, IMPL_OFFSET>,
            MaxYearProperty: MaxYearProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IDatePickerStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStatics3Impl: Sized {
    fn SelectedDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerStatics3Vtbl {
        unsafe extern "system" fn SelectedDateProperty<Impl: IDatePickerStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerStatics3, BASE_OFFSET>(),
            SelectedDateProperty: SelectedDateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickerValueChangedEventArgsImpl: Sized {
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickerValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickerValueChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerValueChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickerValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickerValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerValueChangedEventArgs, BASE_OFFSET>(),
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IDragItemsCompletedEventArgsImpl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>;
    fn DropResult(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackageOperation>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDragItemsCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDragItemsCompletedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IDragItemsCompletedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDragItemsCompletedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDragItemsCompletedEventArgsVtbl {
        unsafe extern "system" fn Items<Impl: IDragItemsCompletedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropResult<Impl: IDragItemsCompletedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::ApplicationModel::DataTransfer::DataPackageOperation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropResult() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDragItemsCompletedEventArgs, BASE_OFFSET>(),
            Items: Items::<Impl, IMPL_OFFSET>,
            DropResult: DropResult::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDragItemsCompletedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IDragItemsStartingEventArgsImpl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn Data(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDragItemsStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IDragItemsStartingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDragItemsStartingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDragItemsStartingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn Items<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Data<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDragItemsStartingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
            Data: Data::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDragItemsStartingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButton";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButtonVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonAutomationPeerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonAutomationPeerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButtonAutomationPeerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButtonAutomationPeerVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButtonAutomationPeer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButtonAutomationPeer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonAutomationPeerFactoryImpl: Sized {
    fn CreateInstance(&mut self, owner: &::core::option::Option<DropDownButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DropDownButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonAutomationPeerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButtonAutomationPeerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButtonAutomationPeerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDropDownButtonAutomationPeerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <DropDownButton as ::windows::core::Abi>::Abi as *const <DropDownButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButtonAutomationPeerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButtonAutomationPeerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DropDownButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDropDownButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDynamicOverflowItemsChangingEventArgsImpl: Sized {
    fn Action(&mut self) -> ::windows::core::Result<CommandBarDynamicOverflowAction>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDynamicOverflowItemsChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDynamicOverflowItemsChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDynamicOverflowItemsChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDynamicOverflowItemsChangingEventArgsVtbl {
        unsafe extern "system" fn Action<Impl: IDynamicOverflowItemsChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarDynamicOverflowAction) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Action() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDynamicOverflowItemsChangingEventArgs, BASE_OFFSET>(),
            Action: Action::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDynamicOverflowItemsChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipView";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipView, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipView2Impl: Sized {
    fn UseTouchAnimationsForAllNavigation(&mut self) -> ::windows::core::Result<bool>;
    fn SetUseTouchAnimationsForAllNavigation(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipView2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipView2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipView2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipView2Vtbl {
        unsafe extern "system" fn UseTouchAnimationsForAllNavigation<Impl: IFlipView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseTouchAnimationsForAllNavigation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseTouchAnimationsForAllNavigation<Impl: IFlipView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseTouchAnimationsForAllNavigation(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipView2, BASE_OFFSET>(),
            UseTouchAnimationsForAllNavigation: UseTouchAnimationsForAllNavigation::<Impl, IMPL_OFFSET>,
            SetUseTouchAnimationsForAllNavigation: SetUseTouchAnimationsForAllNavigation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlipView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlipViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewItemVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlipViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlipViewItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewStatics2Impl: Sized {
    fn UseTouchAnimationsForAllNavigationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewStatics2Vtbl {
        unsafe extern "system" fn UseTouchAnimationsForAllNavigationProperty<Impl: IFlipViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseTouchAnimationsForAllNavigationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewStatics2, BASE_OFFSET>(),
            UseTouchAnimationsForAllNavigationProperty: UseTouchAnimationsForAllNavigationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutImpl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn FlyoutPresenterStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetFlyoutPresenterStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutVtbl {
        unsafe extern "system" fn Content<Impl: IFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FlyoutPresenterStyle<Impl: IFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyoutPresenterStyle<Impl: IFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlyoutPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyout, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            FlyoutPresenterStyle: FlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
            SetFlyoutPresenterStyle: SetFlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Flyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlyoutFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenterVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenter2Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenter2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenter2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenter2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IFlyoutPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IFlyoutPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenter2, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlyoutPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenterFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlyoutPresenterFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterStatics2Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenterStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenterStatics2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IFlyoutPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenterStatics2, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutStaticsImpl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FlyoutPresenterStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FlyoutPresenterStyleProperty<Impl: IFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            FlyoutPresenterStyleProperty: FlyoutPresenterStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusDisengagedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusDisengagedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusDisengagedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusDisengagedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFocusDisengagedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFocusDisengagedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFocusDisengagedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFocusDisengagedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusEngagedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusEngagedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusEngagedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFocusEngagedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFocusEngagedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFocusEngagedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFocusEngagedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusEngagedEventArgs2Impl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusEngagedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusEngagedEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFocusEngagedEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFocusEngagedEventArgs2Vtbl {
        unsafe extern "system" fn Handled<Impl: IFocusEngagedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IFocusEngagedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFocusEngagedEventArgs2, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFocusEngagedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IFontIconImpl: Sized {
    fn Glyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFontIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon";
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IFontIconVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconVtbl {
        unsafe extern "system" fn Glyph<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IFontIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIcon, BASE_OFFSET>(),
            Glyph: Glyph::<Impl, IMPL_OFFSET>,
            SetGlyph: SetGlyph::<Impl, IMPL_OFFSET>,
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIcon2Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIcon2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon2";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIcon2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIcon2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIcon2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IFontIcon2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IFontIcon2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIcon2, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIcon2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIcon3Impl: Sized {
    fn MirroredWhenRightToLeft(&mut self) -> ::windows::core::Result<bool>;
    fn SetMirroredWhenRightToLeft(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIcon3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon3";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIcon3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIcon3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIcon3Vtbl {
        unsafe extern "system" fn MirroredWhenRightToLeft<Impl: IFontIcon3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirroredWhenRightToLeft<Impl: IFontIcon3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMirroredWhenRightToLeft(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIcon3, BASE_OFFSET>(),
            MirroredWhenRightToLeft: MirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
            SetMirroredWhenRightToLeft: SetMirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIcon3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FontIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFontIconFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IFontIconSourceImpl: Sized {
    fn Glyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MirroredWhenRightToLeft(&mut self) -> ::windows::core::Result<bool>;
    fn SetMirroredWhenRightToLeft(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFontIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSource";
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IFontIconSourceVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconSourceImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconSourceVtbl {
        unsafe extern "system" fn Glyph<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        unsafe extern "system" fn MirroredWhenRightToLeft<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirroredWhenRightToLeft<Impl: IFontIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMirroredWhenRightToLeft(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconSource, BASE_OFFSET>(),
            Glyph: Glyph::<Impl, IMPL_OFFSET>,
            SetGlyph: SetGlyph::<Impl, IMPL_OFFSET>,
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            MirroredWhenRightToLeft: MirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
            SetMirroredWhenRightToLeft: SetMirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconSourceFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FontIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconSourceFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconSourceFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFontIconSourceFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconSourceStaticsImpl: Sized {
    fn GlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MirroredWhenRightToLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconSourceStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconSourceStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconSourceStaticsVtbl {
        unsafe extern "system" fn GlyphProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MirroredWhenRightToLeftProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconSourceStatics, BASE_OFFSET>(),
            GlyphProperty: GlyphProperty::<Impl, IMPL_OFFSET>,
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
            MirroredWhenRightToLeftProperty: MirroredWhenRightToLeftProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStaticsImpl: Sized {
    fn GlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconStaticsVtbl {
        unsafe extern "system" fn GlyphProperty<Impl: IFontIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IFontIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IFontIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IFontIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IFontIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconStatics, BASE_OFFSET>(),
            GlyphProperty: GlyphProperty::<Impl, IMPL_OFFSET>,
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStatics2Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconStatics2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IFontIconStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconStatics2, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStatics3Impl: Sized {
    fn MirroredWhenRightToLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconStatics3Vtbl {
        unsafe extern "system" fn MirroredWhenRightToLeftProperty<Impl: IFontIconStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconStatics3, BASE_OFFSET>(),
            MirroredWhenRightToLeftProperty: MirroredWhenRightToLeftProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IFrameImpl: Sized {
    fn CacheSize(&mut self) -> ::windows::core::Result<i32>;
    fn SetCacheSize(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn CanGoBack(&mut self) -> ::windows::core::Result<bool>;
    fn CanGoForward(&mut self) -> ::windows::core::Result<bool>;
    fn CurrentSourcePageType(&mut self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SourcePageType(&mut self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SetSourcePageType(&mut self, value: &super::Interop::TypeName) -> ::windows::core::Result<()>;
    fn BackStackDepth(&mut self) -> ::windows::core::Result<i32>;
    fn Navigated(&mut self, handler: &::core::option::Option<super::Navigation::NavigatedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigated(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Navigating(&mut self, handler: &::core::option::Option<super::Navigation::NavigatingCancelEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigating(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationFailed(&mut self, handler: &::core::option::Option<super::Navigation::NavigationFailedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationStopped(&mut self, handler: &::core::option::Option<super::Navigation::NavigationStoppedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationStopped(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GoBack(&mut self) -> ::windows::core::Result<()>;
    fn GoForward(&mut self) -> ::windows::core::Result<()>;
    fn Navigate(&mut self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<bool>;
    fn GetNavigationState(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetNavigationState(&mut self, navigationstate: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IFrameVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameVtbl {
        unsafe extern "system" fn CacheSize<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheSize<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCacheSize(value).into()
        }
        unsafe extern "system" fn CanGoBack<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForward<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForward() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSourcePageType<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentSourcePageType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourcePageType<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourcePageType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourcePageType<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourcePageType(&*(&value as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackStackDepth<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStackDepth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigated<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigated(&*(&handler as *const <super::Navigation::NavigatedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigated<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigated(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Navigating<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigating(&*(&handler as *const <super::Navigation::NavigatingCancelEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatingCancelEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigating<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigating(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationFailed<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationFailed(&*(&handler as *const <super::Navigation::NavigationFailedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationFailedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationFailed<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationStopped<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationStopped(&*(&handler as *const <super::Navigation::NavigationStoppedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationStoppedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationStopped<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationStopped(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GoBack<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoBack().into()
        }
        unsafe extern "system" fn GoForward<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoForward().into()
        }
        unsafe extern "system" fn Navigate<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigate(&*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType), &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNavigationState<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNavigationState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigationState<Impl: IFrameImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, navigationstate: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigationState(&*(&navigationstate as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame, BASE_OFFSET>(),
            CacheSize: CacheSize::<Impl, IMPL_OFFSET>,
            SetCacheSize: SetCacheSize::<Impl, IMPL_OFFSET>,
            CanGoBack: CanGoBack::<Impl, IMPL_OFFSET>,
            CanGoForward: CanGoForward::<Impl, IMPL_OFFSET>,
            CurrentSourcePageType: CurrentSourcePageType::<Impl, IMPL_OFFSET>,
            SourcePageType: SourcePageType::<Impl, IMPL_OFFSET>,
            SetSourcePageType: SetSourcePageType::<Impl, IMPL_OFFSET>,
            BackStackDepth: BackStackDepth::<Impl, IMPL_OFFSET>,
            Navigated: Navigated::<Impl, IMPL_OFFSET>,
            RemoveNavigated: RemoveNavigated::<Impl, IMPL_OFFSET>,
            Navigating: Navigating::<Impl, IMPL_OFFSET>,
            RemoveNavigating: RemoveNavigating::<Impl, IMPL_OFFSET>,
            NavigationFailed: NavigationFailed::<Impl, IMPL_OFFSET>,
            RemoveNavigationFailed: RemoveNavigationFailed::<Impl, IMPL_OFFSET>,
            NavigationStopped: NavigationStopped::<Impl, IMPL_OFFSET>,
            RemoveNavigationStopped: RemoveNavigationStopped::<Impl, IMPL_OFFSET>,
            GoBack: GoBack::<Impl, IMPL_OFFSET>,
            GoForward: GoForward::<Impl, IMPL_OFFSET>,
            Navigate: Navigate::<Impl, IMPL_OFFSET>,
            GetNavigationState: GetNavigationState::<Impl, IMPL_OFFSET>,
            SetNavigationState: SetNavigationState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Media_Animation", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IFrame2Impl: Sized {
    fn BackStack(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Navigation::PageStackEntry>>;
    fn ForwardStack(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Navigation::PageStackEntry>>;
    fn Navigate(&mut self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>, infooverride: &::core::option::Option<super::Media::Animation::NavigationTransitionInfo>) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Media_Animation", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame2";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Media_Animation", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IFrame2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame2Vtbl {
        unsafe extern "system" fn BackStack<Impl: IFrame2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForwardStack<Impl: IFrame2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForwardStack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigate<Impl: IFrame2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, infooverride: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigate(
                &*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType),
                &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&infooverride as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::Abi>::Abi as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame2, BASE_OFFSET>(),
            BackStack: BackStack::<Impl, IMPL_OFFSET>,
            ForwardStack: ForwardStack::<Impl, IMPL_OFFSET>,
            Navigate: Navigate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IFrame3Impl: Sized {
    fn GoBack(&mut self, transitioninfooverride: &::core::option::Option<super::Media::Animation::NavigationTransitionInfo>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame3";
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IFrame3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame3Vtbl {
        unsafe extern "system" fn GoBack<Impl: IFrame3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, transitioninfooverride: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoBack(&*(&transitioninfooverride as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::Abi>::Abi as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame3, BASE_OFFSET>(), GoBack: GoBack::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrame4Impl: Sized {
    fn SetNavigationStateWithNavigationControl(&mut self, navigationstate: &::windows::core::HSTRING, suppressnavigate: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrame4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame4";
}
#[cfg(feature = "implement_exclusive")]
impl IFrame4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame4Vtbl {
        unsafe extern "system" fn SetNavigationStateWithNavigationControl<Impl: IFrame4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, navigationstate: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, suppressnavigate: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigationStateWithNavigationControl(&*(&navigationstate as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), suppressnavigate).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame4, BASE_OFFSET>(),
            SetNavigationStateWithNavigationControl: SetNavigationStateWithNavigationControl::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IFrame5Impl: Sized {
    fn IsNavigationStackEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsNavigationStackEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn NavigateToType(&mut self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>, navigationoptions: &::core::option::Option<super::Navigation::FrameNavigationOptions>) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame5";
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IFrame5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame5Vtbl {
        unsafe extern "system" fn IsNavigationStackEnabled<Impl: IFrame5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNavigationStackEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsNavigationStackEnabled<Impl: IFrame5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsNavigationStackEnabled(value).into()
        }
        unsafe extern "system" fn NavigateToType<Impl: IFrame5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, navigationoptions: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigateToType(
                &*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType),
                &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&navigationoptions as *const <super::Navigation::FrameNavigationOptions as ::windows::core::Abi>::Abi as *const <super::Navigation::FrameNavigationOptions as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame5, BASE_OFFSET>(),
            IsNavigationStackEnabled: IsNavigationStackEnabled::<Impl, IMPL_OFFSET>,
            SetIsNavigationStackEnabled: SetIsNavigationStackEnabled::<Impl, IMPL_OFFSET>,
            NavigateToType: NavigateToType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Frame>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFrameFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStaticsImpl: Sized {
    fn CacheSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoBackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoForwardProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CurrentSourcePageTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourcePageTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackStackDepthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameStaticsVtbl {
        unsafe extern "system" fn CacheSizeProperty<Impl: IFrameStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoBackProperty<Impl: IFrameStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForwardProperty<Impl: IFrameStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForwardProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSourcePageTypeProperty<Impl: IFrameStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentSourcePageTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourcePageTypeProperty<Impl: IFrameStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourcePageTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackStackDepthProperty<Impl: IFrameStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStackDepthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameStatics, BASE_OFFSET>(),
            CacheSizeProperty: CacheSizeProperty::<Impl, IMPL_OFFSET>,
            CanGoBackProperty: CanGoBackProperty::<Impl, IMPL_OFFSET>,
            CanGoForwardProperty: CanGoForwardProperty::<Impl, IMPL_OFFSET>,
            CurrentSourcePageTypeProperty: CurrentSourcePageTypeProperty::<Impl, IMPL_OFFSET>,
            SourcePageTypeProperty: SourcePageTypeProperty::<Impl, IMPL_OFFSET>,
            BackStackDepthProperty: BackStackDepthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStatics2Impl: Sized {
    fn BackStackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForwardStackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameStatics2Vtbl {
        unsafe extern "system" fn BackStackProperty<Impl: IFrameStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForwardStackProperty<Impl: IFrameStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForwardStackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameStatics2, BASE_OFFSET>(),
            BackStackProperty: BackStackProperty::<Impl, IMPL_OFFSET>,
            ForwardStackProperty: ForwardStackProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStatics5Impl: Sized {
    fn IsNavigationStackEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameStatics5Vtbl {
        unsafe extern "system" fn IsNavigationStackEnabledProperty<Impl: IFrameStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNavigationStackEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameStatics5, BASE_OFFSET>(),
            IsNavigationStackEnabledProperty: IsNavigationStackEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IGridImpl: Sized {
    fn RowDefinitions(&mut self) -> ::windows::core::Result<RowDefinitionCollection>;
    fn ColumnDefinitions(&mut self) -> ::windows::core::Result<ColumnDefinitionCollection>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IGridVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridVtbl {
        unsafe extern "system" fn RowDefinitions<Impl: IGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowDefinitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColumnDefinitions<Impl: IGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnDefinitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid, BASE_OFFSET>(),
            RowDefinitions: RowDefinitions::<Impl, IMPL_OFFSET>,
            ColumnDefinitions: ColumnDefinitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IGrid2Impl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IGrid2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IGrid2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGrid2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGrid2Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid2, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGrid3Impl: Sized {
    fn RowSpacing(&mut self) -> ::windows::core::Result<f64>;
    fn SetRowSpacing(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ColumnSpacing(&mut self) -> ::windows::core::Result<f64>;
    fn SetColumnSpacing(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid3";
}
#[cfg(feature = "implement_exclusive")]
impl IGrid3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGrid3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGrid3Vtbl {
        unsafe extern "system" fn RowSpacing<Impl: IGrid3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpacing<Impl: IGrid3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRowSpacing(value).into()
        }
        unsafe extern "system" fn ColumnSpacing<Impl: IGrid3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpacing<Impl: IGrid3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumnSpacing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid3, BASE_OFFSET>(),
            RowSpacing: RowSpacing::<Impl, IMPL_OFFSET>,
            SetRowSpacing: SetRowSpacing::<Impl, IMPL_OFFSET>,
            ColumnSpacing: ColumnSpacing::<Impl, IMPL_OFFSET>,
            SetColumnSpacing: SetColumnSpacing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGrid4Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid4";
}
#[cfg(feature = "implement_exclusive")]
impl IGrid4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGrid4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGrid4Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IGrid4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IGrid4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid4, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Grid>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStaticsImpl: Sized {
    fn RowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRow(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetRow(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumn(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetColumn(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn RowSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRowSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetRowSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumnSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetColumnSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStaticsVtbl {
        unsafe extern "system" fn RowProperty<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRow<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRow(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRow<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRow(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnProperty<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumn<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColumn(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumn<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumn(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn RowSpanProperty<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRowSpan<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRowSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpan<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRowSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnSpanProperty<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumnSpan<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColumnSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpan<Impl: IGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumnSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics, BASE_OFFSET>(),
            RowProperty: RowProperty::<Impl, IMPL_OFFSET>,
            GetRow: GetRow::<Impl, IMPL_OFFSET>,
            SetRow: SetRow::<Impl, IMPL_OFFSET>,
            ColumnProperty: ColumnProperty::<Impl, IMPL_OFFSET>,
            GetColumn: GetColumn::<Impl, IMPL_OFFSET>,
            SetColumn: SetColumn::<Impl, IMPL_OFFSET>,
            RowSpanProperty: RowSpanProperty::<Impl, IMPL_OFFSET>,
            GetRowSpan: GetRowSpan::<Impl, IMPL_OFFSET>,
            SetRowSpan: SetRowSpan::<Impl, IMPL_OFFSET>,
            ColumnSpanProperty: ColumnSpanProperty::<Impl, IMPL_OFFSET>,
            GetColumnSpan: GetColumnSpan::<Impl, IMPL_OFFSET>,
            SetColumnSpan: SetColumnSpan::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics2Impl: Sized {
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStatics2Vtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IGridStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IGridStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IGridStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IGridStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics2, BASE_OFFSET>(),
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics3Impl: Sized {
    fn RowSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColumnSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStatics3Vtbl {
        unsafe extern "system" fn RowSpacingProperty<Impl: IGridStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColumnSpacingProperty<Impl: IGridStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics3, BASE_OFFSET>(),
            RowSpacingProperty: RowSpacingProperty::<Impl, IMPL_OFFSET>,
            ColumnSpacingProperty: ColumnSpacingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics4Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStatics4Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IGridStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics4, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridView";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridView, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewHeaderItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewHeaderItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewHeaderItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewHeaderItemVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewHeaderItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewHeaderItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewHeaderItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridViewHeaderItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewHeaderItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewHeaderItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewHeaderItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewHeaderItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewHeaderItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewHeaderItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IGridViewItemImpl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::GridViewItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IGridViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewItem";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IGridViewItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewItemVtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IGridViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewItem, BASE_OFFSET>(), TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupItem";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupItemVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupItemFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleImpl: Sized {
    fn Panel(&mut self) -> ::windows::core::Result<ItemsPanelTemplate>;
    fn SetPanel(&mut self, value: &::core::option::Option<ItemsPanelTemplate>) -> ::windows::core::Result<()>;
    fn ContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetHeaderTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn HidesIfEmpty(&mut self) -> ::windows::core::Result<bool>;
    fn SetHidesIfEmpty(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyle {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyle";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleVtbl {
        unsafe extern "system" fn Panel<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Panel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanel<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanel(&*(&value as *const <ItemsPanelTemplate as ::windows::core::Abi>::Abi as *const <ItemsPanelTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContainerStyle<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerStyle<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContainerStyleSelector<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerStyleSelector<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplateSelector<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplateSelector<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HidesIfEmpty<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HidesIfEmpty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHidesIfEmpty<Impl: IGroupStyleImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHidesIfEmpty(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyle, BASE_OFFSET>(),
            Panel: Panel::<Impl, IMPL_OFFSET>,
            SetPanel: SetPanel::<Impl, IMPL_OFFSET>,
            ContainerStyle: ContainerStyle::<Impl, IMPL_OFFSET>,
            SetContainerStyle: SetContainerStyle::<Impl, IMPL_OFFSET>,
            ContainerStyleSelector: ContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetContainerStyleSelector: SetContainerStyleSelector::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            HeaderTemplateSelector: HeaderTemplateSelector::<Impl, IMPL_OFFSET>,
            SetHeaderTemplateSelector: SetHeaderTemplateSelector::<Impl, IMPL_OFFSET>,
            HidesIfEmpty: HidesIfEmpty::<Impl, IMPL_OFFSET>,
            SetHidesIfEmpty: SetHidesIfEmpty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyle as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyle2Impl: Sized {
    fn HeaderContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetHeaderContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyle2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyle2";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyle2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyle2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyle2Vtbl {
        unsafe extern "system" fn HeaderContainerStyle<Impl: IGroupStyle2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderContainerStyle<Impl: IGroupStyle2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyle2, BASE_OFFSET>(),
            HeaderContainerStyle: HeaderContainerStyle::<Impl, IMPL_OFFSET>,
            SetHeaderContainerStyle: SetHeaderContainerStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyle2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupStyleFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorImpl: Sized {
    fn SelectGroupStyle(&mut self, group: &::core::option::Option<::windows::core::IInspectable>, level: u32) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleSelectorImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleSelectorVtbl {
        unsafe extern "system" fn SelectGroupStyle<Impl: IGroupStyleSelectorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, group: *mut ::core::ffi::c_void, level: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectGroupStyle(&*(&group as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), level) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleSelector, BASE_OFFSET>(),
            SelectGroupStyle: SelectGroupStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleSelector as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupStyleSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleSelectorFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleSelectorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupStyleSelectorFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleSelectorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleSelectorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorOverridesImpl: Sized {
    fn SelectGroupStyleCore(&mut self, group: &::core::option::Option<::windows::core::IInspectable>, level: u32) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleSelectorOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleSelectorOverridesVtbl {
        unsafe extern "system" fn SelectGroupStyleCore<Impl: IGroupStyleSelectorOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, group: *mut ::core::ffi::c_void, level: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectGroupStyleCore(&*(&group as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), level) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleSelectorOverrides, BASE_OFFSET>(),
            SelectGroupStyleCore: SelectGroupStyleCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleSelectorOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingPanelClosedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingPanelClosedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingPanelClosedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingPanelClosedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingPanelClosedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingPanelClosedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingPanelClosedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingPanelClosedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingPanelOpenedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingPanelOpenedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingPanelOpenedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingPanelOpenedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingPanelOpenedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingPanelOpenedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingPanelOpenedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingPanelOpenedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IHandwritingViewImpl: Sized {
    fn PlacementTarget(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn PlacementAlignment(&mut self) -> ::windows::core::Result<HandwritingPanelPlacementAlignment>;
    fn SetPlacementAlignment(&mut self, value: HandwritingPanelPlacementAlignment) -> ::windows::core::Result<()>;
    fn IsOpen(&mut self) -> ::windows::core::Result<bool>;
    fn AreCandidatesEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreCandidatesEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TryClose(&mut self) -> ::windows::core::Result<bool>;
    fn TryOpen(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHandwritingView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingView";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IHandwritingViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewVtbl {
        unsafe extern "system" fn PlacementTarget<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlacementAlignment<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut HandwritingPanelPlacementAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementAlignment<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: HandwritingPanelPlacementAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementAlignment(value).into()
        }
        unsafe extern "system" fn IsOpen<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreCandidatesEnabled<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreCandidatesEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreCandidatesEnabled<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreCandidatesEnabled(value).into()
        }
        unsafe extern "system" fn Opened<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TryClose<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TryClose() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TryOpen<Impl: IHandwritingViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TryOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingView, BASE_OFFSET>(),
            PlacementTarget: PlacementTarget::<Impl, IMPL_OFFSET>,
            SetPlacementTarget: SetPlacementTarget::<Impl, IMPL_OFFSET>,
            PlacementAlignment: PlacementAlignment::<Impl, IMPL_OFFSET>,
            SetPlacementAlignment: SetPlacementAlignment::<Impl, IMPL_OFFSET>,
            IsOpen: IsOpen::<Impl, IMPL_OFFSET>,
            AreCandidatesEnabled: AreCandidatesEnabled::<Impl, IMPL_OFFSET>,
            SetAreCandidatesEnabled: SetAreCandidatesEnabled::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            TryClose: TryClose::<Impl, IMPL_OFFSET>,
            TryOpen: TryOpen::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Core", feature = "implement_exclusive"))]
pub trait IHandwritingView2Impl: Sized {
    fn IsSwitchToKeyboardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSwitchToKeyboardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCommandBarOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCommandBarOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn InputDeviceTypes(&mut self) -> ::windows::core::Result<super::super::Core::CoreInputDeviceTypes>;
    fn SetInputDeviceTypes(&mut self, value: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<()>;
    fn CandidatesChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidatesChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextSubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextSubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetCandidates(&mut self, candidatessessionid: u32) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>;
    fn SelectCandidate(&mut self, candidatessessionid: u32, selectedcandidateindex: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Core", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHandwritingView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingView2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Core", feature = "implement_exclusive"))]
impl IHandwritingView2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingView2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingView2Vtbl {
        unsafe extern "system" fn IsSwitchToKeyboardEnabled<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwitchToKeyboardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSwitchToKeyboardEnabled<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSwitchToKeyboardEnabled(value).into()
        }
        unsafe extern "system" fn IsCommandBarOpen<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCommandBarOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCommandBarOpen<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCommandBarOpen(value).into()
        }
        unsafe extern "system" fn InputDeviceTypes<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Core::CoreInputDeviceTypes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputDeviceTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputDeviceTypes<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputDeviceTypes(value).into()
        }
        unsafe extern "system" fn CandidatesChanged<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidatesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidatesChanged<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCandidatesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextSubmitted<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextSubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextSubmitted<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextSubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetCandidates<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, candidatessessionid: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCandidates(candidatessessionid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectCandidate<Impl: IHandwritingView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, candidatessessionid: u32, selectedcandidateindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectCandidate(candidatessessionid, selectedcandidateindex).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingView2, BASE_OFFSET>(),
            IsSwitchToKeyboardEnabled: IsSwitchToKeyboardEnabled::<Impl, IMPL_OFFSET>,
            SetIsSwitchToKeyboardEnabled: SetIsSwitchToKeyboardEnabled::<Impl, IMPL_OFFSET>,
            IsCommandBarOpen: IsCommandBarOpen::<Impl, IMPL_OFFSET>,
            SetIsCommandBarOpen: SetIsCommandBarOpen::<Impl, IMPL_OFFSET>,
            InputDeviceTypes: InputDeviceTypes::<Impl, IMPL_OFFSET>,
            SetInputDeviceTypes: SetInputDeviceTypes::<Impl, IMPL_OFFSET>,
            CandidatesChanged: CandidatesChanged::<Impl, IMPL_OFFSET>,
            RemoveCandidatesChanged: RemoveCandidatesChanged::<Impl, IMPL_OFFSET>,
            TextSubmitted: TextSubmitted::<Impl, IMPL_OFFSET>,
            RemoveTextSubmitted: RemoveTextSubmitted::<Impl, IMPL_OFFSET>,
            GetCandidates: GetCandidates::<Impl, IMPL_OFFSET>,
            SelectCandidate: SelectCandidate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewCandidatesChangedEventArgsImpl: Sized {
    fn CandidatesSessionId(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewCandidatesChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewCandidatesChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewCandidatesChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewCandidatesChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewCandidatesChangedEventArgsVtbl {
        unsafe extern "system" fn CandidatesSessionId<Impl: IHandwritingViewCandidatesChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidatesSessionId() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewCandidatesChangedEventArgs, BASE_OFFSET>(),
            CandidatesSessionId: CandidatesSessionId::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewCandidatesChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HandwritingView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHandwritingViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewStaticsImpl: Sized {
    fn PlacementTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AreCandidatesEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewStaticsVtbl {
        unsafe extern "system" fn PlacementTargetProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementAlignmentProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOpenProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreCandidatesEnabledProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreCandidatesEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewStatics, BASE_OFFSET>(),
            PlacementTargetProperty: PlacementTargetProperty::<Impl, IMPL_OFFSET>,
            PlacementAlignmentProperty: PlacementAlignmentProperty::<Impl, IMPL_OFFSET>,
            IsOpenProperty: IsOpenProperty::<Impl, IMPL_OFFSET>,
            AreCandidatesEnabledProperty: AreCandidatesEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewStatics2Impl: Sized {
    fn IsSwitchToKeyboardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCommandBarOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewStatics2Vtbl {
        unsafe extern "system" fn IsSwitchToKeyboardEnabledProperty<Impl: IHandwritingViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwitchToKeyboardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCommandBarOpenProperty<Impl: IHandwritingViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCommandBarOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewStatics2, BASE_OFFSET>(),
            IsSwitchToKeyboardEnabledProperty: IsSwitchToKeyboardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsCommandBarOpenProperty: IsCommandBarOpenProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewTextSubmittedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewTextSubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewTextSubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewTextSubmittedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewTextSubmittedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewTextSubmittedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewTextSubmittedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewTextSubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IHubImpl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn DefaultSectionIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetDefaultSectionIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Sections(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn SectionsInView(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn SectionHeaders(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<::windows::core::IInspectable>>;
    fn SectionHeaderClick(&mut self, handler: &::core::option::Option<HubSectionHeaderClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSectionHeaderClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SectionsInViewChanged(&mut self, handler: &::core::option::Option<SectionsInViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSectionsInViewChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollToSection(&mut self, section: &::core::option::Option<HubSection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHub {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHub";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IHubVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubVtbl {
        unsafe extern "system" fn Header<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn DefaultSectionIndex<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultSectionIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSectionIndex<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultSectionIndex(value).into()
        }
        unsafe extern "system" fn Sections<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Sections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionsInView<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionsInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionHeaders<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionHeaders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionHeaderClick<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionHeaderClick(&*(&handler as *const <HubSectionHeaderClickEventHandler as ::windows::core::Abi>::Abi as *const <HubSectionHeaderClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSectionHeaderClick<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSectionHeaderClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SectionsInViewChanged<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionsInViewChanged(&*(&handler as *const <SectionsInViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SectionsInViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSectionsInViewChanged<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSectionsInViewChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollToSection<Impl: IHubImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, section: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollToSection(&*(&section as *const <HubSection as ::windows::core::Abi>::Abi as *const <HubSection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHub, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            DefaultSectionIndex: DefaultSectionIndex::<Impl, IMPL_OFFSET>,
            SetDefaultSectionIndex: SetDefaultSectionIndex::<Impl, IMPL_OFFSET>,
            Sections: Sections::<Impl, IMPL_OFFSET>,
            SectionsInView: SectionsInView::<Impl, IMPL_OFFSET>,
            SectionHeaders: SectionHeaders::<Impl, IMPL_OFFSET>,
            SectionHeaderClick: SectionHeaderClick::<Impl, IMPL_OFFSET>,
            RemoveSectionHeaderClick: RemoveSectionHeaderClick::<Impl, IMPL_OFFSET>,
            SectionsInViewChanged: SectionsInViewChanged::<Impl, IMPL_OFFSET>,
            RemoveSectionsInViewChanged: RemoveSectionsInViewChanged::<Impl, IMPL_OFFSET>,
            ScrollToSection: ScrollToSection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHub as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Hub>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHubFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHubFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHubFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionImpl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn IsHeaderInteractive(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHeaderInteractive(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSection {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSection";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSectionImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSectionVtbl {
        unsafe extern "system" fn Header<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHeaderInteractive<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderInteractive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHeaderInteractive<Impl: IHubSectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHeaderInteractive(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSection, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            ContentTemplate: ContentTemplate::<Impl, IMPL_OFFSET>,
            SetContentTemplate: SetContentTemplate::<Impl, IMPL_OFFSET>,
            IsHeaderInteractive: IsHeaderInteractive::<Impl, IMPL_OFFSET>,
            SetIsHeaderInteractive: SetIsHeaderInteractive::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSection as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HubSection>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSectionFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSectionFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHubSectionFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSectionFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSectionFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionHeaderClickEventArgsImpl: Sized {
    fn Section(&mut self) -> ::windows::core::Result<HubSection>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionHeaderClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionHeaderClickEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSectionHeaderClickEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSectionHeaderClickEventArgsVtbl {
        unsafe extern "system" fn Section<Impl: IHubSectionHeaderClickEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Section() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSectionHeaderClickEventArgs, BASE_OFFSET>(), Section: Section::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSectionHeaderClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionStaticsImpl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHeaderInteractiveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSectionStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSectionStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IHubSectionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IHubSectionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IHubSectionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHeaderInteractiveProperty<Impl: IHubSectionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderInteractiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSectionStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateProperty: ContentTemplateProperty::<Impl, IMPL_OFFSET>,
            IsHeaderInteractiveProperty: IsHeaderInteractiveProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSectionStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubStaticsImpl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultSectionIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SemanticZoomOwnerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsActiveViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHubStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IHubStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IHubStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IHubStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultSectionIndexProperty<Impl: IHubStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultSectionIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SemanticZoomOwnerProperty<Impl: IHubStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwnerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActiveViewProperty<Impl: IHubStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewProperty<Impl: IHubStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHubStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            DefaultSectionIndexProperty: DefaultSectionIndexProperty::<Impl, IMPL_OFFSET>,
            SemanticZoomOwnerProperty: SemanticZoomOwnerProperty::<Impl, IMPL_OFFSET>,
            IsActiveViewProperty: IsActiveViewProperty::<Impl, IMPL_OFFSET>,
            IsZoomedInViewProperty: IsZoomedInViewProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IHyperlinkButtonImpl: Sized {
    fn NavigateUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetNavigateUri(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHyperlinkButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButton";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IHyperlinkButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHyperlinkButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHyperlinkButtonVtbl {
        unsafe extern "system" fn NavigateUri<Impl: IHyperlinkButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigateUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigateUri<Impl: IHyperlinkButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigateUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHyperlinkButton, BASE_OFFSET>(),
            NavigateUri: NavigateUri::<Impl, IMPL_OFFSET>,
            SetNavigateUri: SetNavigateUri::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHyperlinkButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHyperlinkButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HyperlinkButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHyperlinkButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHyperlinkButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHyperlinkButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHyperlinkButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHyperlinkButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHyperlinkButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHyperlinkButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHyperlinkButtonStaticsImpl: Sized {
    fn NavigateUriProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHyperlinkButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHyperlinkButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHyperlinkButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHyperlinkButtonStaticsVtbl {
        unsafe extern "system" fn NavigateUriProperty<Impl: IHyperlinkButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigateUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHyperlinkButtonStatics, BASE_OFFSET>(),
            NavigateUriProperty: NavigateUriProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHyperlinkButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IIconElementImpl: Sized {
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IIconElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElement";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IIconElementVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconElementImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconElementVtbl {
        unsafe extern "system" fn Foreground<Impl: IIconElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IIconElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconElement, BASE_OFFSET>(),
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconElementFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconElementFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconElementFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconElementFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IIconElementFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconElementFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconElementStaticsImpl: Sized {
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconElementStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconElementStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconElementStaticsVtbl {
        unsafe extern "system" fn ForegroundProperty<Impl: IIconElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconElementStatics, BASE_OFFSET>(),
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IIconSourceImpl: Sized {
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSource";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IIconSourceVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceVtbl {
        unsafe extern "system" fn Foreground<Impl: IIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSource, BASE_OFFSET>(),
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementImpl: Sized {
    fn IconSource(&mut self) -> ::windows::core::Result<IconSource>;
    fn SetIconSource(&mut self, value: &::core::option::Option<IconSource>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElement";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceElementImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceElementVtbl {
        unsafe extern "system" fn IconSource<Impl: IIconSourceElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: IIconSourceElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <IconSource as ::windows::core::Abi>::Abi as *const <IconSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceElement, BASE_OFFSET>(),
            IconSource: IconSource::<Impl, IMPL_OFFSET>,
            SetIconSource: SetIconSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<IconSourceElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceElementFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceElementFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IIconSourceElementFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceElementFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceElementFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementStaticsImpl: Sized {
    fn IconSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceElementStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceElementStaticsVtbl {
        unsafe extern "system" fn IconSourceProperty<Impl: IIconSourceElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceElementStatics, BASE_OFFSET>(),
            IconSourceProperty: IconSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceStaticsImpl: Sized {
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceStaticsVtbl {
        unsafe extern "system" fn ForegroundProperty<Impl: IIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceStatics, BASE_OFFSET>(),
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Media_PlayTo", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IImageImpl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn NineGrid(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetNineGrid(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn PlayToSource(&mut self) -> ::windows::core::Result<super::super::super::Media::PlayTo::PlayToSource>;
    fn ImageFailed(&mut self, handler: &::core::option::Option<super::ExceptionRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveImageFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ImageOpened(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveImageOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Media_PlayTo", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IImage {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage";
}
#[cfg(all(feature = "Foundation", feature = "Media_PlayTo", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IImageVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImageImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImageVtbl {
        unsafe extern "system" fn Source<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn NineGrid<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NineGrid() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNineGrid<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNineGrid(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlayToSource<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ImageFailed<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ImageFailed(&*(&handler as *const <super::ExceptionRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::ExceptionRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveImageFailed<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveImageFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ImageOpened<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ImageOpened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveImageOpened<Impl: IImageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveImageOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IImage, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            NineGrid: NineGrid::<Impl, IMPL_OFFSET>,
            SetNineGrid: SetNineGrid::<Impl, IMPL_OFFSET>,
            PlayToSource: PlayToSource::<Impl, IMPL_OFFSET>,
            ImageFailed: ImageFailed::<Impl, IMPL_OFFSET>,
            RemoveImageFailed: RemoveImageFailed::<Impl, IMPL_OFFSET>,
            ImageOpened: ImageOpened::<Impl, IMPL_OFFSET>,
            RemoveImageOpened: RemoveImageOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImage as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Casting", feature = "implement_exclusive"))]
pub trait IImage2Impl: Sized {
    fn GetAsCastingSource(&mut self) -> ::windows::core::Result<super::super::super::Media::Casting::CastingSource>;
}
#[cfg(all(feature = "Media_Casting", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IImage2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage2";
}
#[cfg(all(feature = "Media_Casting", feature = "implement_exclusive"))]
impl IImage2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImage2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImage2Vtbl {
        unsafe extern "system" fn GetAsCastingSource<Impl: IImage2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAsCastingSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IImage2, BASE_OFFSET>(), GetAsCastingSource: GetAsCastingSource::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImage2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
pub trait IImage3Impl: Sized {
    fn GetAlphaMask(&mut self) -> ::windows::core::Result<super::super::Composition::CompositionBrush>;
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IImage3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage3";
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl IImage3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImage3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImage3Vtbl {
        unsafe extern "system" fn GetAlphaMask<Impl: IImage3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlphaMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IImage3, BASE_OFFSET>(), GetAlphaMask: GetAlphaMask::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImage3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IImageStaticsImpl: Sized {
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NineGridProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IImageStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImageStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IImageStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImageStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImageStaticsVtbl {
        unsafe extern "system" fn SourceProperty<Impl: IImageStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IImageStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NineGridProperty<Impl: IImageStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NineGridProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToSourceProperty<Impl: IImageStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IImageStatics, BASE_OFFSET>(),
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            NineGridProperty: NineGridProperty::<Impl, IMPL_OFFSET>,
            PlayToSourceProperty: PlayToSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImageStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkCanvasImpl: Sized {
    fn InkPresenter(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenter>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkCanvas {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkCanvas";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkCanvasVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkCanvasImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkCanvasVtbl {
        unsafe extern "system" fn InkPresenter<Impl: IInkCanvasImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkPresenter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkCanvas, BASE_OFFSET>(), InkPresenter: InkPresenter::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkCanvas as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkCanvasFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkCanvas>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkCanvasFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkCanvasFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkCanvasFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkCanvasFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkCanvasFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkCanvasFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkCanvasFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkCanvasFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkToolbarImpl: Sized {
    fn InitialControls(&mut self) -> ::windows::core::Result<InkToolbarInitialControls>;
    fn SetInitialControls(&mut self, value: InkToolbarInitialControls) -> ::windows::core::Result<()>;
    fn Children(&mut self) -> ::windows::core::Result<super::DependencyObjectCollection>;
    fn ActiveTool(&mut self) -> ::windows::core::Result<InkToolbarToolButton>;
    fn SetActiveTool(&mut self, value: &::core::option::Option<InkToolbarToolButton>) -> ::windows::core::Result<()>;
    fn InkDrawingAttributes(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
    fn IsRulerButtonChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRulerButtonChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TargetInkCanvas(&mut self) -> ::windows::core::Result<InkCanvas>;
    fn SetTargetInkCanvas(&mut self, value: &::core::option::Option<InkCanvas>) -> ::windows::core::Result<()>;
    fn ActiveToolChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveActiveToolChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn InkDrawingAttributesChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveInkDrawingAttributesChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn EraseAllClicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveEraseAllClicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn IsRulerButtonCheckedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsRulerButtonCheckedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetToolButton(&mut self, tool: InkToolbarTool) -> ::windows::core::Result<InkToolbarToolButton>;
    fn GetToggleButton(&mut self, tool: InkToolbarToggle) -> ::windows::core::Result<InkToolbarToggleButton>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkToolbarVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarVtbl {
        unsafe extern "system" fn InitialControls<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarInitialControls) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitialControls<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarInitialControls) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInitialControls(value).into()
        }
        unsafe extern "system" fn Children<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActiveTool<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActiveTool() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetActiveTool<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetActiveTool(&*(&value as *const <InkToolbarToolButton as ::windows::core::Abi>::Abi as *const <InkToolbarToolButton as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InkDrawingAttributes<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerButtonChecked<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRulerButtonChecked<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRulerButtonChecked(value).into()
        }
        unsafe extern "system" fn TargetInkCanvas<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkCanvas() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetInkCanvas<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTargetInkCanvas(&*(&value as *const <InkCanvas as ::windows::core::Abi>::Abi as *const <InkCanvas as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ActiveToolChanged<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActiveToolChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveActiveToolChanged<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveActiveToolChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InkDrawingAttributesChanged<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveInkDrawingAttributesChanged<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveInkDrawingAttributesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn EraseAllClicked<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EraseAllClicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEraseAllClicked<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveEraseAllClicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsRulerButtonCheckedChanged<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsRulerButtonCheckedChanged<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsRulerButtonCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetToolButton<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tool: InkToolbarTool, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetToolButton(tool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToggleButton<Impl: IInkToolbarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tool: InkToolbarToggle, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetToggleButton(tool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbar, BASE_OFFSET>(),
            InitialControls: InitialControls::<Impl, IMPL_OFFSET>,
            SetInitialControls: SetInitialControls::<Impl, IMPL_OFFSET>,
            Children: Children::<Impl, IMPL_OFFSET>,
            ActiveTool: ActiveTool::<Impl, IMPL_OFFSET>,
            SetActiveTool: SetActiveTool::<Impl, IMPL_OFFSET>,
            InkDrawingAttributes: InkDrawingAttributes::<Impl, IMPL_OFFSET>,
            IsRulerButtonChecked: IsRulerButtonChecked::<Impl, IMPL_OFFSET>,
            SetIsRulerButtonChecked: SetIsRulerButtonChecked::<Impl, IMPL_OFFSET>,
            TargetInkCanvas: TargetInkCanvas::<Impl, IMPL_OFFSET>,
            SetTargetInkCanvas: SetTargetInkCanvas::<Impl, IMPL_OFFSET>,
            ActiveToolChanged: ActiveToolChanged::<Impl, IMPL_OFFSET>,
            RemoveActiveToolChanged: RemoveActiveToolChanged::<Impl, IMPL_OFFSET>,
            InkDrawingAttributesChanged: InkDrawingAttributesChanged::<Impl, IMPL_OFFSET>,
            RemoveInkDrawingAttributesChanged: RemoveInkDrawingAttributesChanged::<Impl, IMPL_OFFSET>,
            EraseAllClicked: EraseAllClicked::<Impl, IMPL_OFFSET>,
            RemoveEraseAllClicked: RemoveEraseAllClicked::<Impl, IMPL_OFFSET>,
            IsRulerButtonCheckedChanged: IsRulerButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsRulerButtonCheckedChanged: RemoveIsRulerButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            GetToolButton: GetToolButton::<Impl, IMPL_OFFSET>,
            GetToggleButton: GetToggleButton::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbar as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IInkToolbar2Impl: Sized {
    fn IsStencilButtonChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsStencilButtonChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ButtonFlyoutPlacement(&mut self) -> ::windows::core::Result<InkToolbarButtonFlyoutPlacement>;
    fn SetButtonFlyoutPlacement(&mut self, value: InkToolbarButtonFlyoutPlacement) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn IsStencilButtonCheckedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsStencilButtonCheckedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetMenuButton(&mut self, menu: InkToolbarMenuKind) -> ::windows::core::Result<InkToolbarMenuButton>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IInkToolbar2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbar2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbar2Vtbl {
        unsafe extern "system" fn IsStencilButtonChecked<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStencilButtonChecked<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsStencilButtonChecked(value).into()
        }
        unsafe extern "system" fn ButtonFlyoutPlacement<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarButtonFlyoutPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ButtonFlyoutPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetButtonFlyoutPlacement<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarButtonFlyoutPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetButtonFlyoutPlacement(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn IsStencilButtonCheckedChanged<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsStencilButtonCheckedChanged<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsStencilButtonCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetMenuButton<Impl: IInkToolbar2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, menu: InkToolbarMenuKind, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMenuButton(menu) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbar2, BASE_OFFSET>(),
            IsStencilButtonChecked: IsStencilButtonChecked::<Impl, IMPL_OFFSET>,
            SetIsStencilButtonChecked: SetIsStencilButtonChecked::<Impl, IMPL_OFFSET>,
            ButtonFlyoutPlacement: ButtonFlyoutPlacement::<Impl, IMPL_OFFSET>,
            SetButtonFlyoutPlacement: SetButtonFlyoutPlacement::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            IsStencilButtonCheckedChanged: IsStencilButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsStencilButtonCheckedChanged: RemoveIsStencilButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            GetMenuButton: GetMenuButton::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbar2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkToolbar3Impl: Sized {
    fn TargetInkPresenter(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenter>;
    fn SetTargetInkPresenter(&mut self, value: &::core::option::Option<super::super::Input::Inking::InkPresenter>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar3";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkToolbar3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbar3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbar3Vtbl {
        unsafe extern "system" fn TargetInkPresenter<Impl: IInkToolbar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkPresenter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetInkPresenter<Impl: IInkToolbar3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTargetInkPresenter(&*(&value as *const <super::super::Input::Inking::InkPresenter as ::windows::core::Abi>::Abi as *const <super::super::Input::Inking::InkPresenter as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbar3, BASE_OFFSET>(),
            TargetInkPresenter: TargetInkPresenter::<Impl, IMPL_OFFSET>,
            SetTargetInkPresenter: SetTargetInkPresenter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbar3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarBallpointPenButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarBallpointPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarBallpointPenButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarBallpointPenButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarBallpointPenButtonVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarBallpointPenButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarBallpointPenButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarBallpointPenButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarBallpointPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarBallpointPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarBallpointPenButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarBallpointPenButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarBallpointPenButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarBallpointPenButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarBallpointPenButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarBallpointPenButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IInkToolbarCustomPenImpl: Sized {
    fn CreateInkDrawingAttributes(&mut self, brush: &::core::option::Option<super::Media::Brush>, strokewidth: f64) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarCustomPen {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPen";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IInkToolbarCustomPenVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenVtbl {
        unsafe extern "system" fn CreateInkDrawingAttributes<Impl: IInkToolbarCustomPenImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brush: ::windows::core::RawPtr, strokewidth: f64, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInkDrawingAttributes(&*(&brush as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType), strokewidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPen, BASE_OFFSET>(),
            CreateInkDrawingAttributes: CreateInkDrawingAttributes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPen as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonImpl: Sized {
    fn CustomPen(&mut self) -> ::windows::core::Result<InkToolbarCustomPen>;
    fn SetCustomPen(&mut self, value: &::core::option::Option<InkToolbarCustomPen>) -> ::windows::core::Result<()>;
    fn ConfigurationContent(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetConfigurationContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenButtonVtbl {
        unsafe extern "system" fn CustomPen<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CustomPen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCustomPen<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCustomPen(&*(&value as *const <InkToolbarCustomPen as ::windows::core::Abi>::Abi as *const <InkToolbarCustomPen as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ConfigurationContent<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfigurationContent<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConfigurationContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenButton, BASE_OFFSET>(),
            CustomPen: CustomPen::<Impl, IMPL_OFFSET>,
            SetCustomPen: SetCustomPen::<Impl, IMPL_OFFSET>,
            ConfigurationContent: ConfigurationContent::<Impl, IMPL_OFFSET>,
            SetConfigurationContent: SetConfigurationContent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomPenButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonStaticsImpl: Sized {
    fn CustomPenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ConfigurationContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenButtonStaticsVtbl {
        unsafe extern "system" fn CustomPenProperty<Impl: IInkToolbarCustomPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CustomPenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfigurationContentProperty<Impl: IInkToolbarCustomPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenButtonStatics, BASE_OFFSET>(),
            CustomPenProperty: CustomPenProperty::<Impl, IMPL_OFFSET>,
            ConfigurationContentProperty: ConfigurationContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomPen>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomPenFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IInkToolbarCustomPenOverridesImpl: Sized {
    fn CreateInkDrawingAttributesCore(&mut self, brush: &::core::option::Option<super::Media::Brush>, strokewidth: f64) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenOverrides";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IInkToolbarCustomPenOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenOverridesVtbl {
        unsafe extern "system" fn CreateInkDrawingAttributesCore<Impl: IInkToolbarCustomPenOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brush: ::windows::core::RawPtr, strokewidth: f64, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInkDrawingAttributesCore(&*(&brush as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType), strokewidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenOverrides, BASE_OFFSET>(),
            CreateInkDrawingAttributesCore: CreateInkDrawingAttributesCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToggleButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToggleButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToggleButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToggleButtonVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToggleButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToggleButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToggleButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomToggleButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToggleButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToggleButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToggleButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomToggleButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToggleButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToggleButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonImpl: Sized {
    fn ConfigurationContent(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetConfigurationContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToolButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToolButtonVtbl {
        unsafe extern "system" fn ConfigurationContent<Impl: IInkToolbarCustomToolButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfigurationContent<Impl: IInkToolbarCustomToolButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConfigurationContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToolButton, BASE_OFFSET>(),
            ConfigurationContent: ConfigurationContent::<Impl, IMPL_OFFSET>,
            SetConfigurationContent: SetConfigurationContent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToolButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomToolButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToolButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToolButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomToolButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToolButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToolButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonStaticsImpl: Sized {
    fn ConfigurationContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToolButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToolButtonStaticsVtbl {
        unsafe extern "system" fn ConfigurationContentProperty<Impl: IInkToolbarCustomToolButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToolButtonStatics, BASE_OFFSET>(),
            ConfigurationContentProperty: ConfigurationContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToolButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButtonVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButton2Impl: Sized {
    fn IsClearAllVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsClearAllVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButton2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButton2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButton2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButton2Vtbl {
        unsafe extern "system" fn IsClearAllVisible<Impl: IInkToolbarEraserButton2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearAllVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsClearAllVisible<Impl: IInkToolbarEraserButton2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsClearAllVisible(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButton2, BASE_OFFSET>(),
            IsClearAllVisible: IsClearAllVisible::<Impl, IMPL_OFFSET>,
            SetIsClearAllVisible: SetIsClearAllVisible::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButton2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarEraserButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarEraserButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonStatics2Impl: Sized {
    fn IsClearAllVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButtonStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButtonStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButtonStatics2Vtbl {
        unsafe extern "system" fn IsClearAllVisibleProperty<Impl: IInkToolbarEraserButtonStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearAllVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButtonStatics2, BASE_OFFSET>(),
            IsClearAllVisibleProperty: IsClearAllVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButtonStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IInkToolbarFlyoutItemImpl: Sized {
    fn Kind(&mut self) -> ::windows::core::Result<InkToolbarFlyoutItemKind>;
    fn SetKind(&mut self, value: InkToolbarFlyoutItemKind) -> ::windows::core::Result<()>;
    fn IsChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Checked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChecked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Unchecked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnchecked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItem";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IInkToolbarFlyoutItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFlyoutItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFlyoutItemVtbl {
        unsafe extern "system" fn Kind<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarFlyoutItemKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Kind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKind<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarFlyoutItemKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKind(value).into()
        }
        unsafe extern "system" fn IsChecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        unsafe extern "system" fn Checked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Checked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveChecked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Unchecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Unchecked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnchecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnchecked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFlyoutItem, BASE_OFFSET>(),
            Kind: Kind::<Impl, IMPL_OFFSET>,
            SetKind: SetKind::<Impl, IMPL_OFFSET>,
            IsChecked: IsChecked::<Impl, IMPL_OFFSET>,
            SetIsChecked: SetIsChecked::<Impl, IMPL_OFFSET>,
            Checked: Checked::<Impl, IMPL_OFFSET>,
            RemoveChecked: RemoveChecked::<Impl, IMPL_OFFSET>,
            Unchecked: Unchecked::<Impl, IMPL_OFFSET>,
            RemoveUnchecked: RemoveUnchecked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFlyoutItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFlyoutItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFlyoutItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFlyoutItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarFlyoutItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFlyoutItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFlyoutItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFlyoutItemStaticsImpl: Sized {
    fn KindProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFlyoutItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFlyoutItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFlyoutItemStaticsVtbl {
        unsafe extern "system" fn KindProperty<Impl: IInkToolbarFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCheckedProperty<Impl: IInkToolbarFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFlyoutItemStatics, BASE_OFFSET>(),
            KindProperty: KindProperty::<Impl, IMPL_OFFSET>,
            IsCheckedProperty: IsCheckedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarHighlighterButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarHighlighterButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarHighlighterButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarHighlighterButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarHighlighterButtonVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarHighlighterButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarHighlighterButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarHighlighterButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarHighlighterButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarHighlighterButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarHighlighterButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarHighlighterButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarHighlighterButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarHighlighterButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarHighlighterButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarHighlighterButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl: Sized {
    fn StencilButton(&mut self) -> ::windows::core::Result<InkToolbarStencilButton>;
    fn StencilKind(&mut self) -> ::windows::core::Result<InkToolbarStencilKind>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarIsStencilButtonCheckedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarIsStencilButtonCheckedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarIsStencilButtonCheckedChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarIsStencilButtonCheckedChangedEventArgsVtbl {
        unsafe extern "system" fn StencilButton<Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StencilButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StencilKind<Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StencilKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarIsStencilButtonCheckedChangedEventArgs, BASE_OFFSET>(),
            StencilButton: StencilButton::<Impl, IMPL_OFFSET>,
            StencilKind: StencilKind::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarIsStencilButtonCheckedChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonImpl: Sized {
    fn MenuKind(&mut self) -> ::windows::core::Result<InkToolbarMenuKind>;
    fn IsExtensionGlyphShown(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExtensionGlyphShown(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarMenuButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarMenuButtonVtbl {
        unsafe extern "system" fn MenuKind<Impl: IInkToolbarMenuButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarMenuKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExtensionGlyphShown<Impl: IInkToolbarMenuButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExtensionGlyphShown<Impl: IInkToolbarMenuButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExtensionGlyphShown(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarMenuButton, BASE_OFFSET>(),
            MenuKind: MenuKind::<Impl, IMPL_OFFSET>,
            IsExtensionGlyphShown: IsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
            SetIsExtensionGlyphShown: SetIsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarMenuButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarMenuButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarMenuButtonFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarMenuButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarMenuButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonStaticsImpl: Sized {
    fn IsExtensionGlyphShownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarMenuButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarMenuButtonStaticsVtbl {
        unsafe extern "system" fn IsExtensionGlyphShownProperty<Impl: IInkToolbarMenuButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarMenuButtonStatics, BASE_OFFSET>(),
            IsExtensionGlyphShownProperty: IsExtensionGlyphShownProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarMenuButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IInkToolbarPenButtonImpl: Sized {
    fn Palette(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Media::Brush>>;
    fn SetPalette(&mut self, value: &::core::option::Option<super::super::super::Foundation::Collections::IVector<super::Media::Brush>>) -> ::windows::core::Result<()>;
    fn MinStrokeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinStrokeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MaxStrokeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxStrokeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn SelectedBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SelectedBrushIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectedBrushIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedStrokeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetSelectedStrokeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButton";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IInkToolbarPenButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenButtonVtbl {
        unsafe extern "system" fn Palette<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Palette() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPalette<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPalette(&*(&value as *const <super::super::super::Foundation::Collections::IVector<super::Media::Brush> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<super::Media::Brush> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinStrokeWidth(value).into()
        }
        unsafe extern "system" fn MaxStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxStrokeWidth(value).into()
        }
        unsafe extern "system" fn SelectedBrush<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushIndex<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrushIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedBrushIndex<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedBrushIndex(value).into()
        }
        unsafe extern "system" fn SelectedStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedStrokeWidth(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenButton, BASE_OFFSET>(),
            Palette: Palette::<Impl, IMPL_OFFSET>,
            SetPalette: SetPalette::<Impl, IMPL_OFFSET>,
            MinStrokeWidth: MinStrokeWidth::<Impl, IMPL_OFFSET>,
            SetMinStrokeWidth: SetMinStrokeWidth::<Impl, IMPL_OFFSET>,
            MaxStrokeWidth: MaxStrokeWidth::<Impl, IMPL_OFFSET>,
            SetMaxStrokeWidth: SetMaxStrokeWidth::<Impl, IMPL_OFFSET>,
            SelectedBrush: SelectedBrush::<Impl, IMPL_OFFSET>,
            SelectedBrushIndex: SelectedBrushIndex::<Impl, IMPL_OFFSET>,
            SetSelectedBrushIndex: SetSelectedBrushIndex::<Impl, IMPL_OFFSET>,
            SelectedStrokeWidth: SelectedStrokeWidth::<Impl, IMPL_OFFSET>,
            SetSelectedStrokeWidth: SetSelectedStrokeWidth::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenButtonFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenButtonStaticsImpl: Sized {
    fn PaletteProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinStrokeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxStrokeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBrushIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedStrokeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenButtonStaticsVtbl {
        unsafe extern "system" fn PaletteProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaletteProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinStrokeWidthProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxStrokeWidthProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushIndexProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrushIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStrokeWidthProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenButtonStatics, BASE_OFFSET>(),
            PaletteProperty: PaletteProperty::<Impl, IMPL_OFFSET>,
            MinStrokeWidthProperty: MinStrokeWidthProperty::<Impl, IMPL_OFFSET>,
            MaxStrokeWidthProperty: MaxStrokeWidthProperty::<Impl, IMPL_OFFSET>,
            SelectedBrushProperty: SelectedBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedBrushIndexProperty: SelectedBrushIndexProperty::<Impl, IMPL_OFFSET>,
            SelectedStrokeWidthProperty: SelectedStrokeWidthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlImpl: Sized {
    fn PenButton(&mut self) -> ::windows::core::Result<InkToolbarPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControl";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenConfigurationControlImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenConfigurationControlVtbl {
        unsafe extern "system" fn PenButton<Impl: IInkToolbarPenConfigurationControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PenButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenConfigurationControl, BASE_OFFSET>(),
            PenButton: PenButton::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenConfigurationControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarPenConfigurationControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenConfigurationControlFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenConfigurationControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarPenConfigurationControlFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenConfigurationControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenConfigurationControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlStaticsImpl: Sized {
    fn PenButtonProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenConfigurationControlStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenConfigurationControlStaticsVtbl {
        unsafe extern "system" fn PenButtonProperty<Impl: IInkToolbarPenConfigurationControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PenButtonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenConfigurationControlStatics, BASE_OFFSET>(),
            PenButtonProperty: PenButtonProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenConfigurationControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPencilButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPencilButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPencilButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPencilButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPencilButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPencilButtonVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPencilButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPencilButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPencilButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarPencilButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPencilButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPencilButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPencilButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPencilButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPencilButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarPencilButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPencilButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPencilButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonImpl: Sized {
    fn Ruler(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterRuler>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButton";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarRulerButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarRulerButtonVtbl {
        unsafe extern "system" fn Ruler<Impl: IInkToolbarRulerButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Ruler() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarRulerButton, BASE_OFFSET>(), Ruler: Ruler::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarRulerButton as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarRulerButton>;
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonFactory";
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarRulerButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarRulerButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarRulerButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarRulerButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarRulerButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonStaticsImpl: Sized {
    fn RulerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonStatics";
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarRulerButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarRulerButtonStaticsVtbl {
        unsafe extern "system" fn RulerProperty<Impl: IInkToolbarRulerButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RulerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarRulerButtonStatics, BASE_OFFSET>(),
            RulerProperty: RulerProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarRulerButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStaticsImpl: Sized {
    fn InitialControlsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildrenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ActiveToolProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InkDrawingAttributesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRulerButtonCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TargetInkCanvasProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStaticsVtbl {
        unsafe extern "system" fn InitialControlsProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialControlsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActiveToolProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActiveToolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InkDrawingAttributesProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerButtonCheckedProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TargetInkCanvasProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkCanvasProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStatics, BASE_OFFSET>(),
            InitialControlsProperty: InitialControlsProperty::<Impl, IMPL_OFFSET>,
            ChildrenProperty: ChildrenProperty::<Impl, IMPL_OFFSET>,
            ActiveToolProperty: ActiveToolProperty::<Impl, IMPL_OFFSET>,
            InkDrawingAttributesProperty: InkDrawingAttributesProperty::<Impl, IMPL_OFFSET>,
            IsRulerButtonCheckedProperty: IsRulerButtonCheckedProperty::<Impl, IMPL_OFFSET>,
            TargetInkCanvasProperty: TargetInkCanvasProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStatics2Impl: Sized {
    fn IsStencilButtonCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ButtonFlyoutPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStatics2Vtbl {
        unsafe extern "system" fn IsStencilButtonCheckedProperty<Impl: IInkToolbarStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonFlyoutPlacementProperty<Impl: IInkToolbarStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ButtonFlyoutPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IInkToolbarStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStatics2, BASE_OFFSET>(),
            IsStencilButtonCheckedProperty: IsStencilButtonCheckedProperty::<Impl, IMPL_OFFSET>,
            ButtonFlyoutPlacementProperty: ButtonFlyoutPlacementProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStatics3Impl: Sized {
    fn TargetInkPresenterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStatics3Vtbl {
        unsafe extern "system" fn TargetInkPresenterProperty<Impl: IInkToolbarStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkPresenterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStatics3, BASE_OFFSET>(),
            TargetInkPresenterProperty: TargetInkPresenterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkToolbarStencilButtonImpl: Sized {
    fn Ruler(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterRuler>;
    fn Protractor(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterProtractor>;
    fn SelectedStencil(&mut self) -> ::windows::core::Result<InkToolbarStencilKind>;
    fn SetSelectedStencil(&mut self, value: InkToolbarStencilKind) -> ::windows::core::Result<()>;
    fn IsRulerItemVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRulerItemVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsProtractorItemVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsProtractorItemVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarStencilButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButton";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkToolbarStencilButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStencilButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStencilButtonVtbl {
        unsafe extern "system" fn Ruler<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Ruler() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Protractor<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Protractor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStencil<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStencil() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStencil<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedStencil(value).into()
        }
        unsafe extern "system" fn IsRulerItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerItemVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRulerItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRulerItemVisible(value).into()
        }
        unsafe extern "system" fn IsProtractorItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsProtractorItemVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsProtractorItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsProtractorItemVisible(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStencilButton, BASE_OFFSET>(),
            Ruler: Ruler::<Impl, IMPL_OFFSET>,
            Protractor: Protractor::<Impl, IMPL_OFFSET>,
            SelectedStencil: SelectedStencil::<Impl, IMPL_OFFSET>,
            SetSelectedStencil: SetSelectedStencil::<Impl, IMPL_OFFSET>,
            IsRulerItemVisible: IsRulerItemVisible::<Impl, IMPL_OFFSET>,
            SetIsRulerItemVisible: SetIsRulerItemVisible::<Impl, IMPL_OFFSET>,
            IsProtractorItemVisible: IsProtractorItemVisible::<Impl, IMPL_OFFSET>,
            SetIsProtractorItemVisible: SetIsProtractorItemVisible::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStencilButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStencilButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarStencilButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStencilButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStencilButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStencilButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStencilButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarStencilButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStencilButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStencilButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStencilButtonStaticsImpl: Sized {
    fn RulerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProtractorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedStencilProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRulerItemVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsProtractorItemVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStencilButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStencilButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStencilButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStencilButtonStaticsVtbl {
        unsafe extern "system" fn RulerProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RulerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtractorProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProtractorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStencilProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStencilProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerItemVisibleProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerItemVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsProtractorItemVisibleProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsProtractorItemVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStencilButtonStatics, BASE_OFFSET>(),
            RulerProperty: RulerProperty::<Impl, IMPL_OFFSET>,
            ProtractorProperty: ProtractorProperty::<Impl, IMPL_OFFSET>,
            SelectedStencilProperty: SelectedStencilProperty::<Impl, IMPL_OFFSET>,
            IsRulerItemVisibleProperty: IsRulerItemVisibleProperty::<Impl, IMPL_OFFSET>,
            IsProtractorItemVisibleProperty: IsProtractorItemVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStencilButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToggleButtonImpl: Sized {
    fn ToggleKind(&mut self) -> ::windows::core::Result<InkToolbarToggle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToggleButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToggleButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToggleButtonVtbl {
        unsafe extern "system" fn ToggleKind<Impl: IInkToolbarToggleButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarToggle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ToggleKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToggleButton, BASE_OFFSET>(), ToggleKind: ToggleKind::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToggleButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToggleButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToggleButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToggleButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToggleButtonFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToggleButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToggleButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonImpl: Sized {
    fn ToolKind(&mut self) -> ::windows::core::Result<InkToolbarTool>;
    fn IsExtensionGlyphShown(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExtensionGlyphShown(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToolButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToolButtonVtbl {
        unsafe extern "system" fn ToolKind<Impl: IInkToolbarToolButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarTool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ToolKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExtensionGlyphShown<Impl: IInkToolbarToolButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExtensionGlyphShown<Impl: IInkToolbarToolButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExtensionGlyphShown(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToolButton, BASE_OFFSET>(),
            ToolKind: ToolKind::<Impl, IMPL_OFFSET>,
            IsExtensionGlyphShown: IsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
            SetIsExtensionGlyphShown: SetIsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToolButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToolButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToolButtonFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToolButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToolButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonStaticsImpl: Sized {
    fn IsExtensionGlyphShownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToolButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToolButtonStaticsVtbl {
        unsafe extern "system" fn IsExtensionGlyphShownProperty<Impl: IInkToolbarToolButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToolButtonStatics, BASE_OFFSET>(),
            IsExtensionGlyphShownProperty: IsExtensionGlyphShownProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToolButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Foundation")]
pub trait IInsertionPanelImpl: Sized {
    fn GetInsertionIndexes(&mut self, position: &super::super::super::Foundation::Point, first: &mut i32, second: &mut i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Foundation")]
impl ::windows::core::RuntimeName for IInsertionPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInsertionPanel";
}
#[cfg(feature = "Foundation")]
impl IInsertionPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInsertionPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInsertionPanelVtbl {
        unsafe extern "system" fn GetInsertionIndexes<Impl: IInsertionPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: super::super::super::Foundation::Point, first: *mut i32, second: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInsertionIndexes(&*(&position as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&first), ::core::mem::transmute_copy(&second)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInsertionPanel, BASE_OFFSET>(),
            GetInsertionIndexes: GetInsertionIndexes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInsertionPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIsTextTrimmedChangedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIsTextTrimmedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIsTextTrimmedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IIsTextTrimmedChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsTextTrimmedChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsTextTrimmedChangedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IIsTextTrimmedChangedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsTextTrimmedChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemClickEventArgsImpl: Sized {
    fn ClickedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IItemClickEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemClickEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemClickEventArgsVtbl {
        unsafe extern "system" fn ClickedItem<Impl: IItemClickEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClickedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IItemClickEventArgs, BASE_OFFSET>(), ClickedItem: ClickedItem::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IItemContainerGeneratorImpl: Sized {
    fn ItemsChanged(&mut self, handler: &::core::option::Option<Primitives::ItemsChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemsChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn IndexFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<i32>;
    fn ContainerFromIndex(&mut self, index: i32) -> ::windows::core::Result<super::DependencyObject>;
    fn GetItemContainerGeneratorForPanel(&mut self, panel: &::core::option::Option<Panel>) -> ::windows::core::Result<ItemContainerGenerator>;
    fn StartAt(&mut self, position: &Primitives::GeneratorPosition, direction: Primitives::GeneratorDirection, allowstartatrealizeditem: bool) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn GenerateNext(&mut self, isnewlyrealized: &mut bool) -> ::windows::core::Result<super::DependencyObject>;
    fn PrepareItemContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn RemoveAll(&mut self) -> ::windows::core::Result<()>;
    fn Remove(&mut self, position: &Primitives::GeneratorPosition, count: i32) -> ::windows::core::Result<()>;
    fn GeneratorPositionFromIndex(&mut self, itemindex: i32) -> ::windows::core::Result<Primitives::GeneratorPosition>;
    fn IndexFromGeneratorPosition(&mut self, position: &Primitives::GeneratorPosition) -> ::windows::core::Result<i32>;
    fn Recycle(&mut self, position: &Primitives::GeneratorPosition, count: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemContainerGenerator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemContainerGenerator";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IItemContainerGeneratorVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemContainerGeneratorImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemContainerGeneratorVtbl {
        unsafe extern "system" fn ItemsChanged<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsChanged(&*(&handler as *const <Primitives::ItemsChangedEventHandler as ::windows::core::Abi>::Abi as *const <Primitives::ItemsChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemsChanged<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemFromContainer<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromContainer<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndexFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromIndex<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromIndex(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemContainerGeneratorForPanel<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, panel: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetItemContainerGeneratorForPanel(&*(&panel as *const <Panel as ::windows::core::Abi>::Abi as *const <Panel as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StartAt<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, direction: Primitives::GeneratorDirection, allowstartatrealizeditem: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartAt(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), direction, allowstartatrealizeditem).into()
        }
        unsafe extern "system" fn Stop<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn GenerateNext<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isnewlyrealized: *mut bool, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GenerateNext(::core::mem::transmute_copy(&isnewlyrealized)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrepareItemContainer<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PrepareItemContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveAll<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAll().into()
        }
        unsafe extern "system" fn Remove<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, count: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), count).into()
        }
        unsafe extern "system" fn GeneratorPositionFromIndex<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemindex: i32, result__: *mut Primitives::GeneratorPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GeneratorPositionFromIndex(itemindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromGeneratorPosition<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndexFromGeneratorPosition(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Recycle<Impl: IItemContainerGeneratorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, count: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Recycle(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), count).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemContainerGenerator, BASE_OFFSET>(),
            ItemsChanged: ItemsChanged::<Impl, IMPL_OFFSET>,
            RemoveItemsChanged: RemoveItemsChanged::<Impl, IMPL_OFFSET>,
            ItemFromContainer: ItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromItem: ContainerFromItem::<Impl, IMPL_OFFSET>,
            IndexFromContainer: IndexFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromIndex: ContainerFromIndex::<Impl, IMPL_OFFSET>,
            GetItemContainerGeneratorForPanel: GetItemContainerGeneratorForPanel::<Impl, IMPL_OFFSET>,
            StartAt: StartAt::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            GenerateNext: GenerateNext::<Impl, IMPL_OFFSET>,
            PrepareItemContainer: PrepareItemContainer::<Impl, IMPL_OFFSET>,
            RemoveAll: RemoveAll::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            GeneratorPositionFromIndex: GeneratorPositionFromIndex::<Impl, IMPL_OFFSET>,
            IndexFromGeneratorPosition: IndexFromGeneratorPosition::<Impl, IMPL_OFFSET>,
            Recycle: Recycle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemContainerGenerator as ::windows::core::Interface>::IID
    }
}
pub trait IItemContainerMappingImpl: Sized {
    fn ItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn IndexFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<i32>;
    fn ContainerFromIndex(&mut self, index: i32) -> ::windows::core::Result<super::DependencyObject>;
}
impl ::windows::core::RuntimeName for IItemContainerMapping {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemContainerMapping";
}
impl IItemContainerMappingVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemContainerMappingImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemContainerMappingVtbl {
        unsafe extern "system" fn ItemFromContainer<Impl: IItemContainerMappingImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: IItemContainerMappingImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromContainer<Impl: IItemContainerMappingImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndexFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromIndex<Impl: IItemContainerMappingImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromIndex(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemContainerMapping, BASE_OFFSET>(),
            ItemFromContainer: ItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromItem: ContainerFromItem::<Impl, IMPL_OFFSET>,
            IndexFromContainer: IndexFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromIndex: ContainerFromIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemContainerMapping as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IItemsControlImpl: Sized {
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Items(&mut self) -> ::windows::core::Result<ItemCollection>;
    fn ItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ItemTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetItemTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ItemsPanel(&mut self) -> ::windows::core::Result<ItemsPanelTemplate>;
    fn SetItemsPanel(&mut self, value: &::core::option::Option<ItemsPanelTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMemberPath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayMemberPath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn ItemContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetItemContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ItemContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetItemContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerGenerator(&mut self) -> ::windows::core::Result<ItemContainerGenerator>;
    fn ItemContainerTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetItemContainerTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn GroupStyle(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<GroupStyle>>;
    fn GroupStyleSelector(&mut self) -> ::windows::core::Result<GroupStyleSelector>;
    fn SetGroupStyleSelector(&mut self, value: &::core::option::Option<GroupStyleSelector>) -> ::windows::core::Result<()>;
    fn IsGrouping(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IItemsControlVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControlImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControlVtbl {
        unsafe extern "system" fn ItemsSource<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Items<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplate<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplateSelector<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplateSelector<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemsPanel<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPanel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsPanel<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsPanel(&*(&value as *const <ItemsPanelTemplate as ::windows::core::Abi>::Abi as *const <ItemsPanelTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMemberPath<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMemberPath<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyle<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyle<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyleSelector<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyleSelector<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerGenerator<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerGenerator() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitions<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerTransitions<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GroupStyle<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupStyleSelector<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupStyleSelector<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupStyleSelector(&*(&value as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGrouping<Impl: IItemsControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGrouping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControl, BASE_OFFSET>(),
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
            ItemTemplate: ItemTemplate::<Impl, IMPL_OFFSET>,
            SetItemTemplate: SetItemTemplate::<Impl, IMPL_OFFSET>,
            ItemTemplateSelector: ItemTemplateSelector::<Impl, IMPL_OFFSET>,
            SetItemTemplateSelector: SetItemTemplateSelector::<Impl, IMPL_OFFSET>,
            ItemsPanel: ItemsPanel::<Impl, IMPL_OFFSET>,
            SetItemsPanel: SetItemsPanel::<Impl, IMPL_OFFSET>,
            DisplayMemberPath: DisplayMemberPath::<Impl, IMPL_OFFSET>,
            SetDisplayMemberPath: SetDisplayMemberPath::<Impl, IMPL_OFFSET>,
            ItemContainerStyle: ItemContainerStyle::<Impl, IMPL_OFFSET>,
            SetItemContainerStyle: SetItemContainerStyle::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelector: ItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetItemContainerStyleSelector: SetItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            ItemContainerGenerator: ItemContainerGenerator::<Impl, IMPL_OFFSET>,
            ItemContainerTransitions: ItemContainerTransitions::<Impl, IMPL_OFFSET>,
            SetItemContainerTransitions: SetItemContainerTransitions::<Impl, IMPL_OFFSET>,
            GroupStyle: GroupStyle::<Impl, IMPL_OFFSET>,
            GroupStyleSelector: GroupStyleSelector::<Impl, IMPL_OFFSET>,
            SetGroupStyleSelector: SetGroupStyleSelector::<Impl, IMPL_OFFSET>,
            IsGrouping: IsGrouping::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControl2Impl: Sized {
    fn ItemsPanelRoot(&mut self) -> ::windows::core::Result<Panel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControl2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControl2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControl2Vtbl {
        unsafe extern "system" fn ItemsPanelRoot<Impl: IItemsControl2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPanelRoot() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControl2, BASE_OFFSET>(), ItemsPanelRoot: ItemsPanelRoot::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControl3Impl: Sized {
    fn GroupHeaderContainerFromItemContainer(&mut self, itemcontainer: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DependencyObject>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControl3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl3";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControl3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControl3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControl3Vtbl {
        unsafe extern "system" fn GroupHeaderContainerFromItemContainer<Impl: IItemsControl3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemcontainer: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderContainerFromItemContainer(&*(&itemcontainer as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControl3, BASE_OFFSET>(),
            GroupHeaderContainerFromItemContainer: GroupHeaderContainerFromItemContainer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControl3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ItemsControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControlFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IItemsControlFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlOverridesImpl: Sized {
    fn IsItemItsOwnContainerOverride(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<bool>;
    fn GetContainerForItemOverride(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn ClearContainerForItemOverride(&mut self, element: &::core::option::Option<super::DependencyObject>, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PrepareContainerForItemOverride(&mut self, element: &::core::option::Option<super::DependencyObject>, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnItemsChanged(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnItemContainerStyleChanged(&mut self, olditemcontainerstyle: &::core::option::Option<super::Style>, newitemcontainerstyle: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn OnItemContainerStyleSelectorChanged(&mut self, olditemcontainerstyleselector: &::core::option::Option<StyleSelector>, newitemcontainerstyleselector: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn OnItemTemplateChanged(&mut self, olditemtemplate: &::core::option::Option<super::DataTemplate>, newitemtemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnItemTemplateSelectorChanged(&mut self, olditemtemplateselector: &::core::option::Option<DataTemplateSelector>, newitemtemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn OnGroupStyleSelectorChanged(&mut self, oldgroupstyleselector: &::core::option::Option<GroupStyleSelector>, newgroupstyleselector: &::core::option::Option<GroupStyleSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControlOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControlOverridesVtbl {
        unsafe extern "system" fn IsItemItsOwnContainerOverride<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemItsOwnContainerOverride(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContainerForItemOverride<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetContainerForItemOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearContainerForItemOverride<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearContainerForItemOverride(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrepareContainerForItemOverride<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PrepareContainerForItemOverride(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemsChanged<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemsChanged(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemContainerStyleChanged<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemcontainerstyle: ::windows::core::RawPtr, newitemcontainerstyle: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemContainerStyleChanged(&*(&olditemcontainerstyle as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType), &*(&newitemcontainerstyle as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemContainerStyleSelectorChanged<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemcontainerstyleselector: ::windows::core::RawPtr, newitemcontainerstyleselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemContainerStyleSelectorChanged(&*(&olditemcontainerstyleselector as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType), &*(&newitemcontainerstyleselector as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemTemplateChanged<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemtemplate: ::windows::core::RawPtr, newitemtemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemTemplateChanged(&*(&olditemtemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newitemtemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemTemplateSelectorChanged<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemtemplateselector: ::windows::core::RawPtr, newitemtemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemTemplateSelectorChanged(&*(&olditemtemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newitemtemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnGroupStyleSelectorChanged<Impl: IItemsControlOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldgroupstyleselector: ::windows::core::RawPtr, newgroupstyleselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnGroupStyleSelectorChanged(&*(&oldgroupstyleselector as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType), &*(&newgroupstyleselector as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControlOverrides, BASE_OFFSET>(),
            IsItemItsOwnContainerOverride: IsItemItsOwnContainerOverride::<Impl, IMPL_OFFSET>,
            GetContainerForItemOverride: GetContainerForItemOverride::<Impl, IMPL_OFFSET>,
            ClearContainerForItemOverride: ClearContainerForItemOverride::<Impl, IMPL_OFFSET>,
            PrepareContainerForItemOverride: PrepareContainerForItemOverride::<Impl, IMPL_OFFSET>,
            OnItemsChanged: OnItemsChanged::<Impl, IMPL_OFFSET>,
            OnItemContainerStyleChanged: OnItemContainerStyleChanged::<Impl, IMPL_OFFSET>,
            OnItemContainerStyleSelectorChanged: OnItemContainerStyleSelectorChanged::<Impl, IMPL_OFFSET>,
            OnItemTemplateChanged: OnItemTemplateChanged::<Impl, IMPL_OFFSET>,
            OnItemTemplateSelectorChanged: OnItemTemplateSelectorChanged::<Impl, IMPL_OFFSET>,
            OnGroupStyleSelectorChanged: OnGroupStyleSelectorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControlOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlStaticsImpl: Sized {
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayMemberPathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetItemsOwner(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ItemsControl>;
    fn ItemsControlFromItemContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ItemsControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControlStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControlStaticsVtbl {
        unsafe extern "system" fn ItemsSourceProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateSelectorProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsPanelProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayMemberPathProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleSelectorProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitionsProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupStyleSelectorProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupingProperty<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemsOwner<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetItemsOwner(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsControlFromItemContainer<Impl: IItemsControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsControlFromItemContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControlStatics, BASE_OFFSET>(),
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateProperty: ItemTemplateProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateSelectorProperty: ItemTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemsPanelProperty: ItemsPanelProperty::<Impl, IMPL_OFFSET>,
            DisplayMemberPathProperty: DisplayMemberPathProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleProperty: ItemContainerStyleProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelectorProperty: ItemContainerStyleSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemContainerTransitionsProperty: ItemContainerTransitionsProperty::<Impl, IMPL_OFFSET>,
            GroupStyleSelectorProperty: GroupStyleSelectorProperty::<Impl, IMPL_OFFSET>,
            IsGroupingProperty: IsGroupingProperty::<Impl, IMPL_OFFSET>,
            GetItemsOwner: GetItemsOwner::<Impl, IMPL_OFFSET>,
            ItemsControlFromItemContainer: ItemsControlFromItemContainer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPanelTemplateImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPanelTemplate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPanelTemplate";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPanelTemplateVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPanelTemplateImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPanelTemplateVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPanelTemplate, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPanelTemplate as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IItemsPickedEventArgsImpl: Sized {
    fn AddedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn RemovedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsPickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPickedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IItemsPickedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPickedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPickedEventArgsVtbl {
        unsafe extern "system" fn AddedItems<Impl: IItemsPickedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedItems<Impl: IItemsPickedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPickedEventArgs, BASE_OFFSET>(),
            AddedItems: AddedItems::<Impl, IMPL_OFFSET>,
            RemovedItems: RemovedItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPickedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IItemsPresenterImpl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetHeaderTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenter";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IItemsPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenterVtbl {
        unsafe extern "system" fn Header<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTransitions<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTransitions<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IItemsPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenter, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            HeaderTransitions: HeaderTransitions::<Impl, IMPL_OFFSET>,
            SetHeaderTransitions: SetHeaderTransitions::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IItemsPresenter2Impl: Sized {
    fn Footer(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetFooter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn FooterTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetFooterTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FooterTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetFooterTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenter2";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IItemsPresenter2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenter2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenter2Vtbl {
        unsafe extern "system" fn Footer<Impl: IItemsPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Footer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooter<Impl: IItemsPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTemplate<Impl: IItemsPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTemplate<Impl: IItemsPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTransitions<Impl: IItemsPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTransitions<Impl: IItemsPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenter2, BASE_OFFSET>(),
            Footer: Footer::<Impl, IMPL_OFFSET>,
            SetFooter: SetFooter::<Impl, IMPL_OFFSET>,
            FooterTemplate: FooterTemplate::<Impl, IMPL_OFFSET>,
            SetFooterTemplate: SetFooterTemplate::<Impl, IMPL_OFFSET>,
            FooterTransitions: FooterTransitions::<Impl, IMPL_OFFSET>,
            SetFooterTransitions: SetFooterTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenterStaticsImpl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenterStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenterStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenterStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTransitionsProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenterStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            HeaderTransitionsProperty: HeaderTransitionsProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenterStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenterStatics2Impl: Sized {
    fn FooterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenterStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenterStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenterStatics2Vtbl {
        unsafe extern "system" fn FooterProperty<Impl: IItemsPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTemplateProperty<Impl: IItemsPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTransitionsProperty<Impl: IItemsPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenterStatics2, BASE_OFFSET>(),
            FooterProperty: FooterProperty::<Impl, IMPL_OFFSET>,
            FooterTemplateProperty: FooterTemplateProperty::<Impl, IMPL_OFFSET>,
            FooterTransitionsProperty: FooterTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IItemsStackPanelImpl: Sized {
    fn GroupPadding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetGroupPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn FirstCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn FirstVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn ScrollingDirection(&mut self) -> ::windows::core::Result<PanelScrollingDirection>;
    fn GroupHeaderPlacement(&mut self) -> ::windows::core::Result<Primitives::GroupHeaderPlacement>;
    fn SetGroupHeaderPlacement(&mut self, value: Primitives::GroupHeaderPlacement) -> ::windows::core::Result<()>;
    fn ItemsUpdatingScrollMode(&mut self) -> ::windows::core::Result<ItemsUpdatingScrollMode>;
    fn SetItemsUpdatingScrollMode(&mut self, value: ItemsUpdatingScrollMode) -> ::windows::core::Result<()>;
    fn CacheLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCacheLength(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanel";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IItemsStackPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanelVtbl {
        unsafe extern "system" fn GroupPadding<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupPadding<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn FirstCacheIndex<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstVisibleIndex<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastVisibleIndex<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastCacheIndex<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollingDirection<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PanelScrollingDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollingDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacement<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderPlacement<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderPlacement(value).into()
        }
        unsafe extern "system" fn ItemsUpdatingScrollMode<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ItemsUpdatingScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsUpdatingScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsUpdatingScrollMode<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ItemsUpdatingScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsUpdatingScrollMode(value).into()
        }
        unsafe extern "system" fn CacheLength<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheLength<Impl: IItemsStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCacheLength(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanel, BASE_OFFSET>(),
            GroupPadding: GroupPadding::<Impl, IMPL_OFFSET>,
            SetGroupPadding: SetGroupPadding::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            FirstCacheIndex: FirstCacheIndex::<Impl, IMPL_OFFSET>,
            FirstVisibleIndex: FirstVisibleIndex::<Impl, IMPL_OFFSET>,
            LastVisibleIndex: LastVisibleIndex::<Impl, IMPL_OFFSET>,
            LastCacheIndex: LastCacheIndex::<Impl, IMPL_OFFSET>,
            ScrollingDirection: ScrollingDirection::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacement: GroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            SetGroupHeaderPlacement: SetGroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            ItemsUpdatingScrollMode: ItemsUpdatingScrollMode::<Impl, IMPL_OFFSET>,
            SetItemsUpdatingScrollMode: SetItemsUpdatingScrollMode::<Impl, IMPL_OFFSET>,
            CacheLength: CacheLength::<Impl, IMPL_OFFSET>,
            SetCacheLength: SetCacheLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanel2Impl: Sized {
    fn AreStickyGroupHeadersEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreStickyGroupHeadersEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanel2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanel2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanel2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabled<Impl: IItemsStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreStickyGroupHeadersEnabled<Impl: IItemsStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreStickyGroupHeadersEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanel2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabled: AreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
            SetAreStickyGroupHeadersEnabled: SetAreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanelStaticsImpl: Sized {
    fn GroupPaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupHeaderPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CacheLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanelStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanelStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanelStaticsVtbl {
        unsafe extern "system" fn GroupPaddingProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacementProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CacheLengthProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanelStatics, BASE_OFFSET>(),
            GroupPaddingProperty: GroupPaddingProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacementProperty: GroupHeaderPlacementProperty::<Impl, IMPL_OFFSET>,
            CacheLengthProperty: CacheLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanelStatics2Impl: Sized {
    fn AreStickyGroupHeadersEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanelStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanelStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanelStatics2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabledProperty<Impl: IItemsStackPanelStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanelStatics2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabledProperty: AreStickyGroupHeadersEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanelStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IItemsWrapGridImpl: Sized {
    fn GroupPadding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetGroupPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn ItemWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FirstCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn FirstVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn ScrollingDirection(&mut self) -> ::windows::core::Result<PanelScrollingDirection>;
    fn GroupHeaderPlacement(&mut self) -> ::windows::core::Result<Primitives::GroupHeaderPlacement>;
    fn SetGroupHeaderPlacement(&mut self, value: Primitives::GroupHeaderPlacement) -> ::windows::core::Result<()>;
    fn CacheLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCacheLength(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGrid";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IItemsWrapGridVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGridImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGridVtbl {
        unsafe extern "system" fn GroupPadding<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupPadding<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        unsafe extern "system" fn ItemWidth<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn ItemHeight<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn FirstCacheIndex<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstVisibleIndex<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastVisibleIndex<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastCacheIndex<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollingDirection<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PanelScrollingDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollingDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacement<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderPlacement<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderPlacement(value).into()
        }
        unsafe extern "system" fn CacheLength<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheLength<Impl: IItemsWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCacheLength(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGrid, BASE_OFFSET>(),
            GroupPadding: GroupPadding::<Impl, IMPL_OFFSET>,
            SetGroupPadding: SetGroupPadding::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumns: MaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            SetMaximumRowsOrColumns: SetMaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            ItemWidth: ItemWidth::<Impl, IMPL_OFFSET>,
            SetItemWidth: SetItemWidth::<Impl, IMPL_OFFSET>,
            ItemHeight: ItemHeight::<Impl, IMPL_OFFSET>,
            SetItemHeight: SetItemHeight::<Impl, IMPL_OFFSET>,
            FirstCacheIndex: FirstCacheIndex::<Impl, IMPL_OFFSET>,
            FirstVisibleIndex: FirstVisibleIndex::<Impl, IMPL_OFFSET>,
            LastVisibleIndex: LastVisibleIndex::<Impl, IMPL_OFFSET>,
            LastCacheIndex: LastCacheIndex::<Impl, IMPL_OFFSET>,
            ScrollingDirection: ScrollingDirection::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacement: GroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            SetGroupHeaderPlacement: SetGroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            CacheLength: CacheLength::<Impl, IMPL_OFFSET>,
            SetCacheLength: SetCacheLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGrid2Impl: Sized {
    fn AreStickyGroupHeadersEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreStickyGroupHeadersEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGrid2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGrid2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGrid2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGrid2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGrid2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabled<Impl: IItemsWrapGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreStickyGroupHeadersEnabled<Impl: IItemsWrapGrid2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreStickyGroupHeadersEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGrid2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabled: AreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
            SetAreStickyGroupHeadersEnabled: SetAreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGrid2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGridStaticsImpl: Sized {
    fn GroupPaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupHeaderPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CacheLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGridStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGridStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGridStaticsVtbl {
        unsafe extern "system" fn GroupPaddingProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemWidthProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemHeightProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacementProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CacheLengthProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGridStatics, BASE_OFFSET>(),
            GroupPaddingProperty: GroupPaddingProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumnsProperty: MaximumRowsOrColumnsProperty::<Impl, IMPL_OFFSET>,
            ItemWidthProperty: ItemWidthProperty::<Impl, IMPL_OFFSET>,
            ItemHeightProperty: ItemHeightProperty::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacementProperty: GroupHeaderPlacementProperty::<Impl, IMPL_OFFSET>,
            CacheLengthProperty: CacheLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGridStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGridStatics2Impl: Sized {
    fn AreStickyGroupHeadersEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGridStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGridStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGridStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGridStatics2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabledProperty<Impl: IItemsWrapGridStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGridStatics2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabledProperty: AreStickyGroupHeadersEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGridStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IListBoxImpl: Sized {
    fn SelectedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<SelectionMode>;
    fn SetSelectionMode(&mut self, value: SelectionMode) -> ::windows::core::Result<()>;
    fn ScrollIntoView(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBox";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IListBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxVtbl {
        unsafe extern "system" fn SelectedItems<Impl: IListBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: IListBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn ScrollIntoView<Impl: IListBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollIntoView(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IListBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBox, BASE_OFFSET>(),
            SelectedItems: SelectedItems::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            ScrollIntoView: ScrollIntoView::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBox2Impl: Sized {
    fn SingleSelectionFollowsFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetSingleSelectionFollowsFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IListBox2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBox2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBox2Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: IListBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSingleSelectionFollowsFocus<Impl: IListBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSingleSelectionFollowsFocus(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBox2, BASE_OFFSET>(),
            SingleSelectionFollowsFocus: SingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            SetSingleSelectionFollowsFocus: SetSingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListBoxFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxItemVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListBoxItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListBoxItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxStaticsImpl: Sized {
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxStaticsVtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: IListBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxStatics, BASE_OFFSET>(),
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxStatics2Impl: Sized {
    fn SingleSelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxStatics2Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: IListBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxStatics2, BASE_OFFSET>(),
            SingleSelectionFollowsFocusProperty: SingleSelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IListPickerFlyoutImpl: Sized {
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMemberPath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayMemberPath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<ListPickerFlyoutSelectionMode>;
    fn SetSelectionMode(&mut self, value: ListPickerFlyoutSelectionMode) -> ::windows::core::Result<()>;
    fn SelectedIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectedIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectedValue(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedValue(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectedValuePath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSelectedValuePath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn ItemsPicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemsPicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListPickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IListPickerFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListPickerFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListPickerFlyoutVtbl {
        unsafe extern "system" fn ItemsSource<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplate<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMemberPath<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMemberPath<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionMode<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ListPickerFlyoutSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ListPickerFlyoutSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn SelectedIndex<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedIndex<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedIndex(value).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedValue<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedValue<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedValue(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedValuePath<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValuePath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedValuePath<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedValuePath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedItems<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsPicked<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemsPicked<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemsPicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IListPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListPickerFlyout, BASE_OFFSET>(),
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
            ItemTemplate: ItemTemplate::<Impl, IMPL_OFFSET>,
            SetItemTemplate: SetItemTemplate::<Impl, IMPL_OFFSET>,
            DisplayMemberPath: DisplayMemberPath::<Impl, IMPL_OFFSET>,
            SetDisplayMemberPath: SetDisplayMemberPath::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            SelectedIndex: SelectedIndex::<Impl, IMPL_OFFSET>,
            SetSelectedIndex: SetSelectedIndex::<Impl, IMPL_OFFSET>,
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            SetSelectedItem: SetSelectedItem::<Impl, IMPL_OFFSET>,
            SelectedValue: SelectedValue::<Impl, IMPL_OFFSET>,
            SetSelectedValue: SetSelectedValue::<Impl, IMPL_OFFSET>,
            SelectedValuePath: SelectedValuePath::<Impl, IMPL_OFFSET>,
            SetSelectedValuePath: SetSelectedValuePath::<Impl, IMPL_OFFSET>,
            SelectedItems: SelectedItems::<Impl, IMPL_OFFSET>,
            ItemsPicked: ItemsPicked::<Impl, IMPL_OFFSET>,
            RemoveItemsPicked: RemoveItemsPicked::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListPickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListPickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListPickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IListPickerFlyoutPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListPickerFlyoutPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListPickerFlyoutPresenterVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListPickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListPickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListPickerFlyoutStaticsImpl: Sized {
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayMemberPathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedValuePathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListPickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListPickerFlyoutStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListPickerFlyoutStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListPickerFlyoutStaticsVtbl {
        unsafe extern "system" fn ItemsSourceProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayMemberPathProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionModeProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedIndexProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedValueProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedValuePathProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValuePathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListPickerFlyoutStatics, BASE_OFFSET>(),
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateProperty: ItemTemplateProperty::<Impl, IMPL_OFFSET>,
            DisplayMemberPathProperty: DisplayMemberPathProperty::<Impl, IMPL_OFFSET>,
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
            SelectedIndexProperty: SelectedIndexProperty::<Impl, IMPL_OFFSET>,
            SelectedItemProperty: SelectedItemProperty::<Impl, IMPL_OFFSET>,
            SelectedValueProperty: SelectedValueProperty::<Impl, IMPL_OFFSET>,
            SelectedValuePathProperty: SelectedValuePathProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListPickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListView";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListView, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IListViewBaseImpl: Sized {
    fn SelectedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<ListViewSelectionMode>;
    fn SetSelectionMode(&mut self, value: ListViewSelectionMode) -> ::windows::core::Result<()>;
    fn IsSwipeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSwipeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanDragItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanDragItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanReorderItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanReorderItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsItemClickEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsItemClickEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DataFetchSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetDataFetchSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IncrementalLoadingThreshold(&mut self) -> ::windows::core::Result<f64>;
    fn SetIncrementalLoadingThreshold(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IncrementalLoadingTrigger(&mut self) -> ::windows::core::Result<IncrementalLoadingTrigger>;
    fn SetIncrementalLoadingTrigger(&mut self, value: IncrementalLoadingTrigger) -> ::windows::core::Result<()>;
    fn ItemClick(&mut self, handler: &::core::option::Option<ItemClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DragItemsStarting(&mut self, handler: &::core::option::Option<DragItemsStartingEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollIntoView(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn LoadMoreItemsAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::Data::LoadMoreItemsResult>>;
    fn ScrollIntoViewWithAlignment(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, alignment: ScrollIntoViewAlignment) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetHeaderTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IListViewBaseVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseVtbl {
        unsafe extern "system" fn SelectedItems<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ListViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ListViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn IsSwipeEnabled<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwipeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSwipeEnabled<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSwipeEnabled(value).into()
        }
        unsafe extern "system" fn CanDragItems<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanDragItems<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanDragItems(value).into()
        }
        unsafe extern "system" fn CanReorderItems<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanReorderItems<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanReorderItems(value).into()
        }
        unsafe extern "system" fn IsItemClickEnabled<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemClickEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsItemClickEnabled<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsItemClickEnabled(value).into()
        }
        unsafe extern "system" fn DataFetchSize<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataFetchSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDataFetchSize<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDataFetchSize(value).into()
        }
        unsafe extern "system" fn IncrementalLoadingThreshold<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingThreshold() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIncrementalLoadingThreshold<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIncrementalLoadingThreshold(value).into()
        }
        unsafe extern "system" fn IncrementalLoadingTrigger<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut IncrementalLoadingTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingTrigger() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIncrementalLoadingTrigger<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: IncrementalLoadingTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIncrementalLoadingTrigger(value).into()
        }
        unsafe extern "system" fn ItemClick<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemClick(&*(&handler as *const <ItemClickEventHandler as ::windows::core::Abi>::Abi as *const <ItemClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemClick<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsStarting<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsStarting(&*(&handler as *const <DragItemsStartingEventHandler as ::windows::core::Abi>::Abi as *const <DragItemsStartingEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsStarting<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollIntoView<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollIntoView(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn LoadMoreItemsAsync<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LoadMoreItemsAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollIntoViewWithAlignment<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, alignment: ScrollIntoViewAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollIntoViewWithAlignment(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), alignment).into()
        }
        unsafe extern "system" fn Header<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTransitions<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTransitions<Impl: IListViewBaseImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase, BASE_OFFSET>(),
            SelectedItems: SelectedItems::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            IsSwipeEnabled: IsSwipeEnabled::<Impl, IMPL_OFFSET>,
            SetIsSwipeEnabled: SetIsSwipeEnabled::<Impl, IMPL_OFFSET>,
            CanDragItems: CanDragItems::<Impl, IMPL_OFFSET>,
            SetCanDragItems: SetCanDragItems::<Impl, IMPL_OFFSET>,
            CanReorderItems: CanReorderItems::<Impl, IMPL_OFFSET>,
            SetCanReorderItems: SetCanReorderItems::<Impl, IMPL_OFFSET>,
            IsItemClickEnabled: IsItemClickEnabled::<Impl, IMPL_OFFSET>,
            SetIsItemClickEnabled: SetIsItemClickEnabled::<Impl, IMPL_OFFSET>,
            DataFetchSize: DataFetchSize::<Impl, IMPL_OFFSET>,
            SetDataFetchSize: SetDataFetchSize::<Impl, IMPL_OFFSET>,
            IncrementalLoadingThreshold: IncrementalLoadingThreshold::<Impl, IMPL_OFFSET>,
            SetIncrementalLoadingThreshold: SetIncrementalLoadingThreshold::<Impl, IMPL_OFFSET>,
            IncrementalLoadingTrigger: IncrementalLoadingTrigger::<Impl, IMPL_OFFSET>,
            SetIncrementalLoadingTrigger: SetIncrementalLoadingTrigger::<Impl, IMPL_OFFSET>,
            ItemClick: ItemClick::<Impl, IMPL_OFFSET>,
            RemoveItemClick: RemoveItemClick::<Impl, IMPL_OFFSET>,
            DragItemsStarting: DragItemsStarting::<Impl, IMPL_OFFSET>,
            RemoveDragItemsStarting: RemoveDragItemsStarting::<Impl, IMPL_OFFSET>,
            ScrollIntoView: ScrollIntoView::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            LoadMoreItemsAsync: LoadMoreItemsAsync::<Impl, IMPL_OFFSET>,
            ScrollIntoViewWithAlignment: ScrollIntoViewWithAlignment::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            HeaderTransitions: HeaderTransitions::<Impl, IMPL_OFFSET>,
            SetHeaderTransitions: SetHeaderTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IListViewBase2Impl: Sized {
    fn ShowsScrollingPlaceholders(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowsScrollingPlaceholders(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ContainerContentChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContainerContentChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDesiredContainerUpdateDuration(&mut self, duration: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn Footer(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetFooter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn FooterTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetFooterTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FooterTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetFooterTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IListViewBase2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase2Vtbl {
        unsafe extern "system" fn ShowsScrollingPlaceholders<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowsScrollingPlaceholders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowsScrollingPlaceholders<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowsScrollingPlaceholders(value).into()
        }
        unsafe extern "system" fn ContainerContentChanging<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerContentChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContainerContentChanging<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContainerContentChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDesiredContainerUpdateDuration<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, duration: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDesiredContainerUpdateDuration(&*(&duration as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Footer<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Footer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooter<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTemplate<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTemplate<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTransitions<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTransitions<Impl: IListViewBase2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase2, BASE_OFFSET>(),
            ShowsScrollingPlaceholders: ShowsScrollingPlaceholders::<Impl, IMPL_OFFSET>,
            SetShowsScrollingPlaceholders: SetShowsScrollingPlaceholders::<Impl, IMPL_OFFSET>,
            ContainerContentChanging: ContainerContentChanging::<Impl, IMPL_OFFSET>,
            RemoveContainerContentChanging: RemoveContainerContentChanging::<Impl, IMPL_OFFSET>,
            SetDesiredContainerUpdateDuration: SetDesiredContainerUpdateDuration::<Impl, IMPL_OFFSET>,
            Footer: Footer::<Impl, IMPL_OFFSET>,
            SetFooter: SetFooter::<Impl, IMPL_OFFSET>,
            FooterTemplate: FooterTemplate::<Impl, IMPL_OFFSET>,
            SetFooterTemplate: SetFooterTemplate::<Impl, IMPL_OFFSET>,
            FooterTransitions: FooterTransitions::<Impl, IMPL_OFFSET>,
            SetFooterTransitions: SetFooterTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase3Impl: Sized {
    fn ReorderMode(&mut self) -> ::windows::core::Result<ListViewReorderMode>;
    fn SetReorderMode(&mut self, value: ListViewReorderMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase3";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase3Vtbl {
        unsafe extern "system" fn ReorderMode<Impl: IListViewBase3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ListViewReorderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReorderMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReorderMode<Impl: IListViewBase3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ListViewReorderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetReorderMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase3, BASE_OFFSET>(),
            ReorderMode: ReorderMode::<Impl, IMPL_OFFSET>,
            SetReorderMode: SetReorderMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
pub trait IListViewBase4Impl: Sized {
    fn SelectedRanges(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::Data::ItemIndexRange>>;
    fn IsMultiSelectCheckBoxEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsMultiSelectCheckBoxEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DragItemsCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChoosingItemContainer(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChoosingItemContainer(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChoosingGroupHeaderContainer(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChoosingGroupHeaderContainer(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectRange(&mut self, itemindexrange: &::core::option::Option<super::Data::ItemIndexRange>) -> ::windows::core::Result<()>;
    fn DeselectRange(&mut self, itemindexrange: &::core::option::Option<super::Data::ItemIndexRange>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl IListViewBase4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase4Vtbl {
        unsafe extern "system" fn SelectedRanges<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedRanges() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMultiSelectCheckBoxEnabled<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMultiSelectCheckBoxEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMultiSelectCheckBoxEnabled<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsMultiSelectCheckBoxEnabled(value).into()
        }
        unsafe extern "system" fn DragItemsCompleted<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsCompleted<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChoosingItemContainer<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChoosingItemContainer(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChoosingItemContainer<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveChoosingItemContainer(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChoosingGroupHeaderContainer<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChoosingGroupHeaderContainer(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChoosingGroupHeaderContainer<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveChoosingGroupHeaderContainer(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectRange<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemindexrange: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectRange(&*(&itemindexrange as *const <super::Data::ItemIndexRange as ::windows::core::Abi>::Abi as *const <super::Data::ItemIndexRange as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DeselectRange<Impl: IListViewBase4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemindexrange: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeselectRange(&*(&itemindexrange as *const <super::Data::ItemIndexRange as ::windows::core::Abi>::Abi as *const <super::Data::ItemIndexRange as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase4, BASE_OFFSET>(),
            SelectedRanges: SelectedRanges::<Impl, IMPL_OFFSET>,
            IsMultiSelectCheckBoxEnabled: IsMultiSelectCheckBoxEnabled::<Impl, IMPL_OFFSET>,
            SetIsMultiSelectCheckBoxEnabled: SetIsMultiSelectCheckBoxEnabled::<Impl, IMPL_OFFSET>,
            DragItemsCompleted: DragItemsCompleted::<Impl, IMPL_OFFSET>,
            RemoveDragItemsCompleted: RemoveDragItemsCompleted::<Impl, IMPL_OFFSET>,
            ChoosingItemContainer: ChoosingItemContainer::<Impl, IMPL_OFFSET>,
            RemoveChoosingItemContainer: RemoveChoosingItemContainer::<Impl, IMPL_OFFSET>,
            ChoosingGroupHeaderContainer: ChoosingGroupHeaderContainer::<Impl, IMPL_OFFSET>,
            RemoveChoosingGroupHeaderContainer: RemoveChoosingGroupHeaderContainer::<Impl, IMPL_OFFSET>,
            SelectRange: SelectRange::<Impl, IMPL_OFFSET>,
            DeselectRange: DeselectRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase5Impl: Sized {
    fn SingleSelectionFollowsFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetSingleSelectionFollowsFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsDragSource(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase5";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase5Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: IListViewBase5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSingleSelectionFollowsFocus<Impl: IListViewBase5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSingleSelectionFollowsFocus(value).into()
        }
        unsafe extern "system" fn IsDragSource<Impl: IListViewBase5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDragSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase5, BASE_OFFSET>(),
            SingleSelectionFollowsFocus: SingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            SetSingleSelectionFollowsFocus: SetSingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            IsDragSource: IsDragSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IListViewBase6Impl: Sized {
    fn TryStartConnectedAnimationAsync(&mut self, animation: &::core::option::Option<super::Media::Animation::ConnectedAnimation>, item: &::core::option::Option<::windows::core::IInspectable>, elementname: &::windows::core::HSTRING) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<bool>>;
    fn PrepareConnectedAnimation(&mut self, key: &::windows::core::HSTRING, item: &::core::option::Option<::windows::core::IInspectable>, elementname: &::windows::core::HSTRING) -> ::windows::core::Result<super::Media::Animation::ConnectedAnimation>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase6";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IListViewBase6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase6Vtbl {
        unsafe extern "system" fn TryStartConnectedAnimationAsync<Impl: IListViewBase6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, animation: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void, elementname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TryStartConnectedAnimationAsync(
                &*(&animation as *const <super::Media::Animation::ConnectedAnimation as ::windows::core::Abi>::Abi as *const <super::Media::Animation::ConnectedAnimation as ::windows::core::DefaultType>::DefaultType),
                &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&elementname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrepareConnectedAnimation<Impl: IListViewBase6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, key: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, item: *mut ::core::ffi::c_void, elementname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrepareConnectedAnimation(
                &*(&key as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
                &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&elementname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase6, BASE_OFFSET>(),
            TryStartConnectedAnimationAsync: TryStartConnectedAnimationAsync::<Impl, IMPL_OFFSET>,
            PrepareConnectedAnimation: PrepareConnectedAnimation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewBase>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewBaseFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseHeaderItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseHeaderItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseHeaderItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseHeaderItemVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseHeaderItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseHeaderItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseHeaderItemFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseHeaderItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseHeaderItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseHeaderItemFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseHeaderItemFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseHeaderItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStaticsImpl: Sized {
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSwipeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanDragItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanReorderItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsItemClickEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DataFetchSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IncrementalLoadingThresholdProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IncrementalLoadingTriggerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SemanticZoomOwnerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsActiveViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStaticsVtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSwipeEnabledProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwipeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanDragItemsProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanReorderItemsProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsItemClickEnabledProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemClickEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DataFetchSizeProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataFetchSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IncrementalLoadingThresholdProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingThresholdProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IncrementalLoadingTriggerProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingTriggerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SemanticZoomOwnerProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwnerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActiveViewProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTransitionsProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics, BASE_OFFSET>(),
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
            IsSwipeEnabledProperty: IsSwipeEnabledProperty::<Impl, IMPL_OFFSET>,
            CanDragItemsProperty: CanDragItemsProperty::<Impl, IMPL_OFFSET>,
            CanReorderItemsProperty: CanReorderItemsProperty::<Impl, IMPL_OFFSET>,
            IsItemClickEnabledProperty: IsItemClickEnabledProperty::<Impl, IMPL_OFFSET>,
            DataFetchSizeProperty: DataFetchSizeProperty::<Impl, IMPL_OFFSET>,
            IncrementalLoadingThresholdProperty: IncrementalLoadingThresholdProperty::<Impl, IMPL_OFFSET>,
            IncrementalLoadingTriggerProperty: IncrementalLoadingTriggerProperty::<Impl, IMPL_OFFSET>,
            SemanticZoomOwnerProperty: SemanticZoomOwnerProperty::<Impl, IMPL_OFFSET>,
            IsActiveViewProperty: IsActiveViewProperty::<Impl, IMPL_OFFSET>,
            IsZoomedInViewProperty: IsZoomedInViewProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            HeaderTransitionsProperty: HeaderTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics2Impl: Sized {
    fn ShowsScrollingPlaceholdersProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics2Vtbl {
        unsafe extern "system" fn ShowsScrollingPlaceholdersProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowsScrollingPlaceholdersProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTemplateProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTransitionsProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics2, BASE_OFFSET>(),
            ShowsScrollingPlaceholdersProperty: ShowsScrollingPlaceholdersProperty::<Impl, IMPL_OFFSET>,
            FooterProperty: FooterProperty::<Impl, IMPL_OFFSET>,
            FooterTemplateProperty: FooterTemplateProperty::<Impl, IMPL_OFFSET>,
            FooterTransitionsProperty: FooterTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics3Impl: Sized {
    fn ReorderModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics3Vtbl {
        unsafe extern "system" fn ReorderModeProperty<Impl: IListViewBaseStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReorderModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics3, BASE_OFFSET>(),
            ReorderModeProperty: ReorderModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics4Impl: Sized {
    fn IsMultiSelectCheckBoxEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics4Vtbl {
        unsafe extern "system" fn IsMultiSelectCheckBoxEnabledProperty<Impl: IListViewBaseStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMultiSelectCheckBoxEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics4, BASE_OFFSET>(),
            IsMultiSelectCheckBoxEnabledProperty: IsMultiSelectCheckBoxEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics5Impl: Sized {
    fn SingleSelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics5Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: IListViewBaseStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics5, BASE_OFFSET>(),
            SingleSelectionFollowsFocusProperty: SingleSelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewHeaderItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewHeaderItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewHeaderItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewHeaderItemVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewHeaderItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewHeaderItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewHeaderItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewHeaderItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewHeaderItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewHeaderItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewHeaderItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewHeaderItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewHeaderItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewHeaderItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IListViewItemImpl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ListViewItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewItem";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IListViewItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewItemVtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IListViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewItem, BASE_OFFSET>(), TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewPersistenceHelperImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewPersistenceHelper {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewPersistenceHelper";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewPersistenceHelperVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewPersistenceHelperImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewPersistenceHelperVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewPersistenceHelper, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewPersistenceHelper as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IListViewPersistenceHelperStaticsImpl: Sized {
    fn GetRelativeScrollPosition(&mut self, listviewbase: &::core::option::Option<ListViewBase>, itemtokeyhandler: &::core::option::Option<ListViewItemToKeyHandler>) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetRelativeScrollPositionAsync(&mut self, listviewbase: &::core::option::Option<ListViewBase>, relativescrollposition: &::windows::core::HSTRING, keytoitemhandler: &::core::option::Option<ListViewKeyToItemHandler>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewPersistenceHelperStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewPersistenceHelperStatics";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IListViewPersistenceHelperStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewPersistenceHelperStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewPersistenceHelperStaticsVtbl {
        unsafe extern "system" fn GetRelativeScrollPosition<Impl: IListViewPersistenceHelperStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, listviewbase: ::windows::core::RawPtr, itemtokeyhandler: ::windows::core::RawPtr, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRelativeScrollPosition(&*(&listviewbase as *const <ListViewBase as ::windows::core::Abi>::Abi as *const <ListViewBase as ::windows::core::DefaultType>::DefaultType), &*(&itemtokeyhandler as *const <ListViewItemToKeyHandler as ::windows::core::Abi>::Abi as *const <ListViewItemToKeyHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRelativeScrollPositionAsync<Impl: IListViewPersistenceHelperStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, listviewbase: ::windows::core::RawPtr, relativescrollposition: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, keytoitemhandler: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetRelativeScrollPositionAsync(
                &*(&listviewbase as *const <ListViewBase as ::windows::core::Abi>::Abi as *const <ListViewBase as ::windows::core::DefaultType>::DefaultType),
                &*(&relativescrollposition as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
                &*(&keytoitemhandler as *const <ListViewKeyToItemHandler as ::windows::core::Abi>::Abi as *const <ListViewKeyToItemHandler as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewPersistenceHelperStatics, BASE_OFFSET>(),
            GetRelativeScrollPosition: GetRelativeScrollPosition::<Impl, IMPL_OFFSET>,
            SetRelativeScrollPositionAsync: SetRelativeScrollPositionAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewPersistenceHelperStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Media_PlayTo", feature = "Media_Protection", feature = "Storage_Streams", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaElementImpl: Sized {
    fn PosterSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPosterSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn IsMuted(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsMuted(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsAudioOnly(&mut self) -> ::windows::core::Result<bool>;
    fn AutoPlay(&mut self) -> ::windows::core::Result<bool>;
    fn SetAutoPlay(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Volume(&mut self) -> ::windows::core::Result<f64>;
    fn SetVolume(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Balance(&mut self) -> ::windows::core::Result<f64>;
    fn SetBalance(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn NaturalVideoHeight(&mut self) -> ::windows::core::Result<i32>;
    fn NaturalVideoWidth(&mut self) -> ::windows::core::Result<i32>;
    fn NaturalDuration(&mut self) -> ::windows::core::Result<super::Duration>;
    fn Position(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetPosition(&mut self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn DownloadProgress(&mut self) -> ::windows::core::Result<f64>;
    fn BufferingProgress(&mut self) -> ::windows::core::Result<f64>;
    fn DownloadProgressOffset(&mut self) -> ::windows::core::Result<f64>;
    fn CurrentState(&mut self) -> ::windows::core::Result<super::Media::MediaElementState>;
    fn Markers(&mut self) -> ::windows::core::Result<super::Media::TimelineMarkerCollection>;
    fn CanSeek(&mut self) -> ::windows::core::Result<bool>;
    fn CanPause(&mut self) -> ::windows::core::Result<bool>;
    fn AudioStreamCount(&mut self) -> ::windows::core::Result<i32>;
    fn AudioStreamIndex(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<i32>>;
    fn SetAudioStreamIndex(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<()>;
    fn PlaybackRate(&mut self) -> ::windows::core::Result<f64>;
    fn SetPlaybackRate(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsLooping(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsLooping(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PlayToSource(&mut self) -> ::windows::core::Result<super::super::super::Media::PlayTo::PlayToSource>;
    fn DefaultPlaybackRate(&mut self) -> ::windows::core::Result<f64>;
    fn SetDefaultPlaybackRate(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn AspectRatioWidth(&mut self) -> ::windows::core::Result<i32>;
    fn AspectRatioHeight(&mut self) -> ::windows::core::Result<i32>;
    fn RealTimePlayback(&mut self) -> ::windows::core::Result<bool>;
    fn SetRealTimePlayback(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AudioCategory(&mut self) -> ::windows::core::Result<super::Media::AudioCategory>;
    fn SetAudioCategory(&mut self, value: super::Media::AudioCategory) -> ::windows::core::Result<()>;
    fn AudioDeviceType(&mut self) -> ::windows::core::Result<super::Media::AudioDeviceType>;
    fn SetAudioDeviceType(&mut self, value: super::Media::AudioDeviceType) -> ::windows::core::Result<()>;
    fn ProtectionManager(&mut self) -> ::windows::core::Result<super::super::super::Media::Protection::MediaProtectionManager>;
    fn SetProtectionManager(&mut self, value: &::core::option::Option<super::super::super::Media::Protection::MediaProtectionManager>) -> ::windows::core::Result<()>;
    fn Stereo3DVideoPackingMode(&mut self) -> ::windows::core::Result<super::Media::Stereo3DVideoPackingMode>;
    fn SetStereo3DVideoPackingMode(&mut self, value: super::Media::Stereo3DVideoPackingMode) -> ::windows::core::Result<()>;
    fn Stereo3DVideoRenderMode(&mut self) -> ::windows::core::Result<super::Media::Stereo3DVideoRenderMode>;
    fn SetStereo3DVideoRenderMode(&mut self, value: super::Media::Stereo3DVideoRenderMode) -> ::windows::core::Result<()>;
    fn IsStereo3DVideo(&mut self) -> ::windows::core::Result<bool>;
    fn MediaOpened(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MediaEnded(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaEnded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MediaFailed(&mut self, handler: &::core::option::Option<super::ExceptionRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DownloadProgressChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDownloadProgressChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn BufferingProgressChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBufferingProgressChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CurrentStateChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCurrentStateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MarkerReached(&mut self, handler: &::core::option::Option<super::Media::TimelineMarkerRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMarkerReached(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RateChanged(&mut self, handler: &::core::option::Option<super::Media::RateChangedRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn VolumeChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveVolumeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SeekCompleted(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSeekCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Play(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn CanPlayType(&mut self, r#type: &::windows::core::HSTRING) -> ::windows::core::Result<super::Media::MediaCanPlayResponse>;
    fn SetSource(&mut self, stream: &::core::option::Option<super::super::super::Storage::Streams::IRandomAccessStream>, mimetype: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn GetAudioStreamLanguage(&mut self, index: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn AddAudioEffect(&mut self, effectid: &::windows::core::HSTRING, effectoptional: bool, effectconfiguration: &::core::option::Option<super::super::super::Foundation::Collections::IPropertySet>) -> ::windows::core::Result<()>;
    fn AddVideoEffect(&mut self, effectid: &::windows::core::HSTRING, effectoptional: bool, effectconfiguration: &::core::option::Option<super::super::super::Foundation::Collections::IPropertySet>) -> ::windows::core::Result<()>;
    fn RemoveAllEffects(&mut self) -> ::windows::core::Result<()>;
    fn ActualStereo3DVideoPackingMode(&mut self) -> ::windows::core::Result<super::Media::Stereo3DVideoPackingMode>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Media_PlayTo", feature = "Media_Protection", feature = "Storage_Streams", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Media_PlayTo", feature = "Media_Protection", feature = "Storage_Streams", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaElementVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElementImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElementVtbl {
        unsafe extern "system" fn PosterSource<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosterSource<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPosterSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Source<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsMuted<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMuted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMuted<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsMuted(value).into()
        }
        unsafe extern "system" fn IsAudioOnly<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAudioOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlay<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoPlay(value).into()
        }
        unsafe extern "system" fn Volume<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Volume() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVolume<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVolume(value).into()
        }
        unsafe extern "system" fn Balance<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Balance() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBalance(value).into()
        }
        unsafe extern "system" fn NaturalVideoHeight<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoWidth<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalDuration<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Duration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Position<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Position() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosition<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPosition(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DownloadProgress<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgress() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingProgress<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BufferingProgress() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressOffset<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentState<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::MediaElementState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Markers<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Markers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeek<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanSeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanPause<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamCount<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamIndex<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioStreamIndex<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioStreamIndex(&*(&value as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaybackRate<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaybackRate<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaybackRate(value).into()
        }
        unsafe extern "system" fn IsLooping<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLooping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsLooping<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsLooping(value).into()
        }
        unsafe extern "system" fn PlayToSource<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPlaybackRate<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultPlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultPlaybackRate<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultPlaybackRate(value).into()
        }
        unsafe extern "system" fn AspectRatioWidth<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioHeight<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RealTimePlayback<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RealTimePlayback() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRealTimePlayback<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRealTimePlayback(value).into()
        }
        unsafe extern "system" fn AudioCategory<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::AudioCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioCategory() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioCategory<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::AudioCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioCategory(value).into()
        }
        unsafe extern "system" fn AudioDeviceType<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::AudioDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioDeviceType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioDeviceType<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::AudioDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioDeviceType(value).into()
        }
        unsafe extern "system" fn ProtectionManager<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProtectionManager() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProtectionManager<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProtectionManager(&*(&value as *const <super::super::super::Media::Protection::MediaProtectionManager as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Protection::MediaProtectionManager as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stereo3DVideoPackingMode<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoPackingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DVideoPackingMode<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStereo3DVideoPackingMode(value).into()
        }
        unsafe extern "system" fn Stereo3DVideoRenderMode<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoRenderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoRenderMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DVideoRenderMode<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stereo3DVideoRenderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStereo3DVideoRenderMode(value).into()
        }
        unsafe extern "system" fn IsStereo3DVideo<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStereo3DVideo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaOpened<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaOpened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaOpened<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMediaOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MediaEnded<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaEnded(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaEnded<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMediaEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MediaFailed<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaFailed(&*(&handler as *const <super::ExceptionRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::ExceptionRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaFailed<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMediaFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DownloadProgressChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDownloadProgressChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDownloadProgressChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BufferingProgressChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BufferingProgressChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBufferingProgressChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBufferingProgressChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CurrentStateChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentStateChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCurrentStateChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCurrentStateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MarkerReached<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MarkerReached(&*(&handler as *const <super::Media::TimelineMarkerRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::Media::TimelineMarkerRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMarkerReached<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMarkerReached(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RateChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RateChanged(&*(&handler as *const <super::Media::RateChangedRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::Media::RateChangedRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRateChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VolumeChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VolumeChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveVolumeChanged<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveVolumeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SeekCompleted<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SeekCompleted(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSeekCompleted<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSeekCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stop<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Play<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Play().into()
        }
        unsafe extern "system" fn Pause<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn CanPlayType<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut super::Media::MediaCanPlayResponse) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPlayType(&*(&r#type as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stream: ::windows::core::RawPtr, mimetype: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&stream as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::Abi>::Abi as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::DefaultType>::DefaultType), &*(&mimetype as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetAudioStreamLanguage<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::windows::core::RawPtr, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioStreamLanguage(&*(&index as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddAudioEffect<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, effectid: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, effectoptional: bool, effectconfiguration: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddAudioEffect(&*(&effectid as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), effectoptional, &*(&effectconfiguration as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AddVideoEffect<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, effectid: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, effectoptional: bool, effectconfiguration: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddVideoEffect(&*(&effectid as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), effectoptional, &*(&effectconfiguration as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllEffects().into()
        }
        unsafe extern "system" fn ActualStereo3DVideoPackingMode<Impl: IMediaElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualStereo3DVideoPackingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElement, BASE_OFFSET>(),
            PosterSource: PosterSource::<Impl, IMPL_OFFSET>,
            SetPosterSource: SetPosterSource::<Impl, IMPL_OFFSET>,
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            IsMuted: IsMuted::<Impl, IMPL_OFFSET>,
            SetIsMuted: SetIsMuted::<Impl, IMPL_OFFSET>,
            IsAudioOnly: IsAudioOnly::<Impl, IMPL_OFFSET>,
            AutoPlay: AutoPlay::<Impl, IMPL_OFFSET>,
            SetAutoPlay: SetAutoPlay::<Impl, IMPL_OFFSET>,
            Volume: Volume::<Impl, IMPL_OFFSET>,
            SetVolume: SetVolume::<Impl, IMPL_OFFSET>,
            Balance: Balance::<Impl, IMPL_OFFSET>,
            SetBalance: SetBalance::<Impl, IMPL_OFFSET>,
            NaturalVideoHeight: NaturalVideoHeight::<Impl, IMPL_OFFSET>,
            NaturalVideoWidth: NaturalVideoWidth::<Impl, IMPL_OFFSET>,
            NaturalDuration: NaturalDuration::<Impl, IMPL_OFFSET>,
            Position: Position::<Impl, IMPL_OFFSET>,
            SetPosition: SetPosition::<Impl, IMPL_OFFSET>,
            DownloadProgress: DownloadProgress::<Impl, IMPL_OFFSET>,
            BufferingProgress: BufferingProgress::<Impl, IMPL_OFFSET>,
            DownloadProgressOffset: DownloadProgressOffset::<Impl, IMPL_OFFSET>,
            CurrentState: CurrentState::<Impl, IMPL_OFFSET>,
            Markers: Markers::<Impl, IMPL_OFFSET>,
            CanSeek: CanSeek::<Impl, IMPL_OFFSET>,
            CanPause: CanPause::<Impl, IMPL_OFFSET>,
            AudioStreamCount: AudioStreamCount::<Impl, IMPL_OFFSET>,
            AudioStreamIndex: AudioStreamIndex::<Impl, IMPL_OFFSET>,
            SetAudioStreamIndex: SetAudioStreamIndex::<Impl, IMPL_OFFSET>,
            PlaybackRate: PlaybackRate::<Impl, IMPL_OFFSET>,
            SetPlaybackRate: SetPlaybackRate::<Impl, IMPL_OFFSET>,
            IsLooping: IsLooping::<Impl, IMPL_OFFSET>,
            SetIsLooping: SetIsLooping::<Impl, IMPL_OFFSET>,
            PlayToSource: PlayToSource::<Impl, IMPL_OFFSET>,
            DefaultPlaybackRate: DefaultPlaybackRate::<Impl, IMPL_OFFSET>,
            SetDefaultPlaybackRate: SetDefaultPlaybackRate::<Impl, IMPL_OFFSET>,
            AspectRatioWidth: AspectRatioWidth::<Impl, IMPL_OFFSET>,
            AspectRatioHeight: AspectRatioHeight::<Impl, IMPL_OFFSET>,
            RealTimePlayback: RealTimePlayback::<Impl, IMPL_OFFSET>,
            SetRealTimePlayback: SetRealTimePlayback::<Impl, IMPL_OFFSET>,
            AudioCategory: AudioCategory::<Impl, IMPL_OFFSET>,
            SetAudioCategory: SetAudioCategory::<Impl, IMPL_OFFSET>,
            AudioDeviceType: AudioDeviceType::<Impl, IMPL_OFFSET>,
            SetAudioDeviceType: SetAudioDeviceType::<Impl, IMPL_OFFSET>,
            ProtectionManager: ProtectionManager::<Impl, IMPL_OFFSET>,
            SetProtectionManager: SetProtectionManager::<Impl, IMPL_OFFSET>,
            Stereo3DVideoPackingMode: Stereo3DVideoPackingMode::<Impl, IMPL_OFFSET>,
            SetStereo3DVideoPackingMode: SetStereo3DVideoPackingMode::<Impl, IMPL_OFFSET>,
            Stereo3DVideoRenderMode: Stereo3DVideoRenderMode::<Impl, IMPL_OFFSET>,
            SetStereo3DVideoRenderMode: SetStereo3DVideoRenderMode::<Impl, IMPL_OFFSET>,
            IsStereo3DVideo: IsStereo3DVideo::<Impl, IMPL_OFFSET>,
            MediaOpened: MediaOpened::<Impl, IMPL_OFFSET>,
            RemoveMediaOpened: RemoveMediaOpened::<Impl, IMPL_OFFSET>,
            MediaEnded: MediaEnded::<Impl, IMPL_OFFSET>,
            RemoveMediaEnded: RemoveMediaEnded::<Impl, IMPL_OFFSET>,
            MediaFailed: MediaFailed::<Impl, IMPL_OFFSET>,
            RemoveMediaFailed: RemoveMediaFailed::<Impl, IMPL_OFFSET>,
            DownloadProgressChanged: DownloadProgressChanged::<Impl, IMPL_OFFSET>,
            RemoveDownloadProgressChanged: RemoveDownloadProgressChanged::<Impl, IMPL_OFFSET>,
            BufferingProgressChanged: BufferingProgressChanged::<Impl, IMPL_OFFSET>,
            RemoveBufferingProgressChanged: RemoveBufferingProgressChanged::<Impl, IMPL_OFFSET>,
            CurrentStateChanged: CurrentStateChanged::<Impl, IMPL_OFFSET>,
            RemoveCurrentStateChanged: RemoveCurrentStateChanged::<Impl, IMPL_OFFSET>,
            MarkerReached: MarkerReached::<Impl, IMPL_OFFSET>,
            RemoveMarkerReached: RemoveMarkerReached::<Impl, IMPL_OFFSET>,
            RateChanged: RateChanged::<Impl, IMPL_OFFSET>,
            RemoveRateChanged: RemoveRateChanged::<Impl, IMPL_OFFSET>,
            VolumeChanged: VolumeChanged::<Impl, IMPL_OFFSET>,
            RemoveVolumeChanged: RemoveVolumeChanged::<Impl, IMPL_OFFSET>,
            SeekCompleted: SeekCompleted::<Impl, IMPL_OFFSET>,
            RemoveSeekCompleted: RemoveSeekCompleted::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Play: Play::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            CanPlayType: CanPlayType::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            GetAudioStreamLanguage: GetAudioStreamLanguage::<Impl, IMPL_OFFSET>,
            AddAudioEffect: AddAudioEffect::<Impl, IMPL_OFFSET>,
            AddVideoEffect: AddVideoEffect::<Impl, IMPL_OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Impl, IMPL_OFFSET>,
            ActualStereo3DVideoPackingMode: ActualStereo3DVideoPackingMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElement as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Media_Core", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaElement2Impl: Sized {
    fn AreTransportControlsEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreTransportControlsEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn IsFullWindow(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SetMediaStreamSource(&mut self, source: &::core::option::Option<super::super::super::Media::Core::IMediaSource>) -> ::windows::core::Result<()>;
    fn PlayToPreferredSourceUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetPlayToPreferredSourceUri(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Media_Core", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaElement2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement2";
}
#[cfg(all(feature = "Foundation", feature = "Media_Core", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaElement2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElement2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElement2Vtbl {
        unsafe extern "system" fn AreTransportControlsEnabled<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreTransportControlsEnabled<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreTransportControlsEnabled(value).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        unsafe extern "system" fn SetMediaStreamSource<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaStreamSource(&*(&source as *const <super::super::super::Media::Core::IMediaSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Core::IMediaSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlayToPreferredSourceUri<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToPreferredSourceUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlayToPreferredSourceUri<Impl: IMediaElement2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlayToPreferredSourceUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElement2, BASE_OFFSET>(),
            AreTransportControlsEnabled: AreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            SetAreTransportControlsEnabled: SetAreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            IsFullWindow: IsFullWindow::<Impl, IMPL_OFFSET>,
            SetIsFullWindow: SetIsFullWindow::<Impl, IMPL_OFFSET>,
            SetMediaStreamSource: SetMediaStreamSource::<Impl, IMPL_OFFSET>,
            PlayToPreferredSourceUri: PlayToPreferredSourceUri::<Impl, IMPL_OFFSET>,
            SetPlayToPreferredSourceUri: SetPlayToPreferredSourceUri::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElement2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Media_Casting", feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaElement3Impl: Sized {
    fn TransportControls(&mut self) -> ::windows::core::Result<MediaTransportControls>;
    fn SetTransportControls(&mut self, value: &::core::option::Option<MediaTransportControls>) -> ::windows::core::Result<()>;
    fn PartialMediaFailureDetected(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePartialMediaFailureDetected(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetPlaybackSource(&mut self, source: &::core::option::Option<super::super::super::Media::Playback::IMediaPlaybackSource>) -> ::windows::core::Result<()>;
    fn GetAsCastingSource(&mut self) -> ::windows::core::Result<super::super::super::Media::Casting::CastingSource>;
}
#[cfg(all(feature = "Foundation", feature = "Media_Casting", feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaElement3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement3";
}
#[cfg(all(feature = "Foundation", feature = "Media_Casting", feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaElement3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElement3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElement3Vtbl {
        unsafe extern "system" fn TransportControls<Impl: IMediaElement3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TransportControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportControls<Impl: IMediaElement3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransportControls(&*(&value as *const <MediaTransportControls as ::windows::core::Abi>::Abi as *const <MediaTransportControls as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PartialMediaFailureDetected<Impl: IMediaElement3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PartialMediaFailureDetected(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePartialMediaFailureDetected<Impl: IMediaElement3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePartialMediaFailureDetected(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetPlaybackSource<Impl: IMediaElement3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaybackSource(&*(&source as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetAsCastingSource<Impl: IMediaElement3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAsCastingSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElement3, BASE_OFFSET>(),
            TransportControls: TransportControls::<Impl, IMPL_OFFSET>,
            SetTransportControls: SetTransportControls::<Impl, IMPL_OFFSET>,
            PartialMediaFailureDetected: PartialMediaFailureDetected::<Impl, IMPL_OFFSET>,
            RemovePartialMediaFailureDetected: RemovePartialMediaFailureDetected::<Impl, IMPL_OFFSET>,
            SetPlaybackSource: SetPlaybackSource::<Impl, IMPL_OFFSET>,
            GetAsCastingSource: GetAsCastingSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElement3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElementStaticsImpl: Sized {
    fn PosterSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsMutedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAudioOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoPlayProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VolumeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BalanceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalVideoHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalVideoWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalDurationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DownloadProgressProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BufferingProgressProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DownloadProgressOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CurrentStateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanSeekProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanPauseProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioStreamCountProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioStreamIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaybackRateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsLoopingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultPlaybackRateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AspectRatioWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AspectRatioHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RealTimePlaybackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioCategoryProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioDeviceTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProtectionManagerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Stereo3DVideoPackingModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Stereo3DVideoRenderModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStereo3DVideoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ActualStereo3DVideoPackingModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElementStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElementStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElementStaticsVtbl {
        unsafe extern "system" fn PosterSourceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMutedProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMutedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAudioOnlyProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAudioOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlayProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VolumeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VolumeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BalanceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BalanceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoHeightProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoWidthProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalDurationProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalDurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PositionProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingProgressProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BufferingProgressProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressOffsetProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentStateProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentStateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeekProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanSeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanPauseProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPauseProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamCountProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamCountProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamIndexProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaybackRateProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaybackRateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsLoopingProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLoopingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToSourceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPlaybackRateProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultPlaybackRateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioWidthProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioHeightProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RealTimePlaybackProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RealTimePlaybackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioCategoryProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioCategoryProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioDeviceTypeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioDeviceTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtectionManagerProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProtectionManagerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stereo3DVideoPackingModeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoPackingModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stereo3DVideoRenderModeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoRenderModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStereo3DVideoProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStereo3DVideoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActualStereo3DVideoPackingModeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualStereo3DVideoPackingModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElementStatics, BASE_OFFSET>(),
            PosterSourceProperty: PosterSourceProperty::<Impl, IMPL_OFFSET>,
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            IsMutedProperty: IsMutedProperty::<Impl, IMPL_OFFSET>,
            IsAudioOnlyProperty: IsAudioOnlyProperty::<Impl, IMPL_OFFSET>,
            AutoPlayProperty: AutoPlayProperty::<Impl, IMPL_OFFSET>,
            VolumeProperty: VolumeProperty::<Impl, IMPL_OFFSET>,
            BalanceProperty: BalanceProperty::<Impl, IMPL_OFFSET>,
            NaturalVideoHeightProperty: NaturalVideoHeightProperty::<Impl, IMPL_OFFSET>,
            NaturalVideoWidthProperty: NaturalVideoWidthProperty::<Impl, IMPL_OFFSET>,
            NaturalDurationProperty: NaturalDurationProperty::<Impl, IMPL_OFFSET>,
            PositionProperty: PositionProperty::<Impl, IMPL_OFFSET>,
            DownloadProgressProperty: DownloadProgressProperty::<Impl, IMPL_OFFSET>,
            BufferingProgressProperty: BufferingProgressProperty::<Impl, IMPL_OFFSET>,
            DownloadProgressOffsetProperty: DownloadProgressOffsetProperty::<Impl, IMPL_OFFSET>,
            CurrentStateProperty: CurrentStateProperty::<Impl, IMPL_OFFSET>,
            CanSeekProperty: CanSeekProperty::<Impl, IMPL_OFFSET>,
            CanPauseProperty: CanPauseProperty::<Impl, IMPL_OFFSET>,
            AudioStreamCountProperty: AudioStreamCountProperty::<Impl, IMPL_OFFSET>,
            AudioStreamIndexProperty: AudioStreamIndexProperty::<Impl, IMPL_OFFSET>,
            PlaybackRateProperty: PlaybackRateProperty::<Impl, IMPL_OFFSET>,
            IsLoopingProperty: IsLoopingProperty::<Impl, IMPL_OFFSET>,
            PlayToSourceProperty: PlayToSourceProperty::<Impl, IMPL_OFFSET>,
            DefaultPlaybackRateProperty: DefaultPlaybackRateProperty::<Impl, IMPL_OFFSET>,
            AspectRatioWidthProperty: AspectRatioWidthProperty::<Impl, IMPL_OFFSET>,
            AspectRatioHeightProperty: AspectRatioHeightProperty::<Impl, IMPL_OFFSET>,
            RealTimePlaybackProperty: RealTimePlaybackProperty::<Impl, IMPL_OFFSET>,
            AudioCategoryProperty: AudioCategoryProperty::<Impl, IMPL_OFFSET>,
            AudioDeviceTypeProperty: AudioDeviceTypeProperty::<Impl, IMPL_OFFSET>,
            ProtectionManagerProperty: ProtectionManagerProperty::<Impl, IMPL_OFFSET>,
            Stereo3DVideoPackingModeProperty: Stereo3DVideoPackingModeProperty::<Impl, IMPL_OFFSET>,
            Stereo3DVideoRenderModeProperty: Stereo3DVideoRenderModeProperty::<Impl, IMPL_OFFSET>,
            IsStereo3DVideoProperty: IsStereo3DVideoProperty::<Impl, IMPL_OFFSET>,
            ActualStereo3DVideoPackingModeProperty: ActualStereo3DVideoPackingModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElementStatics2Impl: Sized {
    fn AreTransportControlsEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToPreferredSourceUriProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElementStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElementStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElementStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElementStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElementStatics2Vtbl {
        unsafe extern "system" fn AreTransportControlsEnabledProperty<Impl: IMediaElementStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaElementStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaElementStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToPreferredSourceUriProperty<Impl: IMediaElementStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToPreferredSourceUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElementStatics2, BASE_OFFSET>(),
            AreTransportControlsEnabledProperty: AreTransportControlsEnabledProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowProperty: IsFullWindowProperty::<Impl, IMPL_OFFSET>,
            PlayToPreferredSourceUriProperty: PlayToPreferredSourceUriProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElementStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaPlayerElementImpl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Media::Playback::IMediaPlaybackSource>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Media::Playback::IMediaPlaybackSource>) -> ::windows::core::Result<()>;
    fn TransportControls(&mut self) -> ::windows::core::Result<MediaTransportControls>;
    fn SetTransportControls(&mut self, value: &::core::option::Option<MediaTransportControls>) -> ::windows::core::Result<()>;
    fn AreTransportControlsEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreTransportControlsEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PosterSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPosterSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn AutoPlay(&mut self) -> ::windows::core::Result<bool>;
    fn SetAutoPlay(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFullWindow(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MediaPlayer(&mut self) -> ::windows::core::Result<super::super::super::Media::Playback::MediaPlayer>;
    fn SetMediaPlayer(&mut self, mediaplayer: &::core::option::Option<super::super::super::Media::Playback::MediaPlayer>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaPlayerElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElement";
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaPlayerElementVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerElementImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerElementVtbl {
        unsafe extern "system" fn Source<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TransportControls<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TransportControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportControls<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransportControls(&*(&value as *const <MediaTransportControls as ::windows::core::Abi>::Abi as *const <MediaTransportControls as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AreTransportControlsEnabled<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreTransportControlsEnabled<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreTransportControlsEnabled(value).into()
        }
        unsafe extern "system" fn PosterSource<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosterSource<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPosterSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn AutoPlay<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoPlay(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        unsafe extern "system" fn MediaPlayer<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaPlayer<Impl: IMediaPlayerElementImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediaplayer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaPlayer(&*(&mediaplayer as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerElement, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            TransportControls: TransportControls::<Impl, IMPL_OFFSET>,
            SetTransportControls: SetTransportControls::<Impl, IMPL_OFFSET>,
            AreTransportControlsEnabled: AreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            SetAreTransportControlsEnabled: SetAreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            PosterSource: PosterSource::<Impl, IMPL_OFFSET>,
            SetPosterSource: SetPosterSource::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            AutoPlay: AutoPlay::<Impl, IMPL_OFFSET>,
            SetAutoPlay: SetAutoPlay::<Impl, IMPL_OFFSET>,
            IsFullWindow: IsFullWindow::<Impl, IMPL_OFFSET>,
            SetIsFullWindow: SetIsFullWindow::<Impl, IMPL_OFFSET>,
            MediaPlayer: MediaPlayer::<Impl, IMPL_OFFSET>,
            SetMediaPlayer: SetMediaPlayer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerElementFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaPlayerElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerElementFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerElementFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerElementFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaPlayerElementFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerElementFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerElementFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerElementStaticsImpl: Sized {
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AreTransportControlsEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PosterSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoPlayProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MediaPlayerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerElementStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerElementStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerElementStaticsVtbl {
        unsafe extern "system" fn SourceProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreTransportControlsEnabledProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PosterSourceProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlayProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaPlayerProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerElementStatics, BASE_OFFSET>(),
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            AreTransportControlsEnabledProperty: AreTransportControlsEnabledProperty::<Impl, IMPL_OFFSET>,
            PosterSourceProperty: PosterSourceProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            AutoPlayProperty: AutoPlayProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowProperty: IsFullWindowProperty::<Impl, IMPL_OFFSET>,
            MediaPlayerProperty: MediaPlayerProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaPlayerPresenterImpl: Sized {
    fn MediaPlayer(&mut self) -> ::windows::core::Result<super::super::super::Media::Playback::MediaPlayer>;
    fn SetMediaPlayer(&mut self, value: &::core::option::Option<super::super::super::Media::Playback::MediaPlayer>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn IsFullWindow(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaPlayerPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenter";
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaPlayerPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerPresenterVtbl {
        unsafe extern "system" fn MediaPlayer<Impl: IMediaPlayerPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaPlayer<Impl: IMediaPlayerPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaPlayer(&*(&value as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaPlayerPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaPlayerPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaPlayerPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaPlayerPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerPresenter, BASE_OFFSET>(),
            MediaPlayer: MediaPlayer::<Impl, IMPL_OFFSET>,
            SetMediaPlayer: SetMediaPlayer::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            IsFullWindow: IsFullWindow::<Impl, IMPL_OFFSET>,
            SetIsFullWindow: SetIsFullWindow::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerPresenterFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaPlayerPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerPresenterFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerPresenterFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaPlayerPresenterFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerPresenterStaticsImpl: Sized {
    fn MediaPlayerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerPresenterStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerPresenterStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerPresenterStaticsVtbl {
        unsafe extern "system" fn MediaPlayerProperty<Impl: IMediaPlayerPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaPlayerPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaPlayerPresenterStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerPresenterStatics, BASE_OFFSET>(),
            MediaPlayerProperty: MediaPlayerProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowProperty: IsFullWindowProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerPresenterStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsImpl: Sized {
    fn IsFullWindowButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindowButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFullWindowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastForwardButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastForwardButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastForwardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastForwardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastRewindButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastRewindButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastRewindEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastRewindEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsStopButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsStopButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsStopEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsStopEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVolumeButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVolumeButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVolumeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVolumeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPlaybackRateButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPlaybackRateButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPlaybackRateEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPlaybackRateEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSeekBarVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSeekBarVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSeekEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSeekEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCompact(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompact(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsVtbl {
        unsafe extern "system" fn IsFullWindowButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindowButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindowButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFullWindowEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindowEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindowEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomButtonVisible(value).into()
        }
        unsafe extern "system" fn IsZoomEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomEnabled(value).into()
        }
        unsafe extern "system" fn IsFastForwardButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastForwardButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastForwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFastForwardEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastForwardEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastForwardEnabled(value).into()
        }
        unsafe extern "system" fn IsFastRewindButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastRewindButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastRewindButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFastRewindEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastRewindEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastRewindEnabled(value).into()
        }
        unsafe extern "system" fn IsStopButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStopButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsStopButtonVisible(value).into()
        }
        unsafe extern "system" fn IsStopEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStopEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsStopEnabled(value).into()
        }
        unsafe extern "system" fn IsVolumeButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVolumeButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVolumeButtonVisible(value).into()
        }
        unsafe extern "system" fn IsVolumeEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVolumeEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVolumeEnabled(value).into()
        }
        unsafe extern "system" fn IsPlaybackRateButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPlaybackRateButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPlaybackRateButtonVisible(value).into()
        }
        unsafe extern "system" fn IsPlaybackRateEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPlaybackRateEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPlaybackRateEnabled(value).into()
        }
        unsafe extern "system" fn IsSeekBarVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekBarVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSeekBarVisible<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSeekBarVisible(value).into()
        }
        unsafe extern "system" fn IsSeekEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSeekEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSeekEnabled(value).into()
        }
        unsafe extern "system" fn IsCompact<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompact<Impl: IMediaTransportControlsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompact(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls, BASE_OFFSET>(),
            IsFullWindowButtonVisible: IsFullWindowButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsFullWindowButtonVisible: SetIsFullWindowButtonVisible::<Impl, IMPL_OFFSET>,
            IsFullWindowEnabled: IsFullWindowEnabled::<Impl, IMPL_OFFSET>,
            SetIsFullWindowEnabled: SetIsFullWindowEnabled::<Impl, IMPL_OFFSET>,
            IsZoomButtonVisible: IsZoomButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsZoomButtonVisible: SetIsZoomButtonVisible::<Impl, IMPL_OFFSET>,
            IsZoomEnabled: IsZoomEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomEnabled: SetIsZoomEnabled::<Impl, IMPL_OFFSET>,
            IsFastForwardButtonVisible: IsFastForwardButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsFastForwardButtonVisible: SetIsFastForwardButtonVisible::<Impl, IMPL_OFFSET>,
            IsFastForwardEnabled: IsFastForwardEnabled::<Impl, IMPL_OFFSET>,
            SetIsFastForwardEnabled: SetIsFastForwardEnabled::<Impl, IMPL_OFFSET>,
            IsFastRewindButtonVisible: IsFastRewindButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsFastRewindButtonVisible: SetIsFastRewindButtonVisible::<Impl, IMPL_OFFSET>,
            IsFastRewindEnabled: IsFastRewindEnabled::<Impl, IMPL_OFFSET>,
            SetIsFastRewindEnabled: SetIsFastRewindEnabled::<Impl, IMPL_OFFSET>,
            IsStopButtonVisible: IsStopButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsStopButtonVisible: SetIsStopButtonVisible::<Impl, IMPL_OFFSET>,
            IsStopEnabled: IsStopEnabled::<Impl, IMPL_OFFSET>,
            SetIsStopEnabled: SetIsStopEnabled::<Impl, IMPL_OFFSET>,
            IsVolumeButtonVisible: IsVolumeButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsVolumeButtonVisible: SetIsVolumeButtonVisible::<Impl, IMPL_OFFSET>,
            IsVolumeEnabled: IsVolumeEnabled::<Impl, IMPL_OFFSET>,
            SetIsVolumeEnabled: SetIsVolumeEnabled::<Impl, IMPL_OFFSET>,
            IsPlaybackRateButtonVisible: IsPlaybackRateButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsPlaybackRateButtonVisible: SetIsPlaybackRateButtonVisible::<Impl, IMPL_OFFSET>,
            IsPlaybackRateEnabled: IsPlaybackRateEnabled::<Impl, IMPL_OFFSET>,
            SetIsPlaybackRateEnabled: SetIsPlaybackRateEnabled::<Impl, IMPL_OFFSET>,
            IsSeekBarVisible: IsSeekBarVisible::<Impl, IMPL_OFFSET>,
            SetIsSeekBarVisible: SetIsSeekBarVisible::<Impl, IMPL_OFFSET>,
            IsSeekEnabled: IsSeekEnabled::<Impl, IMPL_OFFSET>,
            SetIsSeekEnabled: SetIsSeekEnabled::<Impl, IMPL_OFFSET>,
            IsCompact: IsCompact::<Impl, IMPL_OFFSET>,
            SetIsCompact: SetIsCompact::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaTransportControls2Impl: Sized {
    fn IsSkipForwardButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipForwardButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipForwardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipForwardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipBackwardButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipBackwardButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipBackwardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipBackwardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsNextTrackButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsNextTrackButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPreviousTrackButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPreviousTrackButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn FastPlayFallbackBehaviour(&mut self) -> ::windows::core::Result<super::Media::FastPlayFallbackBehaviour>;
    fn SetFastPlayFallbackBehaviour(&mut self, value: super::Media::FastPlayFallbackBehaviour) -> ::windows::core::Result<()>;
    fn ThumbnailRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveThumbnailRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaTransportControls2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaTransportControls2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControls2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControls2Vtbl {
        unsafe extern "system" fn IsSkipForwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipForwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipForwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsSkipForwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipForwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipForwardEnabled(value).into()
        }
        unsafe extern "system" fn IsSkipBackwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipBackwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipBackwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsSkipBackwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipBackwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipBackwardEnabled(value).into()
        }
        unsafe extern "system" fn IsNextTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNextTrackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsNextTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsNextTrackButtonVisible(value).into()
        }
        unsafe extern "system" fn IsPreviousTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPreviousTrackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPreviousTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPreviousTrackButtonVisible(value).into()
        }
        unsafe extern "system" fn FastPlayFallbackBehaviour<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::FastPlayFallbackBehaviour) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FastPlayFallbackBehaviour() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFastPlayFallbackBehaviour<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::FastPlayFallbackBehaviour) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFastPlayFallbackBehaviour(value).into()
        }
        unsafe extern "system" fn ThumbnailRequested<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ThumbnailRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveThumbnailRequested<Impl: IMediaTransportControls2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveThumbnailRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls2, BASE_OFFSET>(),
            IsSkipForwardButtonVisible: IsSkipForwardButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsSkipForwardButtonVisible: SetIsSkipForwardButtonVisible::<Impl, IMPL_OFFSET>,
            IsSkipForwardEnabled: IsSkipForwardEnabled::<Impl, IMPL_OFFSET>,
            SetIsSkipForwardEnabled: SetIsSkipForwardEnabled::<Impl, IMPL_OFFSET>,
            IsSkipBackwardButtonVisible: IsSkipBackwardButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsSkipBackwardButtonVisible: SetIsSkipBackwardButtonVisible::<Impl, IMPL_OFFSET>,
            IsSkipBackwardEnabled: IsSkipBackwardEnabled::<Impl, IMPL_OFFSET>,
            SetIsSkipBackwardEnabled: SetIsSkipBackwardEnabled::<Impl, IMPL_OFFSET>,
            IsNextTrackButtonVisible: IsNextTrackButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsNextTrackButtonVisible: SetIsNextTrackButtonVisible::<Impl, IMPL_OFFSET>,
            IsPreviousTrackButtonVisible: IsPreviousTrackButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsPreviousTrackButtonVisible: SetIsPreviousTrackButtonVisible::<Impl, IMPL_OFFSET>,
            FastPlayFallbackBehaviour: FastPlayFallbackBehaviour::<Impl, IMPL_OFFSET>,
            SetFastPlayFallbackBehaviour: SetFastPlayFallbackBehaviour::<Impl, IMPL_OFFSET>,
            ThumbnailRequested: ThumbnailRequested::<Impl, IMPL_OFFSET>,
            RemoveThumbnailRequested: RemoveThumbnailRequested::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls3Impl: Sized {
    fn ShowAndHideAutomatically(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowAndHideAutomatically(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsRepeatEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRepeatEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsRepeatButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRepeatButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Show(&mut self) -> ::windows::core::Result<()>;
    fn Hide(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls3";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControls3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControls3Vtbl {
        unsafe extern "system" fn ShowAndHideAutomatically<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAndHideAutomatically() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAndHideAutomatically<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowAndHideAutomatically(value).into()
        }
        unsafe extern "system" fn IsRepeatEnabled<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRepeatEnabled<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRepeatEnabled(value).into()
        }
        unsafe extern "system" fn IsRepeatButtonVisible<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRepeatButtonVisible<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRepeatButtonVisible(value).into()
        }
        unsafe extern "system" fn Show<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Show().into()
        }
        unsafe extern "system" fn Hide<Impl: IMediaTransportControls3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls3, BASE_OFFSET>(),
            ShowAndHideAutomatically: ShowAndHideAutomatically::<Impl, IMPL_OFFSET>,
            SetShowAndHideAutomatically: SetShowAndHideAutomatically::<Impl, IMPL_OFFSET>,
            IsRepeatEnabled: IsRepeatEnabled::<Impl, IMPL_OFFSET>,
            SetIsRepeatEnabled: SetIsRepeatEnabled::<Impl, IMPL_OFFSET>,
            IsRepeatButtonVisible: IsRepeatButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsRepeatButtonVisible: SetIsRepeatButtonVisible::<Impl, IMPL_OFFSET>,
            Show: Show::<Impl, IMPL_OFFSET>,
            Hide: Hide::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls4Impl: Sized {
    fn IsCompactOverlayButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompactOverlayButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCompactOverlayEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompactOverlayEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls4";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControls4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControls4Vtbl {
        unsafe extern "system" fn IsCompactOverlayButtonVisible<Impl: IMediaTransportControls4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompactOverlayButtonVisible<Impl: IMediaTransportControls4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompactOverlayButtonVisible(value).into()
        }
        unsafe extern "system" fn IsCompactOverlayEnabled<Impl: IMediaTransportControls4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompactOverlayEnabled<Impl: IMediaTransportControls4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompactOverlayEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls4, BASE_OFFSET>(),
            IsCompactOverlayButtonVisible: IsCompactOverlayButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsCompactOverlayButtonVisible: SetIsCompactOverlayButtonVisible::<Impl, IMPL_OFFSET>,
            IsCompactOverlayEnabled: IsCompactOverlayEnabled::<Impl, IMPL_OFFSET>,
            SetIsCompactOverlayEnabled: SetIsCompactOverlayEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaTransportControls>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaTransportControlsFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsHelperImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsHelper {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelper";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsHelperVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsHelperImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsHelperVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsHelper, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsHelper as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IMediaTransportControlsHelperStaticsImpl: Sized {
    fn DropoutOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetDropoutOrder(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<super::super::super::Foundation::IReference<i32>>;
    fn SetDropoutOrder(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaTransportControlsHelperStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelperStatics";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IMediaTransportControlsHelperStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsHelperStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsHelperStaticsVtbl {
        unsafe extern "system" fn DropoutOrderProperty<Impl: IMediaTransportControlsHelperStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropoutOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDropoutOrder<Impl: IMediaTransportControlsHelperStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDropoutOrder(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDropoutOrder<Impl: IMediaTransportControlsHelperStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDropoutOrder(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsHelperStatics, BASE_OFFSET>(),
            DropoutOrderProperty: DropoutOrderProperty::<Impl, IMPL_OFFSET>,
            GetDropoutOrder: GetDropoutOrder::<Impl, IMPL_OFFSET>,
            SetDropoutOrder: SetDropoutOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsHelperStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStaticsImpl: Sized {
    fn IsFullWindowButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastForwardButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastForwardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastRewindButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastRewindEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStopButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStopEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVolumeButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVolumeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPlaybackRateButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPlaybackRateEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSeekBarVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSeekEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStaticsVtbl {
        unsafe extern "system" fn IsFullWindowButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastForwardButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastForwardEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastRewindButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastRewindEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStopButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStopEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVolumeButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVolumeEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPlaybackRateButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPlaybackRateEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSeekBarVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekBarVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSeekEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics, BASE_OFFSET>(),
            IsFullWindowButtonVisibleProperty: IsFullWindowButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowEnabledProperty: IsFullWindowEnabledProperty::<Impl, IMPL_OFFSET>,
            IsZoomButtonVisibleProperty: IsZoomButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsZoomEnabledProperty: IsZoomEnabledProperty::<Impl, IMPL_OFFSET>,
            IsFastForwardButtonVisibleProperty: IsFastForwardButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsFastForwardEnabledProperty: IsFastForwardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsFastRewindButtonVisibleProperty: IsFastRewindButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsFastRewindEnabledProperty: IsFastRewindEnabledProperty::<Impl, IMPL_OFFSET>,
            IsStopButtonVisibleProperty: IsStopButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsStopEnabledProperty: IsStopEnabledProperty::<Impl, IMPL_OFFSET>,
            IsVolumeButtonVisibleProperty: IsVolumeButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsVolumeEnabledProperty: IsVolumeEnabledProperty::<Impl, IMPL_OFFSET>,
            IsPlaybackRateButtonVisibleProperty: IsPlaybackRateButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsPlaybackRateEnabledProperty: IsPlaybackRateEnabledProperty::<Impl, IMPL_OFFSET>,
            IsSeekBarVisibleProperty: IsSeekBarVisibleProperty::<Impl, IMPL_OFFSET>,
            IsSeekEnabledProperty: IsSeekEnabledProperty::<Impl, IMPL_OFFSET>,
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics2Impl: Sized {
    fn IsSkipForwardButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipForwardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipBackwardButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipBackwardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsNextTrackButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPreviousTrackButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FastPlayFallbackBehaviourProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStatics2Vtbl {
        unsafe extern "system" fn IsSkipForwardButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipForwardEnabledProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipBackwardButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipBackwardEnabledProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsNextTrackButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNextTrackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPreviousTrackButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPreviousTrackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FastPlayFallbackBehaviourProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FastPlayFallbackBehaviourProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics2, BASE_OFFSET>(),
            IsSkipForwardButtonVisibleProperty: IsSkipForwardButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsSkipForwardEnabledProperty: IsSkipForwardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsSkipBackwardButtonVisibleProperty: IsSkipBackwardButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsSkipBackwardEnabledProperty: IsSkipBackwardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsNextTrackButtonVisibleProperty: IsNextTrackButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsPreviousTrackButtonVisibleProperty: IsPreviousTrackButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            FastPlayFallbackBehaviourProperty: FastPlayFallbackBehaviourProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics3Impl: Sized {
    fn ShowAndHideAutomaticallyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRepeatEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRepeatButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStatics3Vtbl {
        unsafe extern "system" fn ShowAndHideAutomaticallyProperty<Impl: IMediaTransportControlsStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAndHideAutomaticallyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRepeatEnabledProperty<Impl: IMediaTransportControlsStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRepeatButtonVisibleProperty<Impl: IMediaTransportControlsStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics3, BASE_OFFSET>(),
            ShowAndHideAutomaticallyProperty: ShowAndHideAutomaticallyProperty::<Impl, IMPL_OFFSET>,
            IsRepeatEnabledProperty: IsRepeatEnabledProperty::<Impl, IMPL_OFFSET>,
            IsRepeatButtonVisibleProperty: IsRepeatButtonVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics4Impl: Sized {
    fn IsCompactOverlayButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactOverlayEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStatics4Vtbl {
        unsafe extern "system" fn IsCompactOverlayButtonVisibleProperty<Impl: IMediaTransportControlsStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactOverlayEnabledProperty<Impl: IMediaTransportControlsStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics4, BASE_OFFSET>(),
            IsCompactOverlayButtonVisibleProperty: IsCompactOverlayButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsCompactOverlayEnabledProperty: IsCompactOverlayEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuBarImpl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuBarItem>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBar";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuBarVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarVtbl {
        unsafe extern "system" fn Items<Impl: IMenuBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBar, BASE_OFFSET>(), Items: Items::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBar as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuBarItemImpl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTitle(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuBarItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItem";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuBarItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemVtbl {
        unsafe extern "system" fn Title<Impl: IMenuBarItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IMenuBarItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Items<Impl: IMenuBarItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItem, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBarItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFlyoutImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemFlyoutVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemFlyout, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFlyoutFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBarItemFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFlyoutFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemFlyoutFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarItemFlyoutFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemStaticsImpl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: IMenuBarItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsProperty<Impl: IMenuBarItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            ItemsProperty: ItemsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarStaticsImpl: Sized {
    fn ItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarStaticsVtbl {
        unsafe extern "system" fn ItemsProperty<Impl: IMenuBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarStatics, BASE_OFFSET>(), ItemsProperty: ItemsProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuFlyoutImpl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
    fn MenuFlyoutPresenterStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetMenuFlyoutPresenterStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyout";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutVtbl {
        unsafe extern "system" fn Items<Impl: IMenuFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuFlyoutPresenterStyle<Impl: IMenuFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuFlyoutPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuFlyoutPresenterStyle<Impl: IMenuFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuFlyoutPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyout, BASE_OFFSET>(),
            Items: Items::<Impl, IMPL_OFFSET>,
            MenuFlyoutPresenterStyle: MenuFlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
            SetMenuFlyoutPresenterStyle: SetMenuFlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IMenuFlyout2Impl: Sized {
    fn ShowAt(&mut self, targetelement: &::core::option::Option<super::UIElement>, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyout2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyout2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IMenuFlyout2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyout2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyout2Vtbl {
        unsafe extern "system" fn ShowAt<Impl: IMenuFlyout2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, targetelement: ::windows::core::RawPtr, point: super::super::super::Foundation::Point) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowAt(&*(&targetelement as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyout2, BASE_OFFSET>(), ShowAt: ShowAt::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyout2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IMenuFlyoutItemImpl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Command(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Click(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IMenuFlyoutItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemVtbl {
        unsafe extern "system" fn Text<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Click<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Click(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClick<Impl: IMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItem, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            Command: Command::<Impl, IMPL_OFFSET>,
            SetCommand: SetCommand::<Impl, IMPL_OFFSET>,
            CommandParameter: CommandParameter::<Impl, IMPL_OFFSET>,
            SetCommandParameter: SetCommandParameter::<Impl, IMPL_OFFSET>,
            Click: Click::<Impl, IMPL_OFFSET>,
            RemoveClick: RemoveClick::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItem2Impl: Sized {
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItem2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItem2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItem2Vtbl {
        unsafe extern "system" fn Icon<Impl: IMenuFlyoutItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IMenuFlyoutItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItem2, BASE_OFFSET>(),
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IMenuFlyoutItem3Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::MenuFlyoutItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutItem3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem3";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IMenuFlyoutItem3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItem3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItem3Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IMenuFlyoutItem3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IMenuFlyoutItem3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IMenuFlyoutItem3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItem3, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverride: KeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            SetKeyboardAcceleratorTextOverride: SetKeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItem3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemBaseImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBase";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemBaseVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemBaseImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemBaseVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemBase, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemBase as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemBaseFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemBaseFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemBaseFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemBaseFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemBaseFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemBaseFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStaticsImpl: Sized {
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemStaticsVtbl {
        unsafe extern "system" fn TextProperty<Impl: IMenuFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: IMenuFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: IMenuFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemStatics, BASE_OFFSET>(),
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            CommandProperty: CommandProperty::<Impl, IMPL_OFFSET>,
            CommandParameterProperty: CommandParameterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStatics2Impl: Sized {
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemStatics2Vtbl {
        unsafe extern "system" fn IconProperty<Impl: IMenuFlyoutItemStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemStatics2, BASE_OFFSET>(),
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStatics3Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemStatics3Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IMenuFlyoutItemStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemStatics3, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverrideProperty: KeyboardAcceleratorTextOverrideProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenterVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IMenuFlyoutPresenter2Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::MenuFlyoutPresenterTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter2";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IMenuFlyoutPresenter2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenter2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenter2Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IMenuFlyoutPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenter2, BASE_OFFSET>(),
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenter3Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenter3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenter3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenter3Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IMenuFlyoutPresenter3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IMenuFlyoutPresenter3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenter3, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenter3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenterFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutPresenterFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterStatics3Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenterStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenterStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenterStatics3Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IMenuFlyoutPresenterStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenterStatics3, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenterStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSeparatorImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSeparatorVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSeparatorImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSeparatorVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSeparator, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSeparator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSeparatorFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSeparatorFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSeparatorFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSeparatorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutSeparatorFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSeparatorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSeparatorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutStaticsImpl: Sized {
    fn MenuFlyoutPresenterStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutStaticsVtbl {
        unsafe extern "system" fn MenuFlyoutPresenterStyleProperty<Impl: IMenuFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuFlyoutPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutStatics, BASE_OFFSET>(),
            MenuFlyoutPresenterStyleProperty: MenuFlyoutPresenterStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuFlyoutSubItemImpl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuFlyoutSubItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItemVtbl {
        unsafe extern "system" fn Items<Impl: IMenuFlyoutSubItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Text<Impl: IMenuFlyoutSubItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IMenuFlyoutSubItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItem, BASE_OFFSET>(),
            Items: Items::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItem2Impl: Sized {
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItem2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItem2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItem2Vtbl {
        unsafe extern "system" fn Icon<Impl: IMenuFlyoutSubItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IMenuFlyoutSubItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItem2, BASE_OFFSET>(),
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItemStaticsImpl: Sized {
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItemStaticsVtbl {
        unsafe extern "system" fn TextProperty<Impl: IMenuFlyoutSubItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItemStatics, BASE_OFFSET>(),
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItemStatics2Impl: Sized {
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItemStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItemStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItemStatics2Vtbl {
        unsafe extern "system" fn IconProperty<Impl: IMenuFlyoutSubItemStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItemStatics2, BASE_OFFSET>(),
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "UI_Xaml_Interop")]
pub trait INavigateImpl: Sized {
    fn Navigate(&mut self, sourcepagetype: &super::Interop::TypeName) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "UI_Xaml_Interop")]
impl ::windows::core::RuntimeName for INavigate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigate";
}
#[cfg(feature = "UI_Xaml_Interop")]
impl INavigateVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigateImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigateVtbl {
        unsafe extern "system" fn Navigate<Impl: INavigateImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigate(&*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigate, BASE_OFFSET>(), Navigate: Navigate::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigate as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait INavigationViewImpl: Sized {
    fn IsPaneOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CompactModeThresholdWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetCompactModeThresholdWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ExpandedModeThresholdWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetExpandedModeThresholdWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn PaneFooter(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneFooter(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<NavigationViewDisplayMode>;
    fn IsSettingsVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSettingsVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPaneToggleButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneToggleButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AlwaysShowHeader(&mut self) -> ::windows::core::Result<bool>;
    fn SetAlwaysShowHeader(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCompactPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn OpenPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetOpenPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn PaneToggleButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetPaneToggleButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn MenuItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn MenuItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetMenuItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SettingsItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn AutoSuggestBox(&mut self) -> ::windows::core::Result<AutoSuggestBox>;
    fn SetAutoSuggestBox(&mut self, value: &::core::option::Option<AutoSuggestBox>) -> ::windows::core::Result<()>;
    fn MenuItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetMenuItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn MenuItemTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetMenuItemTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn MenuItemContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetMenuItemContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn MenuItemContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetMenuItemContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn MenuItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromMenuItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ItemInvoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DisplayModeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDisplayModeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl INavigationViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewVtbl {
        unsafe extern "system" fn IsPaneOpen<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneOpen<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneOpen(value).into()
        }
        unsafe extern "system" fn CompactModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactModeThresholdWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCompactModeThresholdWidth(value).into()
        }
        unsafe extern "system" fn ExpandedModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedModeThresholdWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExpandedModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetExpandedModeThresholdWidth(value).into()
        }
        unsafe extern "system" fn PaneFooter<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneFooter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneFooter<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneFooter(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsVisible<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSettingsVisible<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSettingsVisible(value).into()
        }
        unsafe extern "system" fn IsPaneToggleButtonVisible<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneToggleButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneToggleButtonVisible<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneToggleButtonVisible(value).into()
        }
        unsafe extern "system" fn AlwaysShowHeader<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlwaysShowHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlwaysShowHeader<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlwaysShowHeader(value).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactPaneLength<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCompactPaneLength(value).into()
        }
        unsafe extern "system" fn OpenPaneLength<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpenPaneLength<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpenPaneLength(value).into()
        }
        unsafe extern "system" fn PaneToggleButtonStyle<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneToggleButtonStyle<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneToggleButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItems<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsSource<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemsSource<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SettingsItem<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SettingsItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoSuggestBox<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoSuggestBox() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoSuggestBox<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoSuggestBox(&*(&value as *const <AutoSuggestBox as ::windows::core::Abi>::Abi as *const <AutoSuggestBox as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemTemplate<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemTemplate<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemTemplateSelector<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemTemplateSelector<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemContainerStyle<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemContainerStyle<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemContainerStyleSelector<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemContainerStyleSelector<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemFromContainer<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromMenuItem<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromMenuItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemInvoked<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemInvoked<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayModeChanged<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDisplayModeChanged<Impl: INavigationViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDisplayModeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationView, BASE_OFFSET>(),
            IsPaneOpen: IsPaneOpen::<Impl, IMPL_OFFSET>,
            SetIsPaneOpen: SetIsPaneOpen::<Impl, IMPL_OFFSET>,
            CompactModeThresholdWidth: CompactModeThresholdWidth::<Impl, IMPL_OFFSET>,
            SetCompactModeThresholdWidth: SetCompactModeThresholdWidth::<Impl, IMPL_OFFSET>,
            ExpandedModeThresholdWidth: ExpandedModeThresholdWidth::<Impl, IMPL_OFFSET>,
            SetExpandedModeThresholdWidth: SetExpandedModeThresholdWidth::<Impl, IMPL_OFFSET>,
            PaneFooter: PaneFooter::<Impl, IMPL_OFFSET>,
            SetPaneFooter: SetPaneFooter::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            IsSettingsVisible: IsSettingsVisible::<Impl, IMPL_OFFSET>,
            SetIsSettingsVisible: SetIsSettingsVisible::<Impl, IMPL_OFFSET>,
            IsPaneToggleButtonVisible: IsPaneToggleButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsPaneToggleButtonVisible: SetIsPaneToggleButtonVisible::<Impl, IMPL_OFFSET>,
            AlwaysShowHeader: AlwaysShowHeader::<Impl, IMPL_OFFSET>,
            SetAlwaysShowHeader: SetAlwaysShowHeader::<Impl, IMPL_OFFSET>,
            CompactPaneLength: CompactPaneLength::<Impl, IMPL_OFFSET>,
            SetCompactPaneLength: SetCompactPaneLength::<Impl, IMPL_OFFSET>,
            OpenPaneLength: OpenPaneLength::<Impl, IMPL_OFFSET>,
            SetOpenPaneLength: SetOpenPaneLength::<Impl, IMPL_OFFSET>,
            PaneToggleButtonStyle: PaneToggleButtonStyle::<Impl, IMPL_OFFSET>,
            SetPaneToggleButtonStyle: SetPaneToggleButtonStyle::<Impl, IMPL_OFFSET>,
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            SetSelectedItem: SetSelectedItem::<Impl, IMPL_OFFSET>,
            MenuItems: MenuItems::<Impl, IMPL_OFFSET>,
            MenuItemsSource: MenuItemsSource::<Impl, IMPL_OFFSET>,
            SetMenuItemsSource: SetMenuItemsSource::<Impl, IMPL_OFFSET>,
            SettingsItem: SettingsItem::<Impl, IMPL_OFFSET>,
            AutoSuggestBox: AutoSuggestBox::<Impl, IMPL_OFFSET>,
            SetAutoSuggestBox: SetAutoSuggestBox::<Impl, IMPL_OFFSET>,
            MenuItemTemplate: MenuItemTemplate::<Impl, IMPL_OFFSET>,
            SetMenuItemTemplate: SetMenuItemTemplate::<Impl, IMPL_OFFSET>,
            MenuItemTemplateSelector: MenuItemTemplateSelector::<Impl, IMPL_OFFSET>,
            SetMenuItemTemplateSelector: SetMenuItemTemplateSelector::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyle: MenuItemContainerStyle::<Impl, IMPL_OFFSET>,
            SetMenuItemContainerStyle: SetMenuItemContainerStyle::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyleSelector: MenuItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetMenuItemContainerStyleSelector: SetMenuItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            MenuItemFromContainer: MenuItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromMenuItem: ContainerFromMenuItem::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ItemInvoked: ItemInvoked::<Impl, IMPL_OFFSET>,
            RemoveItemInvoked: RemoveItemInvoked::<Impl, IMPL_OFFSET>,
            DisplayModeChanged: DisplayModeChanged::<Impl, IMPL_OFFSET>,
            RemoveDisplayModeChanged: RemoveDisplayModeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait INavigationView2Impl: Sized {
    fn IsBackButtonVisible(&mut self) -> ::windows::core::Result<NavigationViewBackButtonVisible>;
    fn SetIsBackButtonVisible(&mut self, value: NavigationViewBackButtonVisible) -> ::windows::core::Result<()>;
    fn IsBackEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsBackEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PaneTitle(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPaneTitle(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn BackRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBackRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpening(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl INavigationView2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationView2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationView2Vtbl {
        unsafe extern "system" fn IsBackButtonVisible<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewBackButtonVisible) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBackButtonVisible<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewBackButtonVisible) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsBackButtonVisible(value).into()
        }
        unsafe extern "system" fn IsBackEnabled<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBackEnabled<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsBackEnabled(value).into()
        }
        unsafe extern "system" fn PaneTitle<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneTitle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneTitle<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackRequested<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBackRequested<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBackRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosed<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosed<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosing<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosing<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpened<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpened<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpening<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpening(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpening<Impl: INavigationView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationView2, BASE_OFFSET>(),
            IsBackButtonVisible: IsBackButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsBackButtonVisible: SetIsBackButtonVisible::<Impl, IMPL_OFFSET>,
            IsBackEnabled: IsBackEnabled::<Impl, IMPL_OFFSET>,
            SetIsBackEnabled: SetIsBackEnabled::<Impl, IMPL_OFFSET>,
            PaneTitle: PaneTitle::<Impl, IMPL_OFFSET>,
            SetPaneTitle: SetPaneTitle::<Impl, IMPL_OFFSET>,
            BackRequested: BackRequested::<Impl, IMPL_OFFSET>,
            RemoveBackRequested: RemoveBackRequested::<Impl, IMPL_OFFSET>,
            PaneClosed: PaneClosed::<Impl, IMPL_OFFSET>,
            RemovePaneClosed: RemovePaneClosed::<Impl, IMPL_OFFSET>,
            PaneClosing: PaneClosing::<Impl, IMPL_OFFSET>,
            RemovePaneClosing: RemovePaneClosing::<Impl, IMPL_OFFSET>,
            PaneOpened: PaneOpened::<Impl, IMPL_OFFSET>,
            RemovePaneOpened: RemovePaneOpened::<Impl, IMPL_OFFSET>,
            PaneOpening: PaneOpening::<Impl, IMPL_OFFSET>,
            RemovePaneOpening: RemovePaneOpening::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationView3Impl: Sized {
    fn PaneDisplayMode(&mut self) -> ::windows::core::Result<NavigationViewPaneDisplayMode>;
    fn SetPaneDisplayMode(&mut self, value: NavigationViewPaneDisplayMode) -> ::windows::core::Result<()>;
    fn PaneHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn PaneCustomContent(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneCustomContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ContentOverlay(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContentOverlay(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn IsPaneVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SelectionFollowsFocus(&mut self) -> ::windows::core::Result<NavigationViewSelectionFollowsFocus>;
    fn SetSelectionFollowsFocus(&mut self, value: NavigationViewSelectionFollowsFocus) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<NavigationViewTemplateSettings>;
    fn ShoulderNavigationEnabled(&mut self) -> ::windows::core::Result<NavigationViewShoulderNavigationEnabled>;
    fn SetShoulderNavigationEnabled(&mut self, value: NavigationViewShoulderNavigationEnabled) -> ::windows::core::Result<()>;
    fn OverflowLabelMode(&mut self) -> ::windows::core::Result<NavigationViewOverflowLabelMode>;
    fn SetOverflowLabelMode(&mut self, value: NavigationViewOverflowLabelMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView3";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationView3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationView3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationView3Vtbl {
        unsafe extern "system" fn PaneDisplayMode<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewPaneDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneDisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneDisplayMode<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewPaneDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneDisplayMode(value).into()
        }
        unsafe extern "system" fn PaneHeader<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneHeader<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneCustomContent<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneCustomContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneCustomContent<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneCustomContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentOverlay<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentOverlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentOverlay<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentOverlay(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPaneVisible<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneVisible<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneVisible(value).into()
        }
        unsafe extern "system" fn SelectionFollowsFocus<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewSelectionFollowsFocus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFollowsFocus<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewSelectionFollowsFocus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFollowsFocus(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShoulderNavigationEnabled<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewShoulderNavigationEnabled) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShoulderNavigationEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShoulderNavigationEnabled<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewShoulderNavigationEnabled) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShoulderNavigationEnabled(value).into()
        }
        unsafe extern "system" fn OverflowLabelMode<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewOverflowLabelMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowLabelMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowLabelMode<Impl: INavigationView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewOverflowLabelMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowLabelMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationView3, BASE_OFFSET>(),
            PaneDisplayMode: PaneDisplayMode::<Impl, IMPL_OFFSET>,
            SetPaneDisplayMode: SetPaneDisplayMode::<Impl, IMPL_OFFSET>,
            PaneHeader: PaneHeader::<Impl, IMPL_OFFSET>,
            SetPaneHeader: SetPaneHeader::<Impl, IMPL_OFFSET>,
            PaneCustomContent: PaneCustomContent::<Impl, IMPL_OFFSET>,
            SetPaneCustomContent: SetPaneCustomContent::<Impl, IMPL_OFFSET>,
            ContentOverlay: ContentOverlay::<Impl, IMPL_OFFSET>,
            SetContentOverlay: SetContentOverlay::<Impl, IMPL_OFFSET>,
            IsPaneVisible: IsPaneVisible::<Impl, IMPL_OFFSET>,
            SetIsPaneVisible: SetIsPaneVisible::<Impl, IMPL_OFFSET>,
            SelectionFollowsFocus: SelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            SetSelectionFollowsFocus: SetSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            ShoulderNavigationEnabled: ShoulderNavigationEnabled::<Impl, IMPL_OFFSET>,
            SetShoulderNavigationEnabled: SetShoulderNavigationEnabled::<Impl, IMPL_OFFSET>,
            OverflowLabelMode: OverflowLabelMode::<Impl, IMPL_OFFSET>,
            SetOverflowLabelMode: SetOverflowLabelMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationView3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewBackRequestedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewBackRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewBackRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewBackRequestedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewBackRequestedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewBackRequestedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewBackRequestedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewBackRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewDisplayModeChangedEventArgsImpl: Sized {
    fn DisplayMode(&mut self) -> ::windows::core::Result<NavigationViewDisplayMode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewDisplayModeChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewDisplayModeChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewDisplayModeChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewDisplayModeChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewDisplayModeChangedEventArgsVtbl {
        unsafe extern "system" fn DisplayMode<Impl: INavigationViewDisplayModeChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewDisplayModeChangedEventArgs, BASE_OFFSET>(),
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewDisplayModeChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemImpl: Sized {
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemVtbl {
        unsafe extern "system" fn Icon<Impl: INavigationViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: INavigationViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: INavigationViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItem, BASE_OFFSET>(),
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
            CompactPaneLength: CompactPaneLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItem2Impl: Sized {
    fn SelectsOnInvoked(&mut self) -> ::windows::core::Result<bool>;
    fn SetSelectsOnInvoked(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItem2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItem2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItem2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItem2Vtbl {
        unsafe extern "system" fn SelectsOnInvoked<Impl: INavigationViewItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectsOnInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectsOnInvoked<Impl: INavigationViewItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectsOnInvoked(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItem2, BASE_OFFSET>(),
            SelectsOnInvoked: SelectsOnInvoked::<Impl, IMPL_OFFSET>,
            SetSelectsOnInvoked: SetSelectsOnInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemBaseImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemBase";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemBaseVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemBaseImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemBaseVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemBase, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemBase as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemBaseFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemBaseFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemBaseFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemBaseFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemBaseFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemBaseFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemHeaderImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemHeader {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemHeader";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemHeaderVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemHeaderImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemHeaderVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemHeader, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemHeader as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemHeaderFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItemHeader>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemHeaderFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemHeaderFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemHeaderFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemHeaderFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemHeaderFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemHeaderFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemHeaderFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemHeaderFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemInvokedEventArgsImpl: Sized {
    fn InvokedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn IsSettingsInvoked(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemInvokedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemInvokedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemInvokedEventArgsVtbl {
        unsafe extern "system" fn InvokedItem<Impl: INavigationViewItemInvokedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsInvoked<Impl: INavigationViewItemInvokedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemInvokedEventArgs, BASE_OFFSET>(),
            InvokedItem: InvokedItem::<Impl, IMPL_OFFSET>,
            IsSettingsInvoked: IsSettingsInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemInvokedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait INavigationViewItemInvokedEventArgs2Impl: Sized {
    fn InvokedItemContainer(&mut self) -> ::windows::core::Result<NavigationViewItemBase>;
    fn RecommendedNavigationTransitionInfo(&mut self) -> ::windows::core::Result<super::Media::Animation::NavigationTransitionInfo>;
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationViewItemInvokedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2";
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl INavigationViewItemInvokedEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemInvokedEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemInvokedEventArgs2Vtbl {
        unsafe extern "system" fn InvokedItemContainer<Impl: INavigationViewItemInvokedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokedItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecommendedNavigationTransitionInfo<Impl: INavigationViewItemInvokedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecommendedNavigationTransitionInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemInvokedEventArgs2, BASE_OFFSET>(),
            InvokedItemContainer: InvokedItemContainer::<Impl, IMPL_OFFSET>,
            RecommendedNavigationTransitionInfo: RecommendedNavigationTransitionInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemInvokedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemSeparatorImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemSeparatorVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemSeparatorImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemSeparatorVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemSeparator, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemSeparator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemSeparatorFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItemSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemSeparatorFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemSeparatorFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemSeparatorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemSeparatorFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemSeparatorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemSeparatorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemStaticsImpl: Sized {
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemStaticsVtbl {
        unsafe extern "system" fn IconProperty<Impl: INavigationViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: INavigationViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemStatics, BASE_OFFSET>(),
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
            CompactPaneLengthProperty: CompactPaneLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemStatics2Impl: Sized {
    fn SelectsOnInvokedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemStatics2Vtbl {
        unsafe extern "system" fn SelectsOnInvokedProperty<Impl: INavigationViewItemStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectsOnInvokedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemStatics2, BASE_OFFSET>(),
            SelectsOnInvokedProperty: SelectsOnInvokedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewListImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewList {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewList";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewListVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewListImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewListVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewList, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewListFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewList>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewListFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewListFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewListFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewListFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewListFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewListFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewListFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewListFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewPaneClosingEventArgsImpl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewPaneClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewPaneClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewPaneClosingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewPaneClosingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewPaneClosingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: INavigationViewPaneClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: INavigationViewPaneClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewPaneClosingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewPaneClosingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewSelectionChangedEventArgsImpl: Sized {
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn IsSettingsSelected(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewSelectionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewSelectionChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewSelectionChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewSelectionChangedEventArgsVtbl {
        unsafe extern "system" fn SelectedItem<Impl: INavigationViewSelectionChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsSelected<Impl: INavigationViewSelectionChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsSelected() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewSelectionChangedEventArgs, BASE_OFFSET>(),
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            IsSettingsSelected: IsSettingsSelected::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewSelectionChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait INavigationViewSelectionChangedEventArgs2Impl: Sized {
    fn SelectedItemContainer(&mut self) -> ::windows::core::Result<NavigationViewItemBase>;
    fn RecommendedNavigationTransitionInfo(&mut self) -> ::windows::core::Result<super::Media::Animation::NavigationTransitionInfo>;
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationViewSelectionChangedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2";
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl INavigationViewSelectionChangedEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewSelectionChangedEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewSelectionChangedEventArgs2Vtbl {
        unsafe extern "system" fn SelectedItemContainer<Impl: INavigationViewSelectionChangedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecommendedNavigationTransitionInfo<Impl: INavigationViewSelectionChangedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecommendedNavigationTransitionInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewSelectionChangedEventArgs2, BASE_OFFSET>(),
            SelectedItemContainer: SelectedItemContainer::<Impl, IMPL_OFFSET>,
            RecommendedNavigationTransitionInfo: RecommendedNavigationTransitionInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewSelectionChangedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStaticsImpl: Sized {
    fn IsPaneOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactModeThresholdWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExpandedModeThresholdWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneFooterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSettingsVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneToggleButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AlwaysShowHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpenPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneToggleButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SettingsItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoSuggestBoxProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemContainerStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemContainerStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewStaticsVtbl {
        unsafe extern "system" fn IsPaneOpenProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactModeThresholdWidthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactModeThresholdWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExpandedModeThresholdWidthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedModeThresholdWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneFooterProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneFooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsVisibleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneToggleButtonVisibleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneToggleButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AlwaysShowHeaderProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlwaysShowHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenPaneLengthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonStyleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsSourceProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SettingsItemProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SettingsItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoSuggestBoxProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoSuggestBoxProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemTemplateProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemTemplateSelectorProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemContainerStyleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemContainerStyleSelectorProperty<Impl: INavigationViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewStatics, BASE_OFFSET>(),
            IsPaneOpenProperty: IsPaneOpenProperty::<Impl, IMPL_OFFSET>,
            CompactModeThresholdWidthProperty: CompactModeThresholdWidthProperty::<Impl, IMPL_OFFSET>,
            ExpandedModeThresholdWidthProperty: ExpandedModeThresholdWidthProperty::<Impl, IMPL_OFFSET>,
            PaneFooterProperty: PaneFooterProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            IsSettingsVisibleProperty: IsSettingsVisibleProperty::<Impl, IMPL_OFFSET>,
            IsPaneToggleButtonVisibleProperty: IsPaneToggleButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            AlwaysShowHeaderProperty: AlwaysShowHeaderProperty::<Impl, IMPL_OFFSET>,
            CompactPaneLengthProperty: CompactPaneLengthProperty::<Impl, IMPL_OFFSET>,
            OpenPaneLengthProperty: OpenPaneLengthProperty::<Impl, IMPL_OFFSET>,
            PaneToggleButtonStyleProperty: PaneToggleButtonStyleProperty::<Impl, IMPL_OFFSET>,
            MenuItemsProperty: MenuItemsProperty::<Impl, IMPL_OFFSET>,
            MenuItemsSourceProperty: MenuItemsSourceProperty::<Impl, IMPL_OFFSET>,
            SelectedItemProperty: SelectedItemProperty::<Impl, IMPL_OFFSET>,
            SettingsItemProperty: SettingsItemProperty::<Impl, IMPL_OFFSET>,
            AutoSuggestBoxProperty: AutoSuggestBoxProperty::<Impl, IMPL_OFFSET>,
            MenuItemTemplateProperty: MenuItemTemplateProperty::<Impl, IMPL_OFFSET>,
            MenuItemTemplateSelectorProperty: MenuItemTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyleProperty: MenuItemContainerStyleProperty::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyleSelectorProperty: MenuItemContainerStyleSelectorProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStatics2Impl: Sized {
    fn IsBackButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsBackEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneTitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewStatics2Vtbl {
        unsafe extern "system" fn IsBackButtonVisibleProperty<Impl: INavigationViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsBackEnabledProperty<Impl: INavigationViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneTitleProperty<Impl: INavigationViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneTitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewStatics2, BASE_OFFSET>(),
            IsBackButtonVisibleProperty: IsBackButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsBackEnabledProperty: IsBackEnabledProperty::<Impl, IMPL_OFFSET>,
            PaneTitleProperty: PaneTitleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStatics3Impl: Sized {
    fn PaneDisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneCustomContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentOverlayProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShoulderNavigationEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowLabelModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewStatics3Vtbl {
        unsafe extern "system" fn PaneDisplayModeProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneDisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneHeaderProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneCustomContentProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneCustomContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentOverlayProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentOverlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneVisibleProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFollowsFocusProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShoulderNavigationEnabledProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShoulderNavigationEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowLabelModeProperty<Impl: INavigationViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowLabelModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewStatics3, BASE_OFFSET>(),
            PaneDisplayModeProperty: PaneDisplayModeProperty::<Impl, IMPL_OFFSET>,
            PaneHeaderProperty: PaneHeaderProperty::<Impl, IMPL_OFFSET>,
            PaneCustomContentProperty: PaneCustomContentProperty::<Impl, IMPL_OFFSET>,
            ContentOverlayProperty: ContentOverlayProperty::<Impl, IMPL_OFFSET>,
            IsPaneVisibleProperty: IsPaneVisibleProperty::<Impl, IMPL_OFFSET>,
            SelectionFollowsFocusProperty: SelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
            TemplateSettingsProperty: TemplateSettingsProperty::<Impl, IMPL_OFFSET>,
            ShoulderNavigationEnabledProperty: ShoulderNavigationEnabledProperty::<Impl, IMPL_OFFSET>,
            OverflowLabelModeProperty: OverflowLabelModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsImpl: Sized {
    fn TopPadding(&mut self) -> ::windows::core::Result<f64>;
    fn OverflowButtonVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn PaneToggleButtonVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn BackButtonVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn TopPaneVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn LeftPaneVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn SingleSelectionFollowsFocus(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettings";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewTemplateSettingsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewTemplateSettingsVtbl {
        unsafe extern "system" fn TopPadding<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackButtonVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopPaneVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPaneVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftPaneVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftPaneVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewTemplateSettings, BASE_OFFSET>(),
            TopPadding: TopPadding::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibility: OverflowButtonVisibility::<Impl, IMPL_OFFSET>,
            PaneToggleButtonVisibility: PaneToggleButtonVisibility::<Impl, IMPL_OFFSET>,
            BackButtonVisibility: BackButtonVisibility::<Impl, IMPL_OFFSET>,
            TopPaneVisibility: TopPaneVisibility::<Impl, IMPL_OFFSET>,
            LeftPaneVisibility: LeftPaneVisibility::<Impl, IMPL_OFFSET>,
            SingleSelectionFollowsFocus: SingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewTemplateSettings as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettingsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewTemplateSettingsFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewTemplateSettingsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewTemplateSettingsFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewTemplateSettingsFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewTemplateSettingsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsStaticsImpl: Sized {
    fn TopPaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneToggleButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopPaneVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftPaneVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SingleSelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettingsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewTemplateSettingsStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewTemplateSettingsStaticsVtbl {
        unsafe extern "system" fn TopPaddingProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopPaneVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPaneVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftPaneVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftPaneVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewTemplateSettingsStatics, BASE_OFFSET>(),
            TopPaddingProperty: TopPaddingProperty::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibilityProperty: OverflowButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            PaneToggleButtonVisibilityProperty: PaneToggleButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            BackButtonVisibilityProperty: BackButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            TopPaneVisibilityProperty: TopPaneVisibilityProperty::<Impl, IMPL_OFFSET>,
            LeftPaneVisibilityProperty: LeftPaneVisibilityProperty::<Impl, IMPL_OFFSET>,
            SingleSelectionFollowsFocusProperty: SingleSelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewTemplateSettingsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INotifyEventArgsImpl: Sized {
    fn Value(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INotifyEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INotifyEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INotifyEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INotifyEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INotifyEventArgsVtbl {
        unsafe extern "system" fn Value<Impl: INotifyEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INotifyEventArgs, BASE_OFFSET>(), Value: Value::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INotifyEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait INotifyEventArgs2Impl: Sized {
    fn CallingUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INotifyEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INotifyEventArgs2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl INotifyEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INotifyEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INotifyEventArgs2Vtbl {
        unsafe extern "system" fn CallingUri<Impl: INotifyEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CallingUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INotifyEventArgs2, BASE_OFFSET>(), CallingUri: CallingUri::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INotifyEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IPageImpl: Sized {
    fn Frame(&mut self) -> ::windows::core::Result<Frame>;
    fn NavigationCacheMode(&mut self) -> ::windows::core::Result<super::Navigation::NavigationCacheMode>;
    fn SetNavigationCacheMode(&mut self, value: super::Navigation::NavigationCacheMode) -> ::windows::core::Result<()>;
    fn TopAppBar(&mut self) -> ::windows::core::Result<AppBar>;
    fn SetTopAppBar(&mut self, value: &::core::option::Option<AppBar>) -> ::windows::core::Result<()>;
    fn BottomAppBar(&mut self) -> ::windows::core::Result<AppBar>;
    fn SetBottomAppBar(&mut self, value: &::core::option::Option<AppBar>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPage {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPage";
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IPageVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPageImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPageVtbl {
        unsafe extern "system" fn Frame<Impl: IPageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Frame() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigationCacheMode<Impl: IPageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Navigation::NavigationCacheMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationCacheMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigationCacheMode<Impl: IPageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Navigation::NavigationCacheMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigationCacheMode(value).into()
        }
        unsafe extern "system" fn TopAppBar<Impl: IPageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopAppBar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopAppBar<Impl: IPageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopAppBar(&*(&value as *const <AppBar as ::windows::core::Abi>::Abi as *const <AppBar as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BottomAppBar<Impl: IPageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomAppBar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBottomAppBar<Impl: IPageImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBottomAppBar(&*(&value as *const <AppBar as ::windows::core::Abi>::Abi as *const <AppBar as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPage, BASE_OFFSET>(),
            Frame: Frame::<Impl, IMPL_OFFSET>,
            NavigationCacheMode: NavigationCacheMode::<Impl, IMPL_OFFSET>,
            SetNavigationCacheMode: SetNavigationCacheMode::<Impl, IMPL_OFFSET>,
            TopAppBar: TopAppBar::<Impl, IMPL_OFFSET>,
            SetTopAppBar: SetTopAppBar::<Impl, IMPL_OFFSET>,
            BottomAppBar: BottomAppBar::<Impl, IMPL_OFFSET>,
            SetBottomAppBar: SetBottomAppBar::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPage as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Page>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPageFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPageFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPageFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPageFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPageFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPageFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPageFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IPageOverridesImpl: Sized {
    fn OnNavigatedFrom(&mut self, e: &::core::option::Option<super::Navigation::NavigationEventArgs>) -> ::windows::core::Result<()>;
    fn OnNavigatedTo(&mut self, e: &::core::option::Option<super::Navigation::NavigationEventArgs>) -> ::windows::core::Result<()>;
    fn OnNavigatingFrom(&mut self, e: &::core::option::Option<super::Navigation::NavigatingCancelEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPageOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageOverrides";
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IPageOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPageOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPageOverridesVtbl {
        unsafe extern "system" fn OnNavigatedFrom<Impl: IPageOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnNavigatedFrom(&*(&e as *const <super::Navigation::NavigationEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnNavigatedTo<Impl: IPageOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnNavigatedTo(&*(&e as *const <super::Navigation::NavigationEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnNavigatingFrom<Impl: IPageOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnNavigatingFrom(&*(&e as *const <super::Navigation::NavigatingCancelEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatingCancelEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPageOverrides, BASE_OFFSET>(),
            OnNavigatedFrom: OnNavigatedFrom::<Impl, IMPL_OFFSET>,
            OnNavigatedTo: OnNavigatedTo::<Impl, IMPL_OFFSET>,
            OnNavigatingFrom: OnNavigatingFrom::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPageOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageStaticsImpl: Sized {
    fn FrameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopAppBarProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BottomAppBarProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPageStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPageStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPageStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPageStaticsVtbl {
        unsafe extern "system" fn FrameProperty<Impl: IPageStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopAppBarProperty<Impl: IPageStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopAppBarProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BottomAppBarProperty<Impl: IPageStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomAppBarProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPageStatics, BASE_OFFSET>(),
            FrameProperty: FrameProperty::<Impl, IMPL_OFFSET>,
            TopAppBarProperty: TopAppBarProperty::<Impl, IMPL_OFFSET>,
            BottomAppBarProperty: BottomAppBarProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPageStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IPanelImpl: Sized {
    fn Children(&mut self) -> ::windows::core::Result<UIElementCollection>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IsItemsHost(&mut self) -> ::windows::core::Result<bool>;
    fn ChildrenTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetChildrenTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanel";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanelVtbl {
        unsafe extern "system" fn Children<Impl: IPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Background<Impl: IPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsItemsHost<Impl: IPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemsHost() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenTransitions<Impl: IPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildrenTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChildrenTransitions<Impl: IPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChildrenTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPanel, BASE_OFFSET>(),
            Children: Children::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            IsItemsHost: IsItemsHost::<Impl, IMPL_OFFSET>,
            ChildrenTransitions: ChildrenTransitions::<Impl, IMPL_OFFSET>,
            SetChildrenTransitions: SetChildrenTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanel2Impl: Sized {
    fn BackgroundTransition(&mut self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&mut self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IPanel2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanel2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanel2Vtbl {
        unsafe extern "system" fn BackgroundTransition<Impl: IPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPanel2, BASE_OFFSET>(),
            BackgroundTransition: BackgroundTransition::<Impl, IMPL_OFFSET>,
            SetBackgroundTransition: SetBackgroundTransition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanelFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Panel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPanelFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanelFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPanelFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPanelFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanelStaticsImpl: Sized {
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsItemsHostProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildrenTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPanelStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanelStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanelStaticsVtbl {
        unsafe extern "system" fn BackgroundProperty<Impl: IPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsItemsHostProperty<Impl: IPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemsHostProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenTransitionsProperty<Impl: IPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildrenTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPanelStatics, BASE_OFFSET>(),
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            IsItemsHostProperty: IsItemsHostProperty::<Impl, IMPL_OFFSET>,
            ChildrenTransitionsProperty: ChildrenTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewImpl: Sized {
    fn Child(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn HorizontalShift(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalShift(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn HorizontalSourceEndOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalSourceEndOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn HorizontalSourceOffsetKind(&mut self) -> ::windows::core::Result<ParallaxSourceOffsetKind>;
    fn SetHorizontalSourceOffsetKind(&mut self, value: ParallaxSourceOffsetKind) -> ::windows::core::Result<()>;
    fn HorizontalSourceStartOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalSourceStartOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsHorizontalShiftClamped(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalShiftClamped(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalShiftClamped(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalShiftClamped(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxHorizontalShiftRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxHorizontalShiftRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MaxVerticalShiftRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxVerticalShiftRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Source(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetSource(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn VerticalShift(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalShift(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalSourceEndOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalSourceEndOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalSourceOffsetKind(&mut self) -> ::windows::core::Result<ParallaxSourceOffsetKind>;
    fn SetVerticalSourceOffsetKind(&mut self, value: ParallaxSourceOffsetKind) -> ::windows::core::Result<()>;
    fn VerticalSourceStartOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalSourceStartOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn RefreshAutomaticHorizontalOffsets(&mut self) -> ::windows::core::Result<()>;
    fn RefreshAutomaticVerticalOffsets(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxView";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IParallaxViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IParallaxViewVtbl {
        unsafe extern "system" fn Child<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalShift<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalShift() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalShift<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalShift(value).into()
        }
        unsafe extern "system" fn HorizontalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceEndOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceEndOffset(value).into()
        }
        unsafe extern "system" fn HorizontalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceOffsetKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceOffsetKind(value).into()
        }
        unsafe extern "system" fn HorizontalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceStartOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceStartOffset(value).into()
        }
        unsafe extern "system" fn IsHorizontalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalShiftClamped() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalShiftClamped(value).into()
        }
        unsafe extern "system" fn IsVerticalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalShiftClamped() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalShiftClamped(value).into()
        }
        unsafe extern "system" fn MaxHorizontalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHorizontalShiftRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHorizontalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxHorizontalShiftRatio(value).into()
        }
        unsafe extern "system" fn MaxVerticalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxVerticalShiftRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxVerticalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxVerticalShiftRatio(value).into()
        }
        unsafe extern "system" fn Source<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VerticalShift<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalShift() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalShift<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalShift(value).into()
        }
        unsafe extern "system" fn VerticalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceEndOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceEndOffset(value).into()
        }
        unsafe extern "system" fn VerticalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceOffsetKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceOffsetKind(value).into()
        }
        unsafe extern "system" fn VerticalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceStartOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceStartOffset(value).into()
        }
        unsafe extern "system" fn RefreshAutomaticHorizontalOffsets<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RefreshAutomaticHorizontalOffsets().into()
        }
        unsafe extern "system" fn RefreshAutomaticVerticalOffsets<Impl: IParallaxViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RefreshAutomaticVerticalOffsets().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IParallaxView, BASE_OFFSET>(),
            Child: Child::<Impl, IMPL_OFFSET>,
            SetChild: SetChild::<Impl, IMPL_OFFSET>,
            HorizontalShift: HorizontalShift::<Impl, IMPL_OFFSET>,
            SetHorizontalShift: SetHorizontalShift::<Impl, IMPL_OFFSET>,
            HorizontalSourceEndOffset: HorizontalSourceEndOffset::<Impl, IMPL_OFFSET>,
            SetHorizontalSourceEndOffset: SetHorizontalSourceEndOffset::<Impl, IMPL_OFFSET>,
            HorizontalSourceOffsetKind: HorizontalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            SetHorizontalSourceOffsetKind: SetHorizontalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            HorizontalSourceStartOffset: HorizontalSourceStartOffset::<Impl, IMPL_OFFSET>,
            SetHorizontalSourceStartOffset: SetHorizontalSourceStartOffset::<Impl, IMPL_OFFSET>,
            IsHorizontalShiftClamped: IsHorizontalShiftClamped::<Impl, IMPL_OFFSET>,
            SetIsHorizontalShiftClamped: SetIsHorizontalShiftClamped::<Impl, IMPL_OFFSET>,
            IsVerticalShiftClamped: IsVerticalShiftClamped::<Impl, IMPL_OFFSET>,
            SetIsVerticalShiftClamped: SetIsVerticalShiftClamped::<Impl, IMPL_OFFSET>,
            MaxHorizontalShiftRatio: MaxHorizontalShiftRatio::<Impl, IMPL_OFFSET>,
            SetMaxHorizontalShiftRatio: SetMaxHorizontalShiftRatio::<Impl, IMPL_OFFSET>,
            MaxVerticalShiftRatio: MaxVerticalShiftRatio::<Impl, IMPL_OFFSET>,
            SetMaxVerticalShiftRatio: SetMaxVerticalShiftRatio::<Impl, IMPL_OFFSET>,
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            VerticalShift: VerticalShift::<Impl, IMPL_OFFSET>,
            SetVerticalShift: SetVerticalShift::<Impl, IMPL_OFFSET>,
            VerticalSourceEndOffset: VerticalSourceEndOffset::<Impl, IMPL_OFFSET>,
            SetVerticalSourceEndOffset: SetVerticalSourceEndOffset::<Impl, IMPL_OFFSET>,
            VerticalSourceOffsetKind: VerticalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            SetVerticalSourceOffsetKind: SetVerticalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            VerticalSourceStartOffset: VerticalSourceStartOffset::<Impl, IMPL_OFFSET>,
            SetVerticalSourceStartOffset: SetVerticalSourceStartOffset::<Impl, IMPL_OFFSET>,
            RefreshAutomaticHorizontalOffsets: RefreshAutomaticHorizontalOffsets::<Impl, IMPL_OFFSET>,
            RefreshAutomaticVerticalOffsets: RefreshAutomaticVerticalOffsets::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IParallaxView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ParallaxView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IParallaxViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IParallaxViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IParallaxViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IParallaxViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IParallaxViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewStaticsImpl: Sized {
    fn ChildProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceEndOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceOffsetKindProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceStartOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHorizontalShiftRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalShiftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHorizontalShiftClampedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVerticalShiftClampedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceEndOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceOffsetKindProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceStartOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxVerticalShiftRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalShiftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IParallaxViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IParallaxViewStaticsVtbl {
        unsafe extern "system" fn ChildProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceEndOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceEndOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceOffsetKindProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceOffsetKindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceStartOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceStartOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHorizontalShiftRatioProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHorizontalShiftRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalShiftProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalShiftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHorizontalShiftClampedProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalShiftClampedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVerticalShiftClampedProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalShiftClampedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceEndOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceEndOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceOffsetKindProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceOffsetKindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceStartOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceStartOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxVerticalShiftRatioProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxVerticalShiftRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalShiftProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalShiftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IParallaxViewStatics, BASE_OFFSET>(),
            ChildProperty: ChildProperty::<Impl, IMPL_OFFSET>,
            HorizontalSourceEndOffsetProperty: HorizontalSourceEndOffsetProperty::<Impl, IMPL_OFFSET>,
            HorizontalSourceOffsetKindProperty: HorizontalSourceOffsetKindProperty::<Impl, IMPL_OFFSET>,
            HorizontalSourceStartOffsetProperty: HorizontalSourceStartOffsetProperty::<Impl, IMPL_OFFSET>,
            MaxHorizontalShiftRatioProperty: MaxHorizontalShiftRatioProperty::<Impl, IMPL_OFFSET>,
            HorizontalShiftProperty: HorizontalShiftProperty::<Impl, IMPL_OFFSET>,
            IsHorizontalShiftClampedProperty: IsHorizontalShiftClampedProperty::<Impl, IMPL_OFFSET>,
            IsVerticalShiftClampedProperty: IsVerticalShiftClampedProperty::<Impl, IMPL_OFFSET>,
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            VerticalSourceEndOffsetProperty: VerticalSourceEndOffsetProperty::<Impl, IMPL_OFFSET>,
            VerticalSourceOffsetKindProperty: VerticalSourceOffsetKindProperty::<Impl, IMPL_OFFSET>,
            VerticalSourceStartOffsetProperty: VerticalSourceStartOffsetProperty::<Impl, IMPL_OFFSET>,
            MaxVerticalShiftRatioProperty: MaxVerticalShiftRatioProperty::<Impl, IMPL_OFFSET>,
            VerticalShiftProperty: VerticalShiftProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IParallaxViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPasswordBoxImpl: Sized {
    fn Password(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPassword(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PasswordChar(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPasswordChar(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsPasswordRevealButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPasswordRevealButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn PasswordChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePasswordChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPasswordBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxVtbl {
        unsafe extern "system" fn Password<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Password() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPassword<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPassword(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PasswordChar<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordChar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPasswordChar<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPasswordChar(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPasswordRevealButtonEnabled<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPasswordRevealButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPasswordRevealButtonEnabled<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPasswordRevealButtonEnabled(value).into()
        }
        unsafe extern "system" fn MaxLength<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        unsafe extern "system" fn PasswordChanged<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePasswordChanged<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePasswordChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IPasswordBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox, BASE_OFFSET>(),
            Password: Password::<Impl, IMPL_OFFSET>,
            SetPassword: SetPassword::<Impl, IMPL_OFFSET>,
            PasswordChar: PasswordChar::<Impl, IMPL_OFFSET>,
            SetPasswordChar: SetPasswordChar::<Impl, IMPL_OFFSET>,
            IsPasswordRevealButtonEnabled: IsPasswordRevealButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsPasswordRevealButtonEnabled: SetIsPasswordRevealButtonEnabled::<Impl, IMPL_OFFSET>,
            MaxLength: MaxLength::<Impl, IMPL_OFFSET>,
            SetMaxLength: SetMaxLength::<Impl, IMPL_OFFSET>,
            PasswordChanged: PasswordChanged::<Impl, IMPL_OFFSET>,
            RemovePasswordChanged: RemovePasswordChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPasswordBox2Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&mut self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPasswordBox2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox2Vtbl {
        unsafe extern "system" fn Header<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn Paste<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: IPasswordBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus: PreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus: SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            Paste: Paste::<Impl, IMPL_OFFSET>,
            RemovePaste: RemovePaste::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IPasswordBox3Impl: Sized {
    fn PasswordRevealMode(&mut self) -> ::windows::core::Result<PasswordRevealMode>;
    fn SetPasswordRevealMode(&mut self, value: PasswordRevealMode) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn InputScope(&mut self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&mut self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox3";
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IPasswordBox3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox3Vtbl {
        unsafe extern "system" fn PasswordRevealMode<Impl: IPasswordBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PasswordRevealMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordRevealMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPasswordRevealMode<Impl: IPasswordBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: PasswordRevealMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPasswordRevealMode(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IPasswordBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IPasswordBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn InputScope<Impl: IPasswordBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: IPasswordBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox3, BASE_OFFSET>(),
            PasswordRevealMode: PasswordRevealMode::<Impl, IMPL_OFFSET>,
            SetPasswordRevealMode: SetPasswordRevealMode::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
            InputScope: InputScope::<Impl, IMPL_OFFSET>,
            SetInputScope: SetInputScope::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPasswordBox4Impl: Sized {
    fn PasswordChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePasswordChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPasswordBox4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox4Vtbl {
        unsafe extern "system" fn PasswordChanging<Impl: IPasswordBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePasswordChanging<Impl: IPasswordBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePasswordChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox4, BASE_OFFSET>(),
            PasswordChanging: PasswordChanging::<Impl, IMPL_OFFSET>,
            RemovePasswordChanging: RemovePasswordChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IPasswordBox5Impl: Sized {
    fn CanPasteClipboardContent(&mut self) -> ::windows::core::Result<bool>;
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PasteFromClipboard(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox5";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IPasswordBox5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox5Vtbl {
        unsafe extern "system" fn CanPasteClipboardContent<Impl: IPasswordBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: IPasswordBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IPasswordBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Description<Impl: IPasswordBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IPasswordBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PasteFromClipboard<Impl: IPasswordBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PasteFromClipboard().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox5, BASE_OFFSET>(),
            CanPasteClipboardContent: CanPasteClipboardContent::<Impl, IMPL_OFFSET>,
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            PasteFromClipboard: PasteFromClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxPasswordChangingEventArgsImpl: Sized {
    fn IsContentChanging(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxPasswordChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxPasswordChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxPasswordChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxPasswordChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxPasswordChangingEventArgsVtbl {
        unsafe extern "system" fn IsContentChanging<Impl: IPasswordBoxPasswordChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxPasswordChangingEventArgs, BASE_OFFSET>(),
            IsContentChanging: IsContentChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxPasswordChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStaticsImpl: Sized {
    fn PasswordProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PasswordCharProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPasswordRevealButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStaticsVtbl {
        unsafe extern "system" fn PasswordProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PasswordCharProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordCharProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPasswordRevealButtonEnabledProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPasswordRevealButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics, BASE_OFFSET>(),
            PasswordProperty: PasswordProperty::<Impl, IMPL_OFFSET>,
            PasswordCharProperty: PasswordCharProperty::<Impl, IMPL_OFFSET>,
            IsPasswordRevealButtonEnabledProperty: IsPasswordRevealButtonEnabledProperty::<Impl, IMPL_OFFSET>,
            MaxLengthProperty: MaxLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics2Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocusProperty: PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics3Impl: Sized {
    fn PasswordRevealModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStatics3Vtbl {
        unsafe extern "system" fn PasswordRevealModeProperty<Impl: IPasswordBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordRevealModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IPasswordBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: IPasswordBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics3, BASE_OFFSET>(),
            PasswordRevealModeProperty: PasswordRevealModeProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
            InputScopeProperty: InputScopeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics5Impl: Sized {
    fn CanPasteClipboardContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStatics5Vtbl {
        unsafe extern "system" fn CanPasteClipboardContentProperty<Impl: IPasswordBoxStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IPasswordBoxStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IPasswordBoxStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics5, BASE_OFFSET>(),
            CanPasteClipboardContentProperty: CanPasteClipboardContentProperty::<Impl, IMPL_OFFSET>,
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPathIconImpl: Sized {
    fn Data(&mut self) -> ::windows::core::Result<super::Media::Geometry>;
    fn SetData(&mut self, value: &::core::option::Option<super::Media::Geometry>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPathIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIcon";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPathIconVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconVtbl {
        unsafe extern "system" fn Data<Impl: IPathIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetData<Impl: IPathIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetData(&*(&value as *const <super::Media::Geometry as ::windows::core::Abi>::Abi as *const <super::Media::Geometry as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIcon, BASE_OFFSET>(),
            Data: Data::<Impl, IMPL_OFFSET>,
            SetData: SetData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PathIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPathIconFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPathIconSourceImpl: Sized {
    fn Data(&mut self) -> ::windows::core::Result<super::Media::Geometry>;
    fn SetData(&mut self, value: &::core::option::Option<super::Media::Geometry>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPathIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSource";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPathIconSourceVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconSourceImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconSourceVtbl {
        unsafe extern "system" fn Data<Impl: IPathIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetData<Impl: IPathIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetData(&*(&value as *const <super::Media::Geometry as ::windows::core::Abi>::Abi as *const <super::Media::Geometry as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconSource, BASE_OFFSET>(),
            Data: Data::<Impl, IMPL_OFFSET>,
            SetData: SetData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconSourceFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PathIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconSourceFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconSourceFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPathIconSourceFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconSourceStaticsImpl: Sized {
    fn DataProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconSourceStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconSourceStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconSourceStaticsVtbl {
        unsafe extern "system" fn DataProperty<Impl: IPathIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconSourceStatics, BASE_OFFSET>(), DataProperty: DataProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconStaticsImpl: Sized {
    fn DataProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconStaticsVtbl {
        unsafe extern "system" fn DataProperty<Impl: IPathIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconStatics, BASE_OFFSET>(), DataProperty: DataProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Contacts", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPersonPictureImpl: Sized {
    fn BadgeNumber(&mut self) -> ::windows::core::Result<i32>;
    fn SetBadgeNumber(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn BadgeGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetBadgeGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn BadgeImageSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetBadgeImageSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn BadgeText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetBadgeText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsGroup(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsGroup(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Contact(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Contacts::Contact>;
    fn SetContact(&mut self, value: &::core::option::Option<super::super::super::ApplicationModel::Contacts::Contact>) -> ::windows::core::Result<()>;
    fn DisplayName(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayName(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Initials(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetInitials(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PreferSmallImage(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreferSmallImage(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ProfilePicture(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetProfilePicture(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "ApplicationModel_Contacts", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPersonPicture {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPicture";
}
#[cfg(all(feature = "ApplicationModel_Contacts", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPersonPictureVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersonPictureImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersonPictureVtbl {
        unsafe extern "system" fn BadgeNumber<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeNumber<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeNumber(value).into()
        }
        unsafe extern "system" fn BadgeGlyph<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeGlyph<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BadgeImageSource<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeImageSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeImageSource<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeImageSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BadgeText<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeText<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGroup<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroup() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroup<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsGroup(value).into()
        }
        unsafe extern "system" fn Contact<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Contact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContact<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContact(&*(&value as *const <super::super::super::ApplicationModel::Contacts::Contact as ::windows::core::Abi>::Abi as *const <super::super::super::ApplicationModel::Contacts::Contact as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayName<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayName<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Initials<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Initials() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitials<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInitials(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreferSmallImage<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreferSmallImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreferSmallImage<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreferSmallImage(value).into()
        }
        unsafe extern "system" fn ProfilePicture<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProfilePicture() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProfilePicture<Impl: IPersonPictureImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProfilePicture(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPersonPicture, BASE_OFFSET>(),
            BadgeNumber: BadgeNumber::<Impl, IMPL_OFFSET>,
            SetBadgeNumber: SetBadgeNumber::<Impl, IMPL_OFFSET>,
            BadgeGlyph: BadgeGlyph::<Impl, IMPL_OFFSET>,
            SetBadgeGlyph: SetBadgeGlyph::<Impl, IMPL_OFFSET>,
            BadgeImageSource: BadgeImageSource::<Impl, IMPL_OFFSET>,
            SetBadgeImageSource: SetBadgeImageSource::<Impl, IMPL_OFFSET>,
            BadgeText: BadgeText::<Impl, IMPL_OFFSET>,
            SetBadgeText: SetBadgeText::<Impl, IMPL_OFFSET>,
            IsGroup: IsGroup::<Impl, IMPL_OFFSET>,
            SetIsGroup: SetIsGroup::<Impl, IMPL_OFFSET>,
            Contact: Contact::<Impl, IMPL_OFFSET>,
            SetContact: SetContact::<Impl, IMPL_OFFSET>,
            DisplayName: DisplayName::<Impl, IMPL_OFFSET>,
            SetDisplayName: SetDisplayName::<Impl, IMPL_OFFSET>,
            Initials: Initials::<Impl, IMPL_OFFSET>,
            SetInitials: SetInitials::<Impl, IMPL_OFFSET>,
            PreferSmallImage: PreferSmallImage::<Impl, IMPL_OFFSET>,
            SetPreferSmallImage: SetPreferSmallImage::<Impl, IMPL_OFFSET>,
            ProfilePicture: ProfilePicture::<Impl, IMPL_OFFSET>,
            SetProfilePicture: SetProfilePicture::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersonPicture as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPersonPictureFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PersonPicture>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPersonPictureFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPictureFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPersonPictureFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersonPictureFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersonPictureFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPersonPictureFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPersonPictureFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersonPictureFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPersonPictureStaticsImpl: Sized {
    fn BadgeNumberProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeImageSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayNameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InitialsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreferSmallImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProfilePictureProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPersonPictureStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPictureStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPersonPictureStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersonPictureStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersonPictureStaticsVtbl {
        unsafe extern "system" fn BadgeNumberProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeNumberProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeGlyphProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeImageSourceProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeImageSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeTextProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContactProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayNameProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitialsProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreferSmallImageProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreferSmallImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProfilePictureProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProfilePictureProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPersonPictureStatics, BASE_OFFSET>(),
            BadgeNumberProperty: BadgeNumberProperty::<Impl, IMPL_OFFSET>,
            BadgeGlyphProperty: BadgeGlyphProperty::<Impl, IMPL_OFFSET>,
            BadgeImageSourceProperty: BadgeImageSourceProperty::<Impl, IMPL_OFFSET>,
            BadgeTextProperty: BadgeTextProperty::<Impl, IMPL_OFFSET>,
            IsGroupProperty: IsGroupProperty::<Impl, IMPL_OFFSET>,
            ContactProperty: ContactProperty::<Impl, IMPL_OFFSET>,
            DisplayNameProperty: DisplayNameProperty::<Impl, IMPL_OFFSET>,
            InitialsProperty: InitialsProperty::<Impl, IMPL_OFFSET>,
            PreferSmallImageProperty: PreferSmallImageProperty::<Impl, IMPL_OFFSET>,
            ProfilePictureProperty: ProfilePictureProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersonPictureStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerConfirmedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerConfirmedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerConfirmedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerConfirmedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerConfirmedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerConfirmedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerConfirmedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerConfirmedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPickerFlyoutImpl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ConfirmationButtonsVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetConfirmationButtonsVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Confirmed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveConfirmed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<bool>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPickerFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerFlyoutVtbl {
        unsafe extern "system" fn Content<Impl: IPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ConfirmationButtonsVisible<Impl: IPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfirmationButtonsVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfirmationButtonsVisible<Impl: IPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConfirmationButtonsVisible(value).into()
        }
        unsafe extern "system" fn Confirmed<Impl: IPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Confirmed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveConfirmed<Impl: IPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveConfirmed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IPickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerFlyout, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            ConfirmationButtonsVisible: ConfirmationButtonsVisible::<Impl, IMPL_OFFSET>,
            SetConfirmationButtonsVisible: SetConfirmationButtonsVisible::<Impl, IMPL_OFFSET>,
            Confirmed: Confirmed::<Impl, IMPL_OFFSET>,
            RemoveConfirmed: RemoveConfirmed::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerFlyoutPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerFlyoutPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerFlyoutPresenterVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerFlyoutStaticsImpl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ConfirmationButtonsVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerFlyoutStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerFlyoutStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerFlyoutStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfirmationButtonsVisibleProperty<Impl: IPickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfirmationButtonsVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerFlyoutStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            ConfirmationButtonsVisibleProperty: ConfirmationButtonsVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPivotImpl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetTitle(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TitleTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetTitleTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn SelectedIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectedIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn IsLocked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsLocked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<SelectionChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemLoading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemLoading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemLoaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemLoaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemUnloading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemUnloading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemUnloaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemUnloaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPivot {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPivotVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotVtbl {
        unsafe extern "system" fn Title<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TitleTemplate<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitleTemplate<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitleTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedIndex<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedIndex<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedIndex(value).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsLocked<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsLocked<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsLocked(value).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <SelectionChangedEventHandler as ::windows::core::Abi>::Abi as *const <SelectionChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemLoading<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemLoading<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemLoaded<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemLoaded<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemUnloading<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemUnloading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemUnloading<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemUnloading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemUnloaded<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemUnloaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemUnloaded<Impl: IPivotImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemUnloaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivot, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            TitleTemplate: TitleTemplate::<Impl, IMPL_OFFSET>,
            SetTitleTemplate: SetTitleTemplate::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            SelectedIndex: SelectedIndex::<Impl, IMPL_OFFSET>,
            SetSelectedIndex: SetSelectedIndex::<Impl, IMPL_OFFSET>,
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            SetSelectedItem: SetSelectedItem::<Impl, IMPL_OFFSET>,
            IsLocked: IsLocked::<Impl, IMPL_OFFSET>,
            SetIsLocked: SetIsLocked::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            PivotItemLoading: PivotItemLoading::<Impl, IMPL_OFFSET>,
            RemovePivotItemLoading: RemovePivotItemLoading::<Impl, IMPL_OFFSET>,
            PivotItemLoaded: PivotItemLoaded::<Impl, IMPL_OFFSET>,
            RemovePivotItemLoaded: RemovePivotItemLoaded::<Impl, IMPL_OFFSET>,
            PivotItemUnloading: PivotItemUnloading::<Impl, IMPL_OFFSET>,
            RemovePivotItemUnloading: RemovePivotItemUnloading::<Impl, IMPL_OFFSET>,
            PivotItemUnloaded: PivotItemUnloaded::<Impl, IMPL_OFFSET>,
            RemovePivotItemUnloaded: RemovePivotItemUnloaded::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivot as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivot2Impl: Sized {
    fn LeftHeader(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetLeftHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn LeftHeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetLeftHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn RightHeader(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetRightHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn RightHeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetRightHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivot2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot2";
}
#[cfg(feature = "implement_exclusive")]
impl IPivot2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivot2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivot2Vtbl {
        unsafe extern "system" fn LeftHeader<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeader<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LeftHeaderTemplate<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeaderTemplate<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightHeader<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightHeader<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightHeaderTemplate<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightHeaderTemplate<Impl: IPivot2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivot2, BASE_OFFSET>(),
            LeftHeader: LeftHeader::<Impl, IMPL_OFFSET>,
            SetLeftHeader: SetLeftHeader::<Impl, IMPL_OFFSET>,
            LeftHeaderTemplate: LeftHeaderTemplate::<Impl, IMPL_OFFSET>,
            SetLeftHeaderTemplate: SetLeftHeaderTemplate::<Impl, IMPL_OFFSET>,
            RightHeader: RightHeader::<Impl, IMPL_OFFSET>,
            SetRightHeader: SetRightHeader::<Impl, IMPL_OFFSET>,
            RightHeaderTemplate: RightHeaderTemplate::<Impl, IMPL_OFFSET>,
            SetRightHeaderTemplate: SetRightHeaderTemplate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivot2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivot3Impl: Sized {
    fn HeaderFocusVisualPlacement(&mut self) -> ::windows::core::Result<PivotHeaderFocusVisualPlacement>;
    fn SetHeaderFocusVisualPlacement(&mut self, value: PivotHeaderFocusVisualPlacement) -> ::windows::core::Result<()>;
    fn IsHeaderItemsCarouselEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHeaderItemsCarouselEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivot3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot3";
}
#[cfg(feature = "implement_exclusive")]
impl IPivot3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivot3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivot3Vtbl {
        unsafe extern "system" fn HeaderFocusVisualPlacement<Impl: IPivot3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PivotHeaderFocusVisualPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderFocusVisualPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderFocusVisualPlacement<Impl: IPivot3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: PivotHeaderFocusVisualPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderFocusVisualPlacement(value).into()
        }
        unsafe extern "system" fn IsHeaderItemsCarouselEnabled<Impl: IPivot3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderItemsCarouselEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHeaderItemsCarouselEnabled<Impl: IPivot3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHeaderItemsCarouselEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivot3, BASE_OFFSET>(),
            HeaderFocusVisualPlacement: HeaderFocusVisualPlacement::<Impl, IMPL_OFFSET>,
            SetHeaderFocusVisualPlacement: SetHeaderFocusVisualPlacement::<Impl, IMPL_OFFSET>,
            IsHeaderItemsCarouselEnabled: IsHeaderItemsCarouselEnabled::<Impl, IMPL_OFFSET>,
            SetIsHeaderItemsCarouselEnabled: SetIsHeaderItemsCarouselEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivot3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Pivot>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPivotFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemImpl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItem";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItemVtbl {
        unsafe extern "system" fn Header<Impl: IPivotItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IPivotItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItem, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemEventArgsImpl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<PivotItem>;
    fn SetItem(&mut self, value: &::core::option::Option<PivotItem>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItemEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItemEventArgsVtbl {
        unsafe extern "system" fn Item<Impl: IPivotItemEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IPivotItemEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(&*(&value as *const <PivotItem as ::windows::core::Abi>::Abi as *const <PivotItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItemEventArgs, BASE_OFFSET>(),
            Item: Item::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItemEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PivotItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPivotItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItemFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemStaticsImpl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItemStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IPivotItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItemStatics, BASE_OFFSET>(), HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStaticsImpl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TitleTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsLockedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SlideInAnimationGroupProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetSlideInAnimationGroup(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<PivotSlideInAnimationGroup>;
    fn SetSlideInAnimationGroup(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: PivotSlideInAnimationGroup) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitleTemplateProperty<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedIndexProperty<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsLockedProperty<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLockedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SlideInAnimationGroupProperty<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SlideInAnimationGroupProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSlideInAnimationGroup<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut PivotSlideInAnimationGroup) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSlideInAnimationGroup(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSlideInAnimationGroup<Impl: IPivotStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: PivotSlideInAnimationGroup) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSlideInAnimationGroup(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            TitleTemplateProperty: TitleTemplateProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            SelectedIndexProperty: SelectedIndexProperty::<Impl, IMPL_OFFSET>,
            SelectedItemProperty: SelectedItemProperty::<Impl, IMPL_OFFSET>,
            IsLockedProperty: IsLockedProperty::<Impl, IMPL_OFFSET>,
            SlideInAnimationGroupProperty: SlideInAnimationGroupProperty::<Impl, IMPL_OFFSET>,
            GetSlideInAnimationGroup: GetSlideInAnimationGroup::<Impl, IMPL_OFFSET>,
            SetSlideInAnimationGroup: SetSlideInAnimationGroup::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStatics2Impl: Sized {
    fn LeftHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftHeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightHeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotStatics2Vtbl {
        unsafe extern "system" fn LeftHeaderProperty<Impl: IPivotStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftHeaderTemplateProperty<Impl: IPivotStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightHeaderProperty<Impl: IPivotStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightHeaderTemplateProperty<Impl: IPivotStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotStatics2, BASE_OFFSET>(),
            LeftHeaderProperty: LeftHeaderProperty::<Impl, IMPL_OFFSET>,
            LeftHeaderTemplateProperty: LeftHeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            RightHeaderProperty: RightHeaderProperty::<Impl, IMPL_OFFSET>,
            RightHeaderTemplateProperty: RightHeaderTemplateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStatics3Impl: Sized {
    fn HeaderFocusVisualPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHeaderItemsCarouselEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotStatics3Vtbl {
        unsafe extern "system" fn HeaderFocusVisualPlacementProperty<Impl: IPivotStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderFocusVisualPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHeaderItemsCarouselEnabledProperty<Impl: IPivotStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderItemsCarouselEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotStatics3, BASE_OFFSET>(),
            HeaderFocusVisualPlacementProperty: HeaderFocusVisualPlacementProperty::<Impl, IMPL_OFFSET>,
            IsHeaderItemsCarouselEnabledProperty: IsHeaderItemsCarouselEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IProgressBarImpl: Sized {
    fn IsIndeterminate(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsIndeterminate(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ShowError(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowError(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ShowPaused(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowPaused(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ProgressBarTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IProgressBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBar";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IProgressBarVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressBarImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressBarVtbl {
        unsafe extern "system" fn IsIndeterminate<Impl: IProgressBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIndeterminate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsIndeterminate<Impl: IProgressBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsIndeterminate(value).into()
        }
        unsafe extern "system" fn ShowError<Impl: IProgressBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowError() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowError<Impl: IProgressBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowError(value).into()
        }
        unsafe extern "system" fn ShowPaused<Impl: IProgressBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowPaused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowPaused<Impl: IProgressBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowPaused(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IProgressBarImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressBar, BASE_OFFSET>(),
            IsIndeterminate: IsIndeterminate::<Impl, IMPL_OFFSET>,
            SetIsIndeterminate: SetIsIndeterminate::<Impl, IMPL_OFFSET>,
            ShowError: ShowError::<Impl, IMPL_OFFSET>,
            SetShowError: SetShowError::<Impl, IMPL_OFFSET>,
            ShowPaused: ShowPaused::<Impl, IMPL_OFFSET>,
            SetShowPaused: SetShowPaused::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressBar as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressBarFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ProgressBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressBarFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressBarFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IProgressBarFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressBarFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressBarStaticsImpl: Sized {
    fn IsIndeterminateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowErrorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowPausedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressBarStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressBarStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressBarStaticsVtbl {
        unsafe extern "system" fn IsIndeterminateProperty<Impl: IProgressBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIndeterminateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowErrorProperty<Impl: IProgressBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowErrorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowPausedProperty<Impl: IProgressBarStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowPausedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressBarStatics, BASE_OFFSET>(),
            IsIndeterminateProperty: IsIndeterminateProperty::<Impl, IMPL_OFFSET>,
            ShowErrorProperty: ShowErrorProperty::<Impl, IMPL_OFFSET>,
            ShowPausedProperty: ShowPausedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IProgressRingImpl: Sized {
    fn IsActive(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsActive(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ProgressRingTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IProgressRing {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressRing";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IProgressRingVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressRingImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressRingVtbl {
        unsafe extern "system" fn IsActive<Impl: IProgressRingImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsActive<Impl: IProgressRingImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsActive(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IProgressRingImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressRing, BASE_OFFSET>(),
            IsActive: IsActive::<Impl, IMPL_OFFSET>,
            SetIsActive: SetIsActive::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressRing as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressRingStaticsImpl: Sized {
    fn IsActiveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressRingStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressRingStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressRingStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressRingStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressRingStaticsVtbl {
        unsafe extern "system" fn IsActiveProperty<Impl: IProgressRingStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressRingStatics, BASE_OFFSET>(),
            IsActiveProperty: IsActiveProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressRingStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonImpl: Sized {
    fn GroupName(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGroupName(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButton";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRadioButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRadioButtonVtbl {
        unsafe extern "system" fn GroupName<Impl: IRadioButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupName<Impl: IRadioButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRadioButton, BASE_OFFSET>(),
            GroupName: GroupName::<Impl, IMPL_OFFSET>,
            SetGroupName: SetGroupName::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRadioButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RadioButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRadioButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRadioButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRadioButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRadioButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRadioButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonStaticsImpl: Sized {
    fn GroupNameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRadioButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRadioButtonStaticsVtbl {
        unsafe extern "system" fn GroupNameProperty<Impl: IRadioButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRadioButtonStatics, BASE_OFFSET>(),
            GroupNameProperty: GroupNameProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRadioButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRatingControlImpl: Sized {
    fn Caption(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCaption(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn InitialSetValue(&mut self) -> ::windows::core::Result<i32>;
    fn SetInitialSetValue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn IsClearEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsClearEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsReadOnly(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxRating(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxRating(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn PlaceholderValue(&mut self) -> ::windows::core::Result<f64>;
    fn SetPlaceholderValue(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemInfo(&mut self) -> ::windows::core::Result<RatingItemInfo>;
    fn SetItemInfo(&mut self, value: &::core::option::Option<RatingItemInfo>) -> ::windows::core::Result<()>;
    fn Value(&mut self) -> ::windows::core::Result<f64>;
    fn SetValue(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ValueChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveValueChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRatingControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControl";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRatingControlVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingControlImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingControlVtbl {
        unsafe extern "system" fn Caption<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Caption() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCaption<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCaption(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InitialSetValue<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialSetValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitialSetValue<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInitialSetValue(value).into()
        }
        unsafe extern "system" fn IsClearEnabled<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsClearEnabled<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsClearEnabled(value).into()
        }
        unsafe extern "system" fn IsReadOnly<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn MaxRating<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxRating() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxRating<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxRating(value).into()
        }
        unsafe extern "system" fn PlaceholderValue<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderValue<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderValue(value).into()
        }
        unsafe extern "system" fn ItemInfo<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemInfo<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemInfo(&*(&value as *const <RatingItemInfo as ::windows::core::Abi>::Abi as *const <RatingItemInfo as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Value<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetValue(value).into()
        }
        unsafe extern "system" fn ValueChanged<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ValueChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveValueChanged<Impl: IRatingControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveValueChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingControl, BASE_OFFSET>(),
            Caption: Caption::<Impl, IMPL_OFFSET>,
            SetCaption: SetCaption::<Impl, IMPL_OFFSET>,
            InitialSetValue: InitialSetValue::<Impl, IMPL_OFFSET>,
            SetInitialSetValue: SetInitialSetValue::<Impl, IMPL_OFFSET>,
            IsClearEnabled: IsClearEnabled::<Impl, IMPL_OFFSET>,
            SetIsClearEnabled: SetIsClearEnabled::<Impl, IMPL_OFFSET>,
            IsReadOnly: IsReadOnly::<Impl, IMPL_OFFSET>,
            SetIsReadOnly: SetIsReadOnly::<Impl, IMPL_OFFSET>,
            MaxRating: MaxRating::<Impl, IMPL_OFFSET>,
            SetMaxRating: SetMaxRating::<Impl, IMPL_OFFSET>,
            PlaceholderValue: PlaceholderValue::<Impl, IMPL_OFFSET>,
            SetPlaceholderValue: SetPlaceholderValue::<Impl, IMPL_OFFSET>,
            ItemInfo: ItemInfo::<Impl, IMPL_OFFSET>,
            SetItemInfo: SetItemInfo::<Impl, IMPL_OFFSET>,
            Value: Value::<Impl, IMPL_OFFSET>,
            SetValue: SetValue::<Impl, IMPL_OFFSET>,
            ValueChanged: ValueChanged::<Impl, IMPL_OFFSET>,
            RemoveValueChanged: RemoveValueChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingControlFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingControlFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingControlFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingControlFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingControlStaticsImpl: Sized {
    fn CaptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InitialSetValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsClearEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsReadOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxRatingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemInfoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingControlStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingControlStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingControlStaticsVtbl {
        unsafe extern "system" fn CaptionProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CaptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitialSetValueProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialSetValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsClearEnabledProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsReadOnlyProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxRatingProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxRatingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderValueProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemInfoProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInfoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ValueProperty<Impl: IRatingControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingControlStatics, BASE_OFFSET>(),
            CaptionProperty: CaptionProperty::<Impl, IMPL_OFFSET>,
            InitialSetValueProperty: InitialSetValueProperty::<Impl, IMPL_OFFSET>,
            IsClearEnabledProperty: IsClearEnabledProperty::<Impl, IMPL_OFFSET>,
            IsReadOnlyProperty: IsReadOnlyProperty::<Impl, IMPL_OFFSET>,
            MaxRatingProperty: MaxRatingProperty::<Impl, IMPL_OFFSET>,
            PlaceholderValueProperty: PlaceholderValueProperty::<Impl, IMPL_OFFSET>,
            ItemInfoProperty: ItemInfoProperty::<Impl, IMPL_OFFSET>,
            ValueProperty: ValueProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoImpl: Sized {
    fn DisabledGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisabledGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Glyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PointerOverGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPointerOverGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PointerOverPlaceholderGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPointerOverPlaceholderGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn UnsetGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetUnsetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfo";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemFontInfoImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemFontInfoVtbl {
        unsafe extern "system" fn DisabledGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Glyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverPlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverPlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverPlaceholderGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsetGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnsetGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUnsetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemFontInfo, BASE_OFFSET>(),
            DisabledGlyph: DisabledGlyph::<Impl, IMPL_OFFSET>,
            SetDisabledGlyph: SetDisabledGlyph::<Impl, IMPL_OFFSET>,
            Glyph: Glyph::<Impl, IMPL_OFFSET>,
            SetGlyph: SetGlyph::<Impl, IMPL_OFFSET>,
            PointerOverGlyph: PointerOverGlyph::<Impl, IMPL_OFFSET>,
            SetPointerOverGlyph: SetPointerOverGlyph::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderGlyph: PointerOverPlaceholderGlyph::<Impl, IMPL_OFFSET>,
            SetPointerOverPlaceholderGlyph: SetPointerOverPlaceholderGlyph::<Impl, IMPL_OFFSET>,
            PlaceholderGlyph: PlaceholderGlyph::<Impl, IMPL_OFFSET>,
            SetPlaceholderGlyph: SetPlaceholderGlyph::<Impl, IMPL_OFFSET>,
            UnsetGlyph: UnsetGlyph::<Impl, IMPL_OFFSET>,
            SetUnsetGlyph: SetUnsetGlyph::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemFontInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemFontInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemFontInfoFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemFontInfoFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemFontInfoFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemFontInfoFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemFontInfoFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoStaticsImpl: Sized {
    fn DisabledGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverPlaceholderGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UnsetGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfoStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemFontInfoStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemFontInfoStaticsVtbl {
        unsafe extern "system" fn DisabledGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverPlaceholderGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsetGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemFontInfoStatics, BASE_OFFSET>(),
            DisabledGlyphProperty: DisabledGlyphProperty::<Impl, IMPL_OFFSET>,
            GlyphProperty: GlyphProperty::<Impl, IMPL_OFFSET>,
            PlaceholderGlyphProperty: PlaceholderGlyphProperty::<Impl, IMPL_OFFSET>,
            PointerOverGlyphProperty: PointerOverGlyphProperty::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderGlyphProperty: PointerOverPlaceholderGlyphProperty::<Impl, IMPL_OFFSET>,
            UnsetGlyphProperty: UnsetGlyphProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemFontInfoStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRatingItemImageInfoImpl: Sized {
    fn DisabledImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetDisabledImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Image(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PlaceholderImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPlaceholderImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PointerOverImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPointerOverImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PointerOverPlaceholderImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPointerOverPlaceholderImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn UnsetImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetUnsetImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRatingItemImageInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfo";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRatingItemImageInfoVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemImageInfoImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemImageInfoVtbl {
        unsafe extern "system" fn DisabledImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Image<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Image() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverPlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverPlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverPlaceholderImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsetImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnsetImage<Impl: IRatingItemImageInfoImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUnsetImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemImageInfo, BASE_OFFSET>(),
            DisabledImage: DisabledImage::<Impl, IMPL_OFFSET>,
            SetDisabledImage: SetDisabledImage::<Impl, IMPL_OFFSET>,
            Image: Image::<Impl, IMPL_OFFSET>,
            SetImage: SetImage::<Impl, IMPL_OFFSET>,
            PlaceholderImage: PlaceholderImage::<Impl, IMPL_OFFSET>,
            SetPlaceholderImage: SetPlaceholderImage::<Impl, IMPL_OFFSET>,
            PointerOverImage: PointerOverImage::<Impl, IMPL_OFFSET>,
            SetPointerOverImage: SetPointerOverImage::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderImage: PointerOverPlaceholderImage::<Impl, IMPL_OFFSET>,
            SetPointerOverPlaceholderImage: SetPointerOverPlaceholderImage::<Impl, IMPL_OFFSET>,
            UnsetImage: UnsetImage::<Impl, IMPL_OFFSET>,
            SetUnsetImage: SetUnsetImage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemImageInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemImageInfoFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemImageInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemImageInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemImageInfoFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemImageInfoFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemImageInfoFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemImageInfoFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemImageInfoFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemImageInfoFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemImageInfoStaticsImpl: Sized {
    fn DisabledImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverPlaceholderImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UnsetImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemImageInfoStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemImageInfoStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemImageInfoStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemImageInfoStaticsVtbl {
        unsafe extern "system" fn DisabledImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverPlaceholderImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsetImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemImageInfoStatics, BASE_OFFSET>(),
            DisabledImageProperty: DisabledImageProperty::<Impl, IMPL_OFFSET>,
            ImageProperty: ImageProperty::<Impl, IMPL_OFFSET>,
            PlaceholderImageProperty: PlaceholderImageProperty::<Impl, IMPL_OFFSET>,
            PointerOverImageProperty: PointerOverImageProperty::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderImageProperty: PointerOverPlaceholderImageProperty::<Impl, IMPL_OFFSET>,
            UnsetImageProperty: UnsetImageProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemImageInfoStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemInfoImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemInfo";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemInfoVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemInfoImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemInfoVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemInfo, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemInfoFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemInfoFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemInfoFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemInfoFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemInfoFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemInfoFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemInfoFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRefreshContainerImpl: Sized {
    fn Visualizer(&mut self) -> ::windows::core::Result<RefreshVisualizer>;
    fn SetVisualizer(&mut self, value: &::core::option::Option<RefreshVisualizer>) -> ::windows::core::Result<()>;
    fn PullDirection(&mut self) -> ::windows::core::Result<RefreshPullDirection>;
    fn SetPullDirection(&mut self, value: RefreshPullDirection) -> ::windows::core::Result<()>;
    fn RefreshRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RequestRefresh(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRefreshContainer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainer";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRefreshContainerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshContainerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshContainerVtbl {
        unsafe extern "system" fn Visualizer<Impl: IRefreshContainerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Visualizer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVisualizer<Impl: IRefreshContainerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVisualizer(&*(&value as *const <RefreshVisualizer as ::windows::core::Abi>::Abi as *const <RefreshVisualizer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PullDirection<Impl: IRefreshContainerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshPullDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PullDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPullDirection<Impl: IRefreshContainerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RefreshPullDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPullDirection(value).into()
        }
        unsafe extern "system" fn RefreshRequested<Impl: IRefreshContainerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RefreshRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshRequested<Impl: IRefreshContainerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRefreshRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RequestRefresh<Impl: IRefreshContainerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestRefresh().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshContainer, BASE_OFFSET>(),
            Visualizer: Visualizer::<Impl, IMPL_OFFSET>,
            SetVisualizer: SetVisualizer::<Impl, IMPL_OFFSET>,
            PullDirection: PullDirection::<Impl, IMPL_OFFSET>,
            SetPullDirection: SetPullDirection::<Impl, IMPL_OFFSET>,
            RefreshRequested: RefreshRequested::<Impl, IMPL_OFFSET>,
            RemoveRefreshRequested: RemoveRefreshRequested::<Impl, IMPL_OFFSET>,
            RequestRefresh: RequestRefresh::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshContainer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshContainerFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RefreshContainer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshContainerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshContainerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshContainerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshContainerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRefreshContainerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshContainerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshContainerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshContainerStaticsImpl: Sized {
    fn VisualizerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PullDirectionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshContainerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshContainerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshContainerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshContainerStaticsVtbl {
        unsafe extern "system" fn VisualizerProperty<Impl: IRefreshContainerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VisualizerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PullDirectionProperty<Impl: IRefreshContainerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PullDirectionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshContainerStatics, BASE_OFFSET>(),
            VisualizerProperty: VisualizerProperty::<Impl, IMPL_OFFSET>,
            PullDirectionProperty: PullDirectionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshContainerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshInteractionRatioChangedEventArgsImpl: Sized {
    fn InteractionRatio(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshInteractionRatioChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshInteractionRatioChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshInteractionRatioChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshInteractionRatioChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshInteractionRatioChangedEventArgsVtbl {
        unsafe extern "system" fn InteractionRatio<Impl: IRefreshInteractionRatioChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InteractionRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshInteractionRatioChangedEventArgs, BASE_OFFSET>(),
            InteractionRatio: InteractionRatio::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshInteractionRatioChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRefreshRequestedEventArgsImpl: Sized {
    fn GetDeferral(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Deferral>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRefreshRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshRequestedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRefreshRequestedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshRequestedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshRequestedEventArgsVtbl {
        unsafe extern "system" fn GetDeferral<Impl: IRefreshRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshRequestedEventArgs, BASE_OFFSET>(),
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshStateChangedEventArgsImpl: Sized {
    fn OldState(&mut self) -> ::windows::core::Result<RefreshVisualizerState>;
    fn NewState(&mut self) -> ::windows::core::Result<RefreshVisualizerState>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshStateChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshStateChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshStateChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshStateChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshStateChangedEventArgsVtbl {
        unsafe extern "system" fn OldState<Impl: IRefreshStateChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewState<Impl: IRefreshStateChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshStateChangedEventArgs, BASE_OFFSET>(),
            OldState: OldState::<Impl, IMPL_OFFSET>,
            NewState: NewState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshStateChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRefreshVisualizerImpl: Sized {
    fn RequestRefresh(&mut self) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<RefreshVisualizerOrientation>;
    fn SetOrientation(&mut self, value: RefreshVisualizerOrientation) -> ::windows::core::Result<()>;
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn State(&mut self) -> ::windows::core::Result<RefreshVisualizerState>;
    fn RefreshRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RefreshStateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshStateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRefreshVisualizer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizer";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRefreshVisualizerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshVisualizerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshVisualizerVtbl {
        unsafe extern "system" fn RequestRefresh<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestRefresh().into()
        }
        unsafe extern "system" fn Orientation<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerOrientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RefreshVisualizerOrientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn Content<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn State<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).State() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RefreshRequested<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RefreshRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshRequested<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRefreshRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RefreshStateChanged<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RefreshStateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshStateChanged<Impl: IRefreshVisualizerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRefreshStateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshVisualizer, BASE_OFFSET>(),
            RequestRefresh: RequestRefresh::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            State: State::<Impl, IMPL_OFFSET>,
            RefreshRequested: RefreshRequested::<Impl, IMPL_OFFSET>,
            RemoveRefreshRequested: RemoveRefreshRequested::<Impl, IMPL_OFFSET>,
            RefreshStateChanged: RefreshStateChanged::<Impl, IMPL_OFFSET>,
            RemoveRefreshStateChanged: RemoveRefreshStateChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshVisualizer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshVisualizerFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RefreshVisualizer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshVisualizerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshVisualizerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshVisualizerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshVisualizerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRefreshVisualizerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshVisualizerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshVisualizerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshVisualizerStaticsImpl: Sized {
    fn InfoProviderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshVisualizerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshVisualizerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshVisualizerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshVisualizerStaticsVtbl {
        unsafe extern "system" fn InfoProviderProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InfoProviderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StateProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshVisualizerStatics, BASE_OFFSET>(),
            InfoProviderProperty: InfoProviderProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            StateProperty: StateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshVisualizerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRelativePanelImpl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRelativePanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanel";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRelativePanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanelVtbl {
        unsafe extern "system" fn BorderBrush<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRelativePanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanel, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanel2Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanel2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanel2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanel2Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IRelativePanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IRelativePanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanel2, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RelativePanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanelFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRelativePanelFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanelFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelStaticsImpl: Sized {
    fn LeftOfProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetLeftOf(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetLeftOf(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AboveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAbove(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAbove(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn RightOfProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRightOf(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetRightOf(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn BelowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetBelow(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetBelow(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignHorizontalCenterWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignHorizontalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignHorizontalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignVerticalCenterWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignVerticalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignVerticalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignLeftWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignLeftWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignLeftWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignTopWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignTopWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignTopWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignRightWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignRightWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignRightWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignBottomWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignBottomWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignBottomWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignLeftWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignLeftWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignLeftWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignTopWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignTopWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignTopWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignRightWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignRightWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignRightWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignBottomWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignBottomWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignBottomWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignHorizontalCenterWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignHorizontalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignHorizontalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignVerticalCenterWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignVerticalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignVerticalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanelStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanelStaticsVtbl {
        unsafe extern "system" fn LeftOfProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftOfProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeftOf<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLeftOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftOf<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AboveProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AboveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAbove<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAbove(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAbove<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAbove(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightOfProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightOfProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRightOf<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRightOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightOf<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BelowProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BelowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBelow<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBelow(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBelow<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBelow(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignHorizontalCenterWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignHorizontalCenterWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignHorizontalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignHorizontalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignHorizontalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignHorizontalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignVerticalCenterWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignVerticalCenterWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignVerticalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignVerticalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignVerticalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignVerticalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignLeftWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignLeftWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignLeftWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignLeftWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignLeftWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignLeftWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignTopWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignTopWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignTopWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignTopWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignTopWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignTopWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignRightWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignRightWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignRightWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignRightWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignRightWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignRightWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignBottomWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignBottomWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignBottomWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignBottomWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignBottomWith<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignBottomWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignLeftWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignLeftWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignLeftWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignLeftWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignLeftWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignLeftWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignTopWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignTopWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignTopWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignTopWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignTopWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignTopWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignRightWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignRightWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignRightWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignRightWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignRightWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignRightWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignBottomWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignBottomWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignBottomWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignBottomWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignBottomWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignBottomWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignHorizontalCenterWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignHorizontalCenterWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignHorizontalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignHorizontalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignHorizontalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignHorizontalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignVerticalCenterWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignVerticalCenterWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignVerticalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignVerticalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignVerticalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignVerticalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanelStatics, BASE_OFFSET>(),
            LeftOfProperty: LeftOfProperty::<Impl, IMPL_OFFSET>,
            GetLeftOf: GetLeftOf::<Impl, IMPL_OFFSET>,
            SetLeftOf: SetLeftOf::<Impl, IMPL_OFFSET>,
            AboveProperty: AboveProperty::<Impl, IMPL_OFFSET>,
            GetAbove: GetAbove::<Impl, IMPL_OFFSET>,
            SetAbove: SetAbove::<Impl, IMPL_OFFSET>,
            RightOfProperty: RightOfProperty::<Impl, IMPL_OFFSET>,
            GetRightOf: GetRightOf::<Impl, IMPL_OFFSET>,
            SetRightOf: SetRightOf::<Impl, IMPL_OFFSET>,
            BelowProperty: BelowProperty::<Impl, IMPL_OFFSET>,
            GetBelow: GetBelow::<Impl, IMPL_OFFSET>,
            SetBelow: SetBelow::<Impl, IMPL_OFFSET>,
            AlignHorizontalCenterWithProperty: AlignHorizontalCenterWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignHorizontalCenterWith: GetAlignHorizontalCenterWith::<Impl, IMPL_OFFSET>,
            SetAlignHorizontalCenterWith: SetAlignHorizontalCenterWith::<Impl, IMPL_OFFSET>,
            AlignVerticalCenterWithProperty: AlignVerticalCenterWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignVerticalCenterWith: GetAlignVerticalCenterWith::<Impl, IMPL_OFFSET>,
            SetAlignVerticalCenterWith: SetAlignVerticalCenterWith::<Impl, IMPL_OFFSET>,
            AlignLeftWithProperty: AlignLeftWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignLeftWith: GetAlignLeftWith::<Impl, IMPL_OFFSET>,
            SetAlignLeftWith: SetAlignLeftWith::<Impl, IMPL_OFFSET>,
            AlignTopWithProperty: AlignTopWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignTopWith: GetAlignTopWith::<Impl, IMPL_OFFSET>,
            SetAlignTopWith: SetAlignTopWith::<Impl, IMPL_OFFSET>,
            AlignRightWithProperty: AlignRightWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignRightWith: GetAlignRightWith::<Impl, IMPL_OFFSET>,
            SetAlignRightWith: SetAlignRightWith::<Impl, IMPL_OFFSET>,
            AlignBottomWithProperty: AlignBottomWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignBottomWith: GetAlignBottomWith::<Impl, IMPL_OFFSET>,
            SetAlignBottomWith: SetAlignBottomWith::<Impl, IMPL_OFFSET>,
            AlignLeftWithPanelProperty: AlignLeftWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignLeftWithPanel: GetAlignLeftWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignLeftWithPanel: SetAlignLeftWithPanel::<Impl, IMPL_OFFSET>,
            AlignTopWithPanelProperty: AlignTopWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignTopWithPanel: GetAlignTopWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignTopWithPanel: SetAlignTopWithPanel::<Impl, IMPL_OFFSET>,
            AlignRightWithPanelProperty: AlignRightWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignRightWithPanel: GetAlignRightWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignRightWithPanel: SetAlignRightWithPanel::<Impl, IMPL_OFFSET>,
            AlignBottomWithPanelProperty: AlignBottomWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignBottomWithPanel: GetAlignBottomWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignBottomWithPanel: SetAlignBottomWithPanel::<Impl, IMPL_OFFSET>,
            AlignHorizontalCenterWithPanelProperty: AlignHorizontalCenterWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignHorizontalCenterWithPanel: GetAlignHorizontalCenterWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignHorizontalCenterWithPanel: SetAlignHorizontalCenterWithPanel::<Impl, IMPL_OFFSET>,
            AlignVerticalCenterWithPanelProperty: AlignVerticalCenterWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignVerticalCenterWithPanel: GetAlignVerticalCenterWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignVerticalCenterWithPanel: SetAlignVerticalCenterWithPanel::<Impl, IMPL_OFFSET>,
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelStatics2Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanelStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanelStatics2Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IRelativePanelStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanelStatics2, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanelStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IRichEditBoxImpl: Sized {
    fn IsReadOnly(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AcceptsReturn(&mut self) -> ::windows::core::Result<bool>;
    fn SetAcceptsReturn(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn IsSpellCheckEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSpellCheckEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsTextPredictionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextPredictionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Document(&mut self) -> ::windows::core::Result<super::super::Text::ITextDocument>;
    fn InputScope(&mut self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&mut self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
    fn TextChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox";
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IRichEditBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxVtbl {
        unsafe extern "system" fn IsReadOnly<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn AcceptsReturn<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAcceptsReturn<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAcceptsReturn(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn IsSpellCheckEnabled<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSpellCheckEnabled<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSpellCheckEnabled(value).into()
        }
        unsafe extern "system" fn IsTextPredictionEnabled<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextPredictionEnabled<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextPredictionEnabled(value).into()
        }
        unsafe extern "system" fn Document<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Document() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScope<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IRichEditBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox, BASE_OFFSET>(),
            IsReadOnly: IsReadOnly::<Impl, IMPL_OFFSET>,
            SetIsReadOnly: SetIsReadOnly::<Impl, IMPL_OFFSET>,
            AcceptsReturn: AcceptsReturn::<Impl, IMPL_OFFSET>,
            SetAcceptsReturn: SetAcceptsReturn::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabled: IsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            SetIsSpellCheckEnabled: SetIsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabled: IsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextPredictionEnabled: SetIsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            Document: Document::<Impl, IMPL_OFFSET>,
            InputScope: InputScope::<Impl, IMPL_OFFSET>,
            SetInputScope: SetInputScope::<Impl, IMPL_OFFSET>,
            TextChanged: TextChanged::<Impl, IMPL_OFFSET>,
            RemoveTextChanged: RemoveTextChanged::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichEditBox2Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&mut self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichEditBox2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox2Vtbl {
        unsafe extern "system" fn Header<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn Paste<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: IRichEditBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus: PreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus: SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            Paste: Paste::<Impl, IMPL_OFFSET>,
            RemovePaste: RemovePaste::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRichEditBox3Impl: Sized {
    fn TextCompositionStarted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionEnded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionEnded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn DesiredCandidateWindowAlignment(&mut self) -> ::windows::core::Result<CandidateWindowAlignment>;
    fn SetDesiredCandidateWindowAlignment(&mut self, value: CandidateWindowAlignment) -> ::windows::core::Result<()>;
    fn CandidateWindowBoundsChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidateWindowBoundsChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRichEditBox3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox3Vtbl {
        unsafe extern "system" fn TextCompositionStarted<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionStarted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionStarted<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionChanged<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionChanged<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionEnded<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionEnded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionEnded<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn DesiredCandidateWindowAlignment<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDesiredCandidateWindowAlignment<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDesiredCandidateWindowAlignment(value).into()
        }
        unsafe extern "system" fn CandidateWindowBoundsChanged<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidateWindowBoundsChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidateWindowBoundsChanged<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCandidateWindowBoundsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanging<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanging<Impl: IRichEditBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox3, BASE_OFFSET>(),
            TextCompositionStarted: TextCompositionStarted::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionStarted: RemoveTextCompositionStarted::<Impl, IMPL_OFFSET>,
            TextCompositionChanged: TextCompositionChanged::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionChanged: RemoveTextCompositionChanged::<Impl, IMPL_OFFSET>,
            TextCompositionEnded: TextCompositionEnded::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionEnded: RemoveTextCompositionEnded::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
            DesiredCandidateWindowAlignment: DesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            SetDesiredCandidateWindowAlignment: SetDesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            CandidateWindowBoundsChanged: CandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            RemoveCandidateWindowBoundsChanged: RemoveCandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            TextChanging: TextChanging::<Impl, IMPL_OFFSET>,
            RemoveTextChanging: RemoveTextChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IRichEditBox4Impl: Sized {
    fn GetLinguisticAlternativesAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>>;
    fn ClipboardCopyFormat(&mut self) -> ::windows::core::Result<RichEditClipboardFormat>;
    fn SetClipboardCopyFormat(&mut self, value: RichEditClipboardFormat) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IRichEditBox4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox4Vtbl {
        unsafe extern "system" fn GetLinguisticAlternativesAsync<Impl: IRichEditBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLinguisticAlternativesAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClipboardCopyFormat<Impl: IRichEditBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RichEditClipboardFormat) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClipboardCopyFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClipboardCopyFormat<Impl: IRichEditBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RichEditClipboardFormat) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClipboardCopyFormat(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox4, BASE_OFFSET>(),
            GetLinguisticAlternativesAsync: GetLinguisticAlternativesAsync::<Impl, IMPL_OFFSET>,
            ClipboardCopyFormat: ClipboardCopyFormat::<Impl, IMPL_OFFSET>,
            SetClipboardCopyFormat: SetClipboardCopyFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichEditBox5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocused(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColorWhenNotFocused(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn MaxLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox5";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichEditBox5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocused<Impl: IRichEditBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColorWhenNotFocused<Impl: IRichEditBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColorWhenNotFocused(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxLength<Impl: IRichEditBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: IRichEditBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocused: SelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColorWhenNotFocused: SetSelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
            MaxLength: MaxLength::<Impl, IMPL_OFFSET>,
            SetMaxLength: SetMaxLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRichEditBox6Impl: Sized {
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn CharacterCasing(&mut self) -> ::windows::core::Result<CharacterCasing>;
    fn SetCharacterCasing(&mut self, value: CharacterCasing) -> ::windows::core::Result<()>;
    fn DisabledFormattingAccelerators(&mut self) -> ::windows::core::Result<DisabledFormattingAccelerators>;
    fn SetDisabledFormattingAccelerators(&mut self, value: DisabledFormattingAccelerators) -> ::windows::core::Result<()>;
    fn CopyingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCopyingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CuttingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCuttingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox6";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRichEditBox6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignment<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn CharacterCasing<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterCasing<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterCasing(value).into()
        }
        unsafe extern "system" fn DisabledFormattingAccelerators<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut DisabledFormattingAccelerators) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledFormattingAccelerators() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledFormattingAccelerators<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: DisabledFormattingAccelerators) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledFormattingAccelerators(value).into()
        }
        unsafe extern "system" fn CopyingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CopyingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCopyingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCopyingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CuttingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CuttingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCuttingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCuttingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox6, BASE_OFFSET>(),
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            CharacterCasing: CharacterCasing::<Impl, IMPL_OFFSET>,
            SetCharacterCasing: SetCharacterCasing::<Impl, IMPL_OFFSET>,
            DisabledFormattingAccelerators: DisabledFormattingAccelerators::<Impl, IMPL_OFFSET>,
            SetDisabledFormattingAccelerators: SetDisabledFormattingAccelerators::<Impl, IMPL_OFFSET>,
            CopyingToClipboard: CopyingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCopyingToClipboard: RemoveCopyingToClipboard::<Impl, IMPL_OFFSET>,
            CuttingToClipboard: CuttingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCuttingToClipboard: RemoveCuttingToClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichEditBox7Impl: Sized {
    fn ContentLinkForegroundColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetContentLinkForegroundColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn ContentLinkBackgroundColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetContentLinkBackgroundColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn ContentLinkProviders(&mut self) -> ::windows::core::Result<super::Documents::ContentLinkProviderCollection>;
    fn SetContentLinkProviders(&mut self, value: &::core::option::Option<super::Documents::ContentLinkProviderCollection>) -> ::windows::core::Result<()>;
    fn HandwritingView(&mut self) -> ::windows::core::Result<HandwritingView>;
    fn SetHandwritingView(&mut self, value: &::core::option::Option<HandwritingView>) -> ::windows::core::Result<()>;
    fn IsHandwritingViewEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHandwritingViewEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ContentLinkChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLinkChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContentLinkInvoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLinkInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox7";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichEditBox7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox7Vtbl {
        unsafe extern "system" fn ContentLinkForegroundColor<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkForegroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkForegroundColor<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentLinkForegroundColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkBackgroundColor<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkBackgroundColor<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentLinkBackgroundColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkProviders<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkProviders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkProviders<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentLinkProviders(&*(&value as *const <super::Documents::ContentLinkProviderCollection as ::windows::core::Abi>::Abi as *const <super::Documents::ContentLinkProviderCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HandwritingView<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandwritingView<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandwritingView(&*(&value as *const <HandwritingView as ::windows::core::Abi>::Abi as *const <HandwritingView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHandwritingViewEnabled<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHandwritingViewEnabled<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHandwritingViewEnabled(value).into()
        }
        unsafe extern "system" fn ContentLinkChanged<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLinkChanged<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContentLinkChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkInvoked<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLinkInvoked<Impl: IRichEditBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContentLinkInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox7, BASE_OFFSET>(),
            ContentLinkForegroundColor: ContentLinkForegroundColor::<Impl, IMPL_OFFSET>,
            SetContentLinkForegroundColor: SetContentLinkForegroundColor::<Impl, IMPL_OFFSET>,
            ContentLinkBackgroundColor: ContentLinkBackgroundColor::<Impl, IMPL_OFFSET>,
            SetContentLinkBackgroundColor: SetContentLinkBackgroundColor::<Impl, IMPL_OFFSET>,
            ContentLinkProviders: ContentLinkProviders::<Impl, IMPL_OFFSET>,
            SetContentLinkProviders: SetContentLinkProviders::<Impl, IMPL_OFFSET>,
            HandwritingView: HandwritingView::<Impl, IMPL_OFFSET>,
            SetHandwritingView: SetHandwritingView::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabled: IsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
            SetIsHandwritingViewEnabled: SetIsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
            ContentLinkChanged: ContentLinkChanged::<Impl, IMPL_OFFSET>,
            RemoveContentLinkChanged: RemoveContentLinkChanged::<Impl, IMPL_OFFSET>,
            ContentLinkInvoked: ContentLinkInvoked::<Impl, IMPL_OFFSET>,
            RemoveContentLinkInvoked: RemoveContentLinkInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IRichEditBox8Impl: Sized {
    fn TextDocument(&mut self) -> ::windows::core::Result<super::super::Text::RichEditTextDocument>;
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn ProofingMenuFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectionChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox8";
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IRichEditBox8Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox8Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox8Vtbl {
        unsafe extern "system" fn TextDocument<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDocument() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ProofingMenuFlyout<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanging<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanging<Impl: IRichEditBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox8, BASE_OFFSET>(),
            TextDocument: TextDocument::<Impl, IMPL_OFFSET>,
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyout: ProofingMenuFlyout::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            SelectionChanging: SelectionChanging::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanging: RemoveSelectionChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RichEditBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRichEditBoxFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxSelectionChangingEventArgsImpl: Sized {
    fn SelectionStart(&mut self) -> ::windows::core::Result<i32>;
    fn SelectionLength(&mut self) -> ::windows::core::Result<i32>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxSelectionChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxSelectionChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxSelectionChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxSelectionChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxSelectionChangingEventArgsVtbl {
        unsafe extern "system" fn SelectionStart<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionLength<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxSelectionChangingEventArgs, BASE_OFFSET>(),
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionLength: SelectionLength::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxSelectionChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStaticsImpl: Sized {
    fn IsReadOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AcceptsReturnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSpellCheckEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextPredictionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStaticsVtbl {
        unsafe extern "system" fn IsReadOnlyProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptsReturnProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSpellCheckEnabledProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextPredictionEnabledProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics, BASE_OFFSET>(),
            IsReadOnlyProperty: IsReadOnlyProperty::<Impl, IMPL_OFFSET>,
            AcceptsReturnProperty: AcceptsReturnProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabledProperty: IsSpellCheckEnabledProperty::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabledProperty: IsTextPredictionEnabledProperty::<Impl, IMPL_OFFSET>,
            InputScopeProperty: InputScopeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics2Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocusProperty: PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics3Impl: Sized {
    fn DesiredCandidateWindowAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics3Vtbl {
        unsafe extern "system" fn DesiredCandidateWindowAlignmentProperty<Impl: IRichEditBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IRichEditBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics3, BASE_OFFSET>(),
            DesiredCandidateWindowAlignmentProperty: DesiredCandidateWindowAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics4Impl: Sized {
    fn ClipboardCopyFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics4Vtbl {
        unsafe extern "system" fn ClipboardCopyFormatProperty<Impl: IRichEditBoxStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClipboardCopyFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics4, BASE_OFFSET>(),
            ClipboardCopyFormatProperty: ClipboardCopyFormatProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocusedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocusedProperty<Impl: IRichEditBoxStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocusedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: IRichEditBoxStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocusedProperty: SelectionHighlightColorWhenNotFocusedProperty::<Impl, IMPL_OFFSET>,
            MaxLengthProperty: MaxLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics6Impl: Sized {
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterCasingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisabledFormattingAcceleratorsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: IRichEditBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterCasingProperty<Impl: IRichEditBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisabledFormattingAcceleratorsProperty<Impl: IRichEditBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledFormattingAcceleratorsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics6, BASE_OFFSET>(),
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
            CharacterCasingProperty: CharacterCasingProperty::<Impl, IMPL_OFFSET>,
            DisabledFormattingAcceleratorsProperty: DisabledFormattingAcceleratorsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics7Impl: Sized {
    fn ContentLinkForegroundColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentLinkBackgroundColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentLinkProvidersProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HandwritingViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHandwritingViewEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics7Vtbl {
        unsafe extern "system" fn ContentLinkForegroundColorProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkForegroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkBackgroundColorProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkBackgroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkProvidersProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkProvidersProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HandwritingViewProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHandwritingViewEnabledProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics7, BASE_OFFSET>(),
            ContentLinkForegroundColorProperty: ContentLinkForegroundColorProperty::<Impl, IMPL_OFFSET>,
            ContentLinkBackgroundColorProperty: ContentLinkBackgroundColorProperty::<Impl, IMPL_OFFSET>,
            ContentLinkProvidersProperty: ContentLinkProvidersProperty::<Impl, IMPL_OFFSET>,
            HandwritingViewProperty: HandwritingViewProperty::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabledProperty: IsHandwritingViewEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics8Impl: Sized {
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProofingMenuFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics8";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics8Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics8Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics8Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IRichEditBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProofingMenuFlyoutProperty<Impl: IRichEditBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IRichEditBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics8, BASE_OFFSET>(),
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyoutProperty: ProofingMenuFlyoutProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxTextChangingEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxTextChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxTextChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxTextChangingEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxTextChangingEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxTextChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxTextChangingEventArgs2Impl: Sized {
    fn IsContentChanging(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxTextChangingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxTextChangingEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxTextChangingEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxTextChangingEventArgs2Vtbl {
        unsafe extern "system" fn IsContentChanging<Impl: IRichEditBoxTextChangingEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxTextChangingEventArgs2, BASE_OFFSET>(),
            IsContentChanging: IsContentChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxTextChangingEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichTextBlockImpl: Sized {
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn TextTrimming(&mut self) -> ::windows::core::Result<super::TextTrimming>;
    fn SetTextTrimming(&mut self, value: super::TextTrimming) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn Blocks(&mut self) -> ::windows::core::Result<super::Documents::BlockCollection>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn LineHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&mut self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&mut self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn OverflowContentTarget(&mut self) -> ::windows::core::Result<RichTextBlockOverflow>;
    fn SetOverflowContentTarget(&mut self, value: &::core::option::Option<RichTextBlockOverflow>) -> ::windows::core::Result<()>;
    fn IsTextSelectionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextSelectionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HasOverflowContent(&mut self) -> ::windows::core::Result<bool>;
    fn SelectedText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ContentStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn Select(&mut self, start: &::core::option::Option<super::Documents::TextPointer>, end: &::core::option::Option<super::Documents::TextPointer>) -> ::windows::core::Result<()>;
    fn GetPositionFromPoint(&mut self, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
    fn TextIndent(&mut self) -> ::windows::core::Result<f64>;
    fn SetTextIndent(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichTextBlockVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockVtbl {
        unsafe extern "system" fn FontSize<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn TextTrimming<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimming() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextTrimming<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextTrimming(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn Blocks<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Blocks() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Padding<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineHeight<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn OverflowContentTarget<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowContentTarget<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowContentTarget(&*(&value as *const <RichTextBlockOverflow as ::windows::core::Abi>::Abi as *const <RichTextBlockOverflow as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTextSelectionEnabled<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSelectionEnabled<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextSelectionEnabled(value).into()
        }
        unsafe extern "system" fn HasOverflowContent<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedText<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionStart<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionEnd<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn Select<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: ::windows::core::RawPtr, end: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Select(&*(&start as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType), &*(&end as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetPositionFromPoint<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::super::Foundation::Point, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPositionFromPoint(&*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextIndent<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextIndent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextIndent<Impl: IRichTextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextIndent(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock, BASE_OFFSET>(),
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            TextTrimming: TextTrimming::<Impl, IMPL_OFFSET>,
            SetTextTrimming: SetTextTrimming::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            Blocks: Blocks::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            LineHeight: LineHeight::<Impl, IMPL_OFFSET>,
            SetLineHeight: SetLineHeight::<Impl, IMPL_OFFSET>,
            LineStackingStrategy: LineStackingStrategy::<Impl, IMPL_OFFSET>,
            SetLineStackingStrategy: SetLineStackingStrategy::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            OverflowContentTarget: OverflowContentTarget::<Impl, IMPL_OFFSET>,
            SetOverflowContentTarget: SetOverflowContentTarget::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabled: IsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextSelectionEnabled: SetIsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            HasOverflowContent: HasOverflowContent::<Impl, IMPL_OFFSET>,
            SelectedText: SelectedText::<Impl, IMPL_OFFSET>,
            ContentStart: ContentStart::<Impl, IMPL_OFFSET>,
            ContentEnd: ContentEnd::<Impl, IMPL_OFFSET>,
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionEnd: SelectionEnd::<Impl, IMPL_OFFSET>,
            BaselineOffset: BaselineOffset::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            Select: Select::<Impl, IMPL_OFFSET>,
            GetPositionFromPoint: GetPositionFromPoint::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
            TextIndent: TextIndent::<Impl, IMPL_OFFSET>,
            SetTextIndent: SetTextIndent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichTextBlock2Impl: Sized {
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TextLineBounds(&mut self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&mut self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn OpticalMarginAlignment(&mut self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&mut self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichTextBlock2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock2Vtbl {
        unsafe extern "system" fn MaxLines<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OpticalMarginAlignment<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IRichTextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock2, BASE_OFFSET>(),
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
            TextLineBounds: TextLineBounds::<Impl, IMPL_OFFSET>,
            SetTextLineBounds: SetTextLineBounds::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignment: OpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            SetOpticalMarginAlignment: SetOpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlock3Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlock3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IRichTextBlock3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IRichTextBlock3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock3, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
pub trait IRichTextBlock4Impl: Sized {
    fn TextDecorations(&mut self) -> ::windows::core::Result<super::super::Text::TextDecorations>;
    fn SetTextDecorations(&mut self, value: super::super::Text::TextDecorations) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock4";
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl IRichTextBlock4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock4Vtbl {
        unsafe extern "system" fn TextDecorations<Impl: IRichTextBlock4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorations() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextDecorations<Impl: IRichTextBlock4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextDecorations(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock4, BASE_OFFSET>(),
            TextDecorations: TextDecorations::<Impl, IMPL_OFFSET>,
            SetTextDecorations: SetTextDecorations::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait IRichTextBlock5Impl: Sized {
    fn IsTextTrimmed(&mut self) -> ::windows::core::Result<bool>;
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextHighlighters(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Documents::TextHighlighter>>;
    fn IsTextTrimmedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock5";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl IRichTextBlock5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock5Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: IRichTextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignment<Impl: IRichTextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: IRichTextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn TextHighlighters<Impl: IRichTextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextHighlighters() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: IRichTextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: IRichTextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock5, BASE_OFFSET>(),
            IsTextTrimmed: IsTextTrimmed::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            TextHighlighters: TextHighlighters::<Impl, IMPL_OFFSET>,
            IsTextTrimmedChanged: IsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsTextTrimmedChanged: RemoveIsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IRichTextBlock6Impl: Sized {
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock6";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IRichTextBlock6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock6Vtbl {
        unsafe extern "system" fn SelectionFlyout<Impl: IRichTextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IRichTextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: IRichTextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock6, BASE_OFFSET>(),
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            CopySelectionToClipboard: CopySelectionToClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait IRichTextBlockOverflowImpl: Sized {
    fn OverflowContentTarget(&mut self) -> ::windows::core::Result<RichTextBlockOverflow>;
    fn SetOverflowContentTarget(&mut self, value: &::core::option::Option<RichTextBlockOverflow>) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn ContentSource(&mut self) -> ::windows::core::Result<RichTextBlock>;
    fn HasOverflowContent(&mut self) -> ::windows::core::Result<bool>;
    fn ContentStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&mut self) -> ::windows::core::Result<f64>;
    fn GetPositionFromPoint(&mut self, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl IRichTextBlockOverflowVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflowImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflowVtbl {
        unsafe extern "system" fn OverflowContentTarget<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowContentTarget<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowContentTarget(&*(&value as *const <RichTextBlockOverflow as ::windows::core::Abi>::Abi as *const <RichTextBlockOverflow as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentSource<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContent<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPositionFromPoint<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::super::Foundation::Point, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPositionFromPoint(&*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IRichTextBlockOverflowImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflow, BASE_OFFSET>(),
            OverflowContentTarget: OverflowContentTarget::<Impl, IMPL_OFFSET>,
            SetOverflowContentTarget: SetOverflowContentTarget::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            ContentSource: ContentSource::<Impl, IMPL_OFFSET>,
            HasOverflowContent: HasOverflowContent::<Impl, IMPL_OFFSET>,
            ContentStart: ContentStart::<Impl, IMPL_OFFSET>,
            ContentEnd: ContentEnd::<Impl, IMPL_OFFSET>,
            BaselineOffset: BaselineOffset::<Impl, IMPL_OFFSET>,
            GetPositionFromPoint: GetPositionFromPoint::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflow as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflow2Impl: Sized {
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflow2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflow2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflow2Vtbl {
        unsafe extern "system" fn MaxLines<Impl: IRichTextBlockOverflow2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IRichTextBlockOverflow2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflow2, BASE_OFFSET>(),
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflow2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRichTextBlockOverflow3Impl: Sized {
    fn IsTextTrimmed(&mut self) -> ::windows::core::Result<bool>;
    fn IsTextTrimmedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRichTextBlockOverflow3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflow3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflow3Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: IRichTextBlockOverflow3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: IRichTextBlockOverflow3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: IRichTextBlockOverflow3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflow3, BASE_OFFSET>(),
            IsTextTrimmed: IsTextTrimmed::<Impl, IMPL_OFFSET>,
            IsTextTrimmedChanged: IsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsTextTrimmedChanged: RemoveIsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflow3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStaticsImpl: Sized {
    fn OverflowContentTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasOverflowContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflowStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflowStaticsVtbl {
        unsafe extern "system" fn OverflowContentTargetProperty<Impl: IRichTextBlockOverflowStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRichTextBlockOverflowStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContentProperty<Impl: IRichTextBlockOverflowStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflowStatics, BASE_OFFSET>(),
            OverflowContentTargetProperty: OverflowContentTargetProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            HasOverflowContentProperty: HasOverflowContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflowStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStatics2Impl: Sized {
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflowStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflowStatics2Vtbl {
        unsafe extern "system" fn MaxLinesProperty<Impl: IRichTextBlockOverflowStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflowStatics2, BASE_OFFSET>(),
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflowStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStatics3Impl: Sized {
    fn IsTextTrimmedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflowStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflowStatics3Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: IRichTextBlockOverflowStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflowStatics3, BASE_OFFSET>(),
            IsTextTrimmedProperty: IsTextTrimmedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflowStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStaticsImpl: Sized {
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextTrimmingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowContentTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSelectionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasOverflowContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextIndentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStaticsVtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextTrimmingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimmingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowContentTargetProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSelectionEnabledProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContentProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedTextProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextIndentProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextIndentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics, BASE_OFFSET>(),
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            TextTrimmingProperty: TextTrimmingProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            LineHeightProperty: LineHeightProperty::<Impl, IMPL_OFFSET>,
            LineStackingStrategyProperty: LineStackingStrategyProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            OverflowContentTargetProperty: OverflowContentTargetProperty::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabledProperty: IsTextSelectionEnabledProperty::<Impl, IMPL_OFFSET>,
            HasOverflowContentProperty: HasOverflowContentProperty::<Impl, IMPL_OFFSET>,
            SelectedTextProperty: SelectedTextProperty::<Impl, IMPL_OFFSET>,
            TextIndentProperty: TextIndentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics2Impl: Sized {
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpticalMarginAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics2Vtbl {
        unsafe extern "system" fn MaxLinesProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics2, BASE_OFFSET>(),
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
            TextLineBoundsProperty: TextLineBoundsProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignmentProperty: OpticalMarginAlignmentProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics3Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IRichTextBlockStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics3, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics4Impl: Sized {
    fn TextDecorationsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics4Vtbl {
        unsafe extern "system" fn TextDecorationsProperty<Impl: IRichTextBlockStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorationsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics4, BASE_OFFSET>(),
            TextDecorationsProperty: TextDecorationsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics5Impl: Sized {
    fn IsTextTrimmedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics5Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: IRichTextBlockStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: IRichTextBlockStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics5, BASE_OFFSET>(),
            IsTextTrimmedProperty: IsTextTrimmedProperty::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics6Impl: Sized {
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics6Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IRichTextBlockStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics6, BASE_OFFSET>(),
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRowDefinitionImpl: Sized {
    fn Height(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetHeight(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn MaxHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MinHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ActualHeight(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRowDefinition {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRowDefinition";
}
#[cfg(feature = "implement_exclusive")]
impl IRowDefinitionVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRowDefinitionImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRowDefinitionVtbl {
        unsafe extern "system" fn Height<Impl: IRowDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Height() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeight<Impl: IRowDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeight(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxHeight<Impl: IRowDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHeight<Impl: IRowDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxHeight(value).into()
        }
        unsafe extern "system" fn MinHeight<Impl: IRowDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinHeight<Impl: IRowDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinHeight(value).into()
        }
        unsafe extern "system" fn ActualHeight<Impl: IRowDefinitionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRowDefinition, BASE_OFFSET>(),
            Height: Height::<Impl, IMPL_OFFSET>,
            SetHeight: SetHeight::<Impl, IMPL_OFFSET>,
            MaxHeight: MaxHeight::<Impl, IMPL_OFFSET>,
            SetMaxHeight: SetMaxHeight::<Impl, IMPL_OFFSET>,
            MinHeight: MinHeight::<Impl, IMPL_OFFSET>,
            SetMinHeight: SetMinHeight::<Impl, IMPL_OFFSET>,
            ActualHeight: ActualHeight::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRowDefinition as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRowDefinitionStaticsImpl: Sized {
    fn HeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRowDefinitionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRowDefinitionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRowDefinitionStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRowDefinitionStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRowDefinitionStaticsVtbl {
        unsafe extern "system" fn HeightProperty<Impl: IRowDefinitionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHeightProperty<Impl: IRowDefinitionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinHeightProperty<Impl: IRowDefinitionStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRowDefinitionStatics, BASE_OFFSET>(),
            HeightProperty: HeightProperty::<Impl, IMPL_OFFSET>,
            MaxHeightProperty: MaxHeightProperty::<Impl, IMPL_OFFSET>,
            MinHeightProperty: MinHeightProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRowDefinitionStatics as ::windows::core::Interface>::IID
    }
}
pub trait IScrollAnchorProviderImpl: Sized {
    fn CurrentAnchor(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn RegisterAnchorCandidate(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn UnregisterAnchorCandidate(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IScrollAnchorProvider {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollAnchorProvider";
}
impl IScrollAnchorProviderVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollAnchorProviderImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollAnchorProviderVtbl {
        unsafe extern "system" fn CurrentAnchor<Impl: IScrollAnchorProviderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentAnchor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterAnchorCandidate<Impl: IScrollAnchorProviderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterAnchorCandidate(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnregisterAnchorCandidate<Impl: IScrollAnchorProviderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterAnchorCandidate(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollAnchorProvider, BASE_OFFSET>(),
            CurrentAnchor: CurrentAnchor::<Impl, IMPL_OFFSET>,
            RegisterAnchorCandidate: RegisterAnchorCandidate::<Impl, IMPL_OFFSET>,
            UnregisterAnchorCandidate: UnregisterAnchorCandidate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollAnchorProvider as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollContentPresenterImpl: Sized {
    fn CanVerticallyScroll(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanVerticallyScroll(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanHorizontallyScroll(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanHorizontallyScroll(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ExtentWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ExtentHeight(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportHeight(&mut self) -> ::windows::core::Result<f64>;
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ScrollOwner(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetScrollOwner(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn LineUp(&mut self) -> ::windows::core::Result<()>;
    fn LineDown(&mut self) -> ::windows::core::Result<()>;
    fn LineLeft(&mut self) -> ::windows::core::Result<()>;
    fn LineRight(&mut self) -> ::windows::core::Result<()>;
    fn PageUp(&mut self) -> ::windows::core::Result<()>;
    fn PageDown(&mut self) -> ::windows::core::Result<()>;
    fn PageLeft(&mut self) -> ::windows::core::Result<()>;
    fn PageRight(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelUp(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelDown(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelLeft(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelRight(&mut self) -> ::windows::core::Result<()>;
    fn SetHorizontalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn SetVerticalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn MakeVisible(&mut self, visual: &::core::option::Option<super::UIElement>, rectangle: &super::super::super::Foundation::Rect) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollContentPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenter";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollContentPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollContentPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollContentPresenterVtbl {
        unsafe extern "system" fn CanVerticallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanVerticallyScroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanVerticallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanVerticallyScroll(value).into()
        }
        unsafe extern "system" fn CanHorizontallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanHorizontallyScroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanHorizontallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanHorizontallyScroll(value).into()
        }
        unsafe extern "system" fn ExtentWidth<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeight<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidth<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeight<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollOwner<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollOwner() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetScrollOwner<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetScrollOwner(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineUp<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineUp().into()
        }
        unsafe extern "system" fn LineDown<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineDown().into()
        }
        unsafe extern "system" fn LineLeft<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineLeft().into()
        }
        unsafe extern "system" fn LineRight<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineRight().into()
        }
        unsafe extern "system" fn PageUp<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageUp().into()
        }
        unsafe extern "system" fn PageDown<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageDown().into()
        }
        unsafe extern "system" fn PageLeft<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageLeft().into()
        }
        unsafe extern "system" fn PageRight<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageRight().into()
        }
        unsafe extern "system" fn MouseWheelUp<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelUp().into()
        }
        unsafe extern "system" fn MouseWheelDown<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelDown().into()
        }
        unsafe extern "system" fn MouseWheelLeft<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelLeft().into()
        }
        unsafe extern "system" fn MouseWheelRight<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelRight().into()
        }
        unsafe extern "system" fn SetHorizontalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalOffset(offset).into()
        }
        unsafe extern "system" fn SetVerticalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalOffset(offset).into()
        }
        unsafe extern "system" fn MakeVisible<Impl: IScrollContentPresenterImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, visual: ::windows::core::RawPtr, rectangle: super::super::super::Foundation::Rect, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MakeVisible(&*(&visual as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&rectangle as *const <super::super::super::Foundation::Rect as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Rect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollContentPresenter, BASE_OFFSET>(),
            CanVerticallyScroll: CanVerticallyScroll::<Impl, IMPL_OFFSET>,
            SetCanVerticallyScroll: SetCanVerticallyScroll::<Impl, IMPL_OFFSET>,
            CanHorizontallyScroll: CanHorizontallyScroll::<Impl, IMPL_OFFSET>,
            SetCanHorizontallyScroll: SetCanHorizontallyScroll::<Impl, IMPL_OFFSET>,
            ExtentWidth: ExtentWidth::<Impl, IMPL_OFFSET>,
            ExtentHeight: ExtentHeight::<Impl, IMPL_OFFSET>,
            ViewportWidth: ViewportWidth::<Impl, IMPL_OFFSET>,
            ViewportHeight: ViewportHeight::<Impl, IMPL_OFFSET>,
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            ScrollOwner: ScrollOwner::<Impl, IMPL_OFFSET>,
            SetScrollOwner: SetScrollOwner::<Impl, IMPL_OFFSET>,
            LineUp: LineUp::<Impl, IMPL_OFFSET>,
            LineDown: LineDown::<Impl, IMPL_OFFSET>,
            LineLeft: LineLeft::<Impl, IMPL_OFFSET>,
            LineRight: LineRight::<Impl, IMPL_OFFSET>,
            PageUp: PageUp::<Impl, IMPL_OFFSET>,
            PageDown: PageDown::<Impl, IMPL_OFFSET>,
            PageLeft: PageLeft::<Impl, IMPL_OFFSET>,
            PageRight: PageRight::<Impl, IMPL_OFFSET>,
            MouseWheelUp: MouseWheelUp::<Impl, IMPL_OFFSET>,
            MouseWheelDown: MouseWheelDown::<Impl, IMPL_OFFSET>,
            MouseWheelLeft: MouseWheelLeft::<Impl, IMPL_OFFSET>,
            MouseWheelRight: MouseWheelRight::<Impl, IMPL_OFFSET>,
            SetHorizontalOffset: SetHorizontalOffset::<Impl, IMPL_OFFSET>,
            SetVerticalOffset: SetVerticalOffset::<Impl, IMPL_OFFSET>,
            MakeVisible: MakeVisible::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollContentPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollContentPresenter2Impl: Sized {
    fn CanContentRenderOutsideBounds(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SizesContentToTemplatedParent(&mut self) -> ::windows::core::Result<bool>;
    fn SetSizesContentToTemplatedParent(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollContentPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollContentPresenter2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollContentPresenter2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollContentPresenter2Vtbl {
        unsafe extern "system" fn CanContentRenderOutsideBounds<Impl: IScrollContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(value).into()
        }
        unsafe extern "system" fn SizesContentToTemplatedParent<Impl: IScrollContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SizesContentToTemplatedParent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSizesContentToTemplatedParent<Impl: IScrollContentPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSizesContentToTemplatedParent(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollContentPresenter2, BASE_OFFSET>(),
            CanContentRenderOutsideBounds: CanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SetCanContentRenderOutsideBounds: SetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SizesContentToTemplatedParent: SizesContentToTemplatedParent::<Impl, IMPL_OFFSET>,
            SetSizesContentToTemplatedParent: SetSizesContentToTemplatedParent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollContentPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollContentPresenterStatics2Impl: Sized {
    fn CanContentRenderOutsideBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SizesContentToTemplatedParentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollContentPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollContentPresenterStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollContentPresenterStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollContentPresenterStatics2Vtbl {
        unsafe extern "system" fn CanContentRenderOutsideBoundsProperty<Impl: IScrollContentPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SizesContentToTemplatedParentProperty<Impl: IScrollContentPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SizesContentToTemplatedParentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollContentPresenterStatics2, BASE_OFFSET>(),
            CanContentRenderOutsideBoundsProperty: CanContentRenderOutsideBoundsProperty::<Impl, IMPL_OFFSET>,
            SizesContentToTemplatedParentProperty: SizesContentToTemplatedParentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollContentPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IScrollViewerImpl: Sized {
    fn HorizontalScrollBarVisibility(&mut self) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetHorizontalScrollBarVisibility(&mut self, value: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn VerticalScrollBarVisibility(&mut self) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetVerticalScrollBarVisibility(&mut self, value: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn IsHorizontalRailEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalRailEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalRailEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalRailEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsHorizontalScrollChainingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalScrollChainingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalScrollChainingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalScrollChainingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomChainingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomChainingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsScrollInertiaEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsScrollInertiaEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomInertiaEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomInertiaEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HorizontalScrollMode(&mut self) -> ::windows::core::Result<ScrollMode>;
    fn SetHorizontalScrollMode(&mut self, value: ScrollMode) -> ::windows::core::Result<()>;
    fn VerticalScrollMode(&mut self) -> ::windows::core::Result<ScrollMode>;
    fn SetVerticalScrollMode(&mut self, value: ScrollMode) -> ::windows::core::Result<()>;
    fn ZoomMode(&mut self) -> ::windows::core::Result<ZoomMode>;
    fn SetZoomMode(&mut self, value: ZoomMode) -> ::windows::core::Result<()>;
    fn HorizontalSnapPointsAlignment(&mut self) -> ::windows::core::Result<Primitives::SnapPointsAlignment>;
    fn SetHorizontalSnapPointsAlignment(&mut self, value: Primitives::SnapPointsAlignment) -> ::windows::core::Result<()>;
    fn VerticalSnapPointsAlignment(&mut self) -> ::windows::core::Result<Primitives::SnapPointsAlignment>;
    fn SetVerticalSnapPointsAlignment(&mut self, value: Primitives::SnapPointsAlignment) -> ::windows::core::Result<()>;
    fn HorizontalSnapPointsType(&mut self) -> ::windows::core::Result<SnapPointsType>;
    fn SetHorizontalSnapPointsType(&mut self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn VerticalSnapPointsType(&mut self) -> ::windows::core::Result<SnapPointsType>;
    fn SetVerticalSnapPointsType(&mut self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn ZoomSnapPointsType(&mut self) -> ::windows::core::Result<SnapPointsType>;
    fn SetZoomSnapPointsType(&mut self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ScrollableWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ComputedHorizontalScrollBarVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn ExtentWidth(&mut self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportHeight(&mut self) -> ::windows::core::Result<f64>;
    fn ScrollableHeight(&mut self) -> ::windows::core::Result<f64>;
    fn ComputedVerticalScrollBarVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn ExtentHeight(&mut self) -> ::windows::core::Result<f64>;
    fn MinZoomFactor(&mut self) -> ::windows::core::Result<f32>;
    fn SetMinZoomFactor(&mut self, value: f32) -> ::windows::core::Result<()>;
    fn MaxZoomFactor(&mut self) -> ::windows::core::Result<f32>;
    fn SetMaxZoomFactor(&mut self, value: f32) -> ::windows::core::Result<()>;
    fn ZoomFactor(&mut self) -> ::windows::core::Result<f32>;
    fn ZoomSnapPoints(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<f32>>;
    fn ViewChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollToHorizontalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn ScrollToVerticalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn ZoomToFactor(&mut self, factor: f32) -> ::windows::core::Result<()>;
    fn InvalidateScrollInfo(&mut self) -> ::windows::core::Result<()>;
    fn IsDeferredScrollingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDeferredScrollingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn BringIntoViewOnFocusChange(&mut self) -> ::windows::core::Result<bool>;
    fn SetBringIntoViewOnFocusChange(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IScrollViewerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerVtbl {
        unsafe extern "system" fn HorizontalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollBarVisibility(value).into()
        }
        unsafe extern "system" fn VerticalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollBarVisibility(value).into()
        }
        unsafe extern "system" fn IsHorizontalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalRailEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalRailEnabled(value).into()
        }
        unsafe extern "system" fn IsVerticalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalRailEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalRailEnabled(value).into()
        }
        unsafe extern "system" fn IsHorizontalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalScrollChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalScrollChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsVerticalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalScrollChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalScrollChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsScrollInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsScrollInertiaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsScrollInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsScrollInertiaEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomInertiaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomInertiaEnabled(value).into()
        }
        unsafe extern "system" fn HorizontalScrollMode<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollMode<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollMode(value).into()
        }
        unsafe extern "system" fn VerticalScrollMode<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollMode<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollMode(value).into()
        }
        unsafe extern "system" fn ZoomMode<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomMode<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomMode(value).into()
        }
        unsafe extern "system" fn HorizontalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSnapPointsAlignment(value).into()
        }
        unsafe extern "system" fn VerticalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSnapPointsAlignment(value).into()
        }
        unsafe extern "system" fn HorizontalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSnapPointsType(value).into()
        }
        unsafe extern "system" fn VerticalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSnapPointsType(value).into()
        }
        unsafe extern "system" fn ZoomSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomSnapPointsType(value).into()
        }
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidth<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableWidth<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedHorizontalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedHorizontalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentWidth<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeight<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableHeight<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedVerticalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedVerticalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeight<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinZoomFactor<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinZoomFactor<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinZoomFactor(value).into()
        }
        unsafe extern "system" fn MaxZoomFactor<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxZoomFactor<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxZoomFactor(value).into()
        }
        unsafe extern "system" fn ZoomFactor<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPoints<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPoints() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewChanged<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChanged<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollToHorizontalOffset<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollToHorizontalOffset(offset).into()
        }
        unsafe extern "system" fn ScrollToVerticalOffset<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollToVerticalOffset(offset).into()
        }
        unsafe extern "system" fn ZoomToFactor<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, factor: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ZoomToFactor(factor).into()
        }
        unsafe extern "system" fn InvalidateScrollInfo<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InvalidateScrollInfo().into()
        }
        unsafe extern "system" fn IsDeferredScrollingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDeferredScrollingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDeferredScrollingEnabled<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDeferredScrollingEnabled(value).into()
        }
        unsafe extern "system" fn BringIntoViewOnFocusChange<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BringIntoViewOnFocusChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBringIntoViewOnFocusChange<Impl: IScrollViewerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBringIntoViewOnFocusChange(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer, BASE_OFFSET>(),
            HorizontalScrollBarVisibility: HorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollBarVisibility: SetHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            VerticalScrollBarVisibility: VerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetVerticalScrollBarVisibility: SetVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            IsHorizontalRailEnabled: IsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalRailEnabled: SetIsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalRailEnabled: IsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalRailEnabled: SetIsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            IsHorizontalScrollChainingEnabled: IsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalScrollChainingEnabled: SetIsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalScrollChainingEnabled: IsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalScrollChainingEnabled: SetIsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsZoomChainingEnabled: IsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomChainingEnabled: SetIsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            IsScrollInertiaEnabled: IsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsScrollInertiaEnabled: SetIsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            IsZoomInertiaEnabled: IsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomInertiaEnabled: SetIsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            HorizontalScrollMode: HorizontalScrollMode::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollMode: SetHorizontalScrollMode::<Impl, IMPL_OFFSET>,
            VerticalScrollMode: VerticalScrollMode::<Impl, IMPL_OFFSET>,
            SetVerticalScrollMode: SetVerticalScrollMode::<Impl, IMPL_OFFSET>,
            ZoomMode: ZoomMode::<Impl, IMPL_OFFSET>,
            SetZoomMode: SetZoomMode::<Impl, IMPL_OFFSET>,
            HorizontalSnapPointsAlignment: HorizontalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalSnapPointsAlignment: SetHorizontalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsAlignment: VerticalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalSnapPointsAlignment: SetVerticalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            HorizontalSnapPointsType: HorizontalSnapPointsType::<Impl, IMPL_OFFSET>,
            SetHorizontalSnapPointsType: SetHorizontalSnapPointsType::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsType: VerticalSnapPointsType::<Impl, IMPL_OFFSET>,
            SetVerticalSnapPointsType: SetVerticalSnapPointsType::<Impl, IMPL_OFFSET>,
            ZoomSnapPointsType: ZoomSnapPointsType::<Impl, IMPL_OFFSET>,
            SetZoomSnapPointsType: SetZoomSnapPointsType::<Impl, IMPL_OFFSET>,
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            ViewportWidth: ViewportWidth::<Impl, IMPL_OFFSET>,
            ScrollableWidth: ScrollableWidth::<Impl, IMPL_OFFSET>,
            ComputedHorizontalScrollBarVisibility: ComputedHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            ExtentWidth: ExtentWidth::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            ViewportHeight: ViewportHeight::<Impl, IMPL_OFFSET>,
            ScrollableHeight: ScrollableHeight::<Impl, IMPL_OFFSET>,
            ComputedVerticalScrollBarVisibility: ComputedVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            ExtentHeight: ExtentHeight::<Impl, IMPL_OFFSET>,
            MinZoomFactor: MinZoomFactor::<Impl, IMPL_OFFSET>,
            SetMinZoomFactor: SetMinZoomFactor::<Impl, IMPL_OFFSET>,
            MaxZoomFactor: MaxZoomFactor::<Impl, IMPL_OFFSET>,
            SetMaxZoomFactor: SetMaxZoomFactor::<Impl, IMPL_OFFSET>,
            ZoomFactor: ZoomFactor::<Impl, IMPL_OFFSET>,
            ZoomSnapPoints: ZoomSnapPoints::<Impl, IMPL_OFFSET>,
            ViewChanged: ViewChanged::<Impl, IMPL_OFFSET>,
            RemoveViewChanged: RemoveViewChanged::<Impl, IMPL_OFFSET>,
            ScrollToHorizontalOffset: ScrollToHorizontalOffset::<Impl, IMPL_OFFSET>,
            ScrollToVerticalOffset: ScrollToVerticalOffset::<Impl, IMPL_OFFSET>,
            ZoomToFactor: ZoomToFactor::<Impl, IMPL_OFFSET>,
            InvalidateScrollInfo: InvalidateScrollInfo::<Impl, IMPL_OFFSET>,
            IsDeferredScrollingEnabled: IsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            SetIsDeferredScrollingEnabled: SetIsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            BringIntoViewOnFocusChange: BringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
            SetBringIntoViewOnFocusChange: SetBringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollViewer2Impl: Sized {
    fn TopLeftHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetTopLeftHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn LeftHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetLeftHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn TopHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetTopHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ViewChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChangeView(&mut self, horizontaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, verticaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, zoomfactor: &::core::option::Option<super::super::super::Foundation::IReference<f32>>) -> ::windows::core::Result<bool>;
    fn ChangeViewWithOptionalAnimation(&mut self, horizontaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, verticaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, zoomfactor: &::core::option::Option<super::super::super::Foundation::IReference<f32>>, disableanimation: bool) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollViewer2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewer2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewer2Vtbl {
        unsafe extern "system" fn TopLeftHeader<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopLeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopLeftHeader<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopLeftHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LeftHeader<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeader<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TopHeader<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopHeader<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ViewChanging<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChanging(&*(&handler as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChanging<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChangeView<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, horizontaloffset: ::windows::core::RawPtr, verticaloffset: ::windows::core::RawPtr, zoomfactor: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChangeView(
                &*(&horizontaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&verticaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&zoomfactor as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeViewWithOptionalAnimation<Impl: IScrollViewer2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, horizontaloffset: ::windows::core::RawPtr, verticaloffset: ::windows::core::RawPtr, zoomfactor: ::windows::core::RawPtr, disableanimation: bool, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChangeViewWithOptionalAnimation(
                &*(&horizontaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&verticaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&zoomfactor as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::DefaultType>::DefaultType),
                disableanimation,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer2, BASE_OFFSET>(),
            TopLeftHeader: TopLeftHeader::<Impl, IMPL_OFFSET>,
            SetTopLeftHeader: SetTopLeftHeader::<Impl, IMPL_OFFSET>,
            LeftHeader: LeftHeader::<Impl, IMPL_OFFSET>,
            SetLeftHeader: SetLeftHeader::<Impl, IMPL_OFFSET>,
            TopHeader: TopHeader::<Impl, IMPL_OFFSET>,
            SetTopHeader: SetTopHeader::<Impl, IMPL_OFFSET>,
            ViewChanging: ViewChanging::<Impl, IMPL_OFFSET>,
            RemoveViewChanging: RemoveViewChanging::<Impl, IMPL_OFFSET>,
            ChangeView: ChangeView::<Impl, IMPL_OFFSET>,
            ChangeViewWithOptionalAnimation: ChangeViewWithOptionalAnimation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollViewer3Impl: Sized {
    fn DirectManipulationStarted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDirectManipulationStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DirectManipulationCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDirectManipulationCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollViewer3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewer3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewer3Vtbl {
        unsafe extern "system" fn DirectManipulationStarted<Impl: IScrollViewer3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DirectManipulationStarted(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDirectManipulationStarted<Impl: IScrollViewer3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDirectManipulationStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DirectManipulationCompleted<Impl: IScrollViewer3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DirectManipulationCompleted(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDirectManipulationCompleted<Impl: IScrollViewer3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDirectManipulationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer3, BASE_OFFSET>(),
            DirectManipulationStarted: DirectManipulationStarted::<Impl, IMPL_OFFSET>,
            RemoveDirectManipulationStarted: RemoveDirectManipulationStarted::<Impl, IMPL_OFFSET>,
            DirectManipulationCompleted: DirectManipulationCompleted::<Impl, IMPL_OFFSET>,
            RemoveDirectManipulationCompleted: RemoveDirectManipulationCompleted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollViewer4Impl: Sized {
    fn ReduceViewportForCoreInputViewOcclusions(&mut self) -> ::windows::core::Result<bool>;
    fn SetReduceViewportForCoreInputViewOcclusions(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HorizontalAnchorRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalAnchorRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalAnchorRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalAnchorRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn CanContentRenderOutsideBounds(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AnchorRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveAnchorRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollViewer4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewer4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewer4Vtbl {
        unsafe extern "system" fn ReduceViewportForCoreInputViewOcclusions<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReduceViewportForCoreInputViewOcclusions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReduceViewportForCoreInputViewOcclusions<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetReduceViewportForCoreInputViewOcclusions(value).into()
        }
        unsafe extern "system" fn HorizontalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalAnchorRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalAnchorRatio(value).into()
        }
        unsafe extern "system" fn VerticalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalAnchorRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalAnchorRatio(value).into()
        }
        unsafe extern "system" fn CanContentRenderOutsideBounds<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(value).into()
        }
        unsafe extern "system" fn AnchorRequested<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnchorRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAnchorRequested<Impl: IScrollViewer4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAnchorRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer4, BASE_OFFSET>(),
            ReduceViewportForCoreInputViewOcclusions: ReduceViewportForCoreInputViewOcclusions::<Impl, IMPL_OFFSET>,
            SetReduceViewportForCoreInputViewOcclusions: SetReduceViewportForCoreInputViewOcclusions::<Impl, IMPL_OFFSET>,
            HorizontalAnchorRatio: HorizontalAnchorRatio::<Impl, IMPL_OFFSET>,
            SetHorizontalAnchorRatio: SetHorizontalAnchorRatio::<Impl, IMPL_OFFSET>,
            VerticalAnchorRatio: VerticalAnchorRatio::<Impl, IMPL_OFFSET>,
            SetVerticalAnchorRatio: SetVerticalAnchorRatio::<Impl, IMPL_OFFSET>,
            CanContentRenderOutsideBounds: CanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SetCanContentRenderOutsideBounds: SetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            AnchorRequested: AnchorRequested::<Impl, IMPL_OFFSET>,
            RemoveAnchorRequested: RemoveAnchorRequested::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStaticsImpl: Sized {
    fn HorizontalSnapPointsAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSnapPointsAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSnapPointsTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSnapPointsTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomSnapPointsTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ViewportWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ScrollableWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ComputedHorizontalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExtentWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ViewportHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ScrollableHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ComputedVerticalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExtentHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinZoomFactorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxZoomFactorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomFactorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomSnapPointsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetHorizontalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetHorizontalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>, horizontalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn VerticalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVerticalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetVerticalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>, verticalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn IsHorizontalRailEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsHorizontalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, ishorizontalrailenabled: bool) -> ::windows::core::Result<()>;
    fn IsVerticalRailEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVerticalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsVerticalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isverticalrailenabled: bool) -> ::windows::core::Result<()>;
    fn IsHorizontalScrollChainingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsHorizontalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, ishorizontalscrollchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsVerticalScrollChainingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVerticalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsVerticalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isverticalscrollchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsZoomChainingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsZoomChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsZoomChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, iszoomchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsScrollInertiaEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsScrollInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsScrollInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isscrollinertiaenabled: bool) -> ::windows::core::Result<()>;
    fn IsZoomInertiaEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsZoomInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsZoomInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, iszoominertiaenabled: bool) -> ::windows::core::Result<()>;
    fn HorizontalScrollModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetHorizontalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollMode>;
    fn SetHorizontalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>, horizontalscrollmode: ScrollMode) -> ::windows::core::Result<()>;
    fn VerticalScrollModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVerticalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollMode>;
    fn SetVerticalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>, verticalscrollmode: ScrollMode) -> ::windows::core::Result<()>;
    fn ZoomModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetZoomMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ZoomMode>;
    fn SetZoomMode(&mut self, element: &::core::option::Option<super::DependencyObject>, zoommode: ZoomMode) -> ::windows::core::Result<()>;
    fn IsDeferredScrollingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsDeferredScrollingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsDeferredScrollingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isdeferredscrollingenabled: bool) -> ::windows::core::Result<()>;
    fn BringIntoViewOnFocusChangeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetBringIntoViewOnFocusChange(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetBringIntoViewOnFocusChange(&mut self, element: &::core::option::Option<super::DependencyObject>, bringintoviewonfocuschange: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerStaticsVtbl {
        unsafe extern "system" fn HorizontalSnapPointsAlignmentProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSnapPointsAlignmentProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSnapPointsTypeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSnapPointsTypeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPointsTypeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalOffsetProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidthProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableWidthProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedHorizontalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedHorizontalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentWidthProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffsetProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeightProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableHeightProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedVerticalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedVerticalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeightProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinZoomFactorProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxZoomFactorProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomFactorProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPointsProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHorizontalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHorizontalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, horizontalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), horizontalscrollbarvisibility).into()
        }
        unsafe extern "system" fn VerticalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVerticalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVerticalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, verticalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), verticalscrollbarvisibility).into()
        }
        unsafe extern "system" fn IsHorizontalRailEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalRailEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsHorizontalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsHorizontalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, ishorizontalrailenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), ishorizontalrailenabled).into()
        }
        unsafe extern "system" fn IsVerticalRailEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalRailEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVerticalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsVerticalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isverticalrailenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isverticalrailenabled).into()
        }
        unsafe extern "system" fn IsHorizontalScrollChainingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalScrollChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsHorizontalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, ishorizontalscrollchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), ishorizontalscrollchainingenabled).into()
        }
        unsafe extern "system" fn IsVerticalScrollChainingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalScrollChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVerticalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsVerticalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isverticalscrollchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isverticalscrollchainingenabled).into()
        }
        unsafe extern "system" fn IsZoomChainingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsZoomChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsZoomChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, iszoomchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), iszoomchainingenabled).into()
        }
        unsafe extern "system" fn IsScrollInertiaEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsScrollInertiaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsScrollInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsScrollInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsScrollInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isscrollinertiaenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsScrollInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isscrollinertiaenabled).into()
        }
        unsafe extern "system" fn IsZoomInertiaEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomInertiaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsZoomInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsZoomInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, iszoominertiaenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), iszoominertiaenabled).into()
        }
        unsafe extern "system" fn HorizontalScrollModeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHorizontalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHorizontalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, horizontalscrollmode: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), horizontalscrollmode).into()
        }
        unsafe extern "system" fn VerticalScrollModeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVerticalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVerticalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, verticalscrollmode: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), verticalscrollmode).into()
        }
        unsafe extern "system" fn ZoomModeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZoomMode<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetZoomMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomMode<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, zoommode: ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), zoommode).into()
        }
        unsafe extern "system" fn IsDeferredScrollingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDeferredScrollingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsDeferredScrollingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsDeferredScrollingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDeferredScrollingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isdeferredscrollingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDeferredScrollingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isdeferredscrollingenabled).into()
        }
        unsafe extern "system" fn BringIntoViewOnFocusChangeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BringIntoViewOnFocusChangeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBringIntoViewOnFocusChange<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBringIntoViewOnFocusChange(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBringIntoViewOnFocusChange<Impl: IScrollViewerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, bringintoviewonfocuschange: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBringIntoViewOnFocusChange(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), bringintoviewonfocuschange).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerStatics, BASE_OFFSET>(),
            HorizontalSnapPointsAlignmentProperty: HorizontalSnapPointsAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsAlignmentProperty: VerticalSnapPointsAlignmentProperty::<Impl, IMPL_OFFSET>,
            HorizontalSnapPointsTypeProperty: HorizontalSnapPointsTypeProperty::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsTypeProperty: VerticalSnapPointsTypeProperty::<Impl, IMPL_OFFSET>,
            ZoomSnapPointsTypeProperty: ZoomSnapPointsTypeProperty::<Impl, IMPL_OFFSET>,
            HorizontalOffsetProperty: HorizontalOffsetProperty::<Impl, IMPL_OFFSET>,
            ViewportWidthProperty: ViewportWidthProperty::<Impl, IMPL_OFFSET>,
            ScrollableWidthProperty: ScrollableWidthProperty::<Impl, IMPL_OFFSET>,
            ComputedHorizontalScrollBarVisibilityProperty: ComputedHorizontalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            ExtentWidthProperty: ExtentWidthProperty::<Impl, IMPL_OFFSET>,
            VerticalOffsetProperty: VerticalOffsetProperty::<Impl, IMPL_OFFSET>,
            ViewportHeightProperty: ViewportHeightProperty::<Impl, IMPL_OFFSET>,
            ScrollableHeightProperty: ScrollableHeightProperty::<Impl, IMPL_OFFSET>,
            ComputedVerticalScrollBarVisibilityProperty: ComputedVerticalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            ExtentHeightProperty: ExtentHeightProperty::<Impl, IMPL_OFFSET>,
            MinZoomFactorProperty: MinZoomFactorProperty::<Impl, IMPL_OFFSET>,
            MaxZoomFactorProperty: MaxZoomFactorProperty::<Impl, IMPL_OFFSET>,
            ZoomFactorProperty: ZoomFactorProperty::<Impl, IMPL_OFFSET>,
            ZoomSnapPointsProperty: ZoomSnapPointsProperty::<Impl, IMPL_OFFSET>,
            HorizontalScrollBarVisibilityProperty: HorizontalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            GetHorizontalScrollBarVisibility: GetHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollBarVisibility: SetHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            VerticalScrollBarVisibilityProperty: VerticalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            GetVerticalScrollBarVisibility: GetVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetVerticalScrollBarVisibility: SetVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            IsHorizontalRailEnabledProperty: IsHorizontalRailEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsHorizontalRailEnabled: GetIsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalRailEnabled: SetIsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalRailEnabledProperty: IsVerticalRailEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsVerticalRailEnabled: GetIsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalRailEnabled: SetIsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            IsHorizontalScrollChainingEnabledProperty: IsHorizontalScrollChainingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsHorizontalScrollChainingEnabled: GetIsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalScrollChainingEnabled: SetIsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalScrollChainingEnabledProperty: IsVerticalScrollChainingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsVerticalScrollChainingEnabled: GetIsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalScrollChainingEnabled: SetIsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsZoomChainingEnabledProperty: IsZoomChainingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsZoomChainingEnabled: GetIsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomChainingEnabled: SetIsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            IsScrollInertiaEnabledProperty: IsScrollInertiaEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsScrollInertiaEnabled: GetIsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsScrollInertiaEnabled: SetIsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            IsZoomInertiaEnabledProperty: IsZoomInertiaEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsZoomInertiaEnabled: GetIsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomInertiaEnabled: SetIsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            HorizontalScrollModeProperty: HorizontalScrollModeProperty::<Impl, IMPL_OFFSET>,
            GetHorizontalScrollMode: GetHorizontalScrollMode::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollMode: SetHorizontalScrollMode::<Impl, IMPL_OFFSET>,
            VerticalScrollModeProperty: VerticalScrollModeProperty::<Impl, IMPL_OFFSET>,
            GetVerticalScrollMode: GetVerticalScrollMode::<Impl, IMPL_OFFSET>,
            SetVerticalScrollMode: SetVerticalScrollMode::<Impl, IMPL_OFFSET>,
            ZoomModeProperty: ZoomModeProperty::<Impl, IMPL_OFFSET>,
            GetZoomMode: GetZoomMode::<Impl, IMPL_OFFSET>,
            SetZoomMode: SetZoomMode::<Impl, IMPL_OFFSET>,
            IsDeferredScrollingEnabledProperty: IsDeferredScrollingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsDeferredScrollingEnabled: GetIsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            SetIsDeferredScrollingEnabled: SetIsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            BringIntoViewOnFocusChangeProperty: BringIntoViewOnFocusChangeProperty::<Impl, IMPL_OFFSET>,
            GetBringIntoViewOnFocusChange: GetBringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
            SetBringIntoViewOnFocusChange: SetBringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStatics2Impl: Sized {
    fn TopLeftHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerStatics2Vtbl {
        unsafe extern "system" fn TopLeftHeaderProperty<Impl: IScrollViewerStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopLeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftHeaderProperty<Impl: IScrollViewerStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopHeaderProperty<Impl: IScrollViewerStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerStatics2, BASE_OFFSET>(),
            TopLeftHeaderProperty: TopLeftHeaderProperty::<Impl, IMPL_OFFSET>,
            LeftHeaderProperty: LeftHeaderProperty::<Impl, IMPL_OFFSET>,
            TopHeaderProperty: TopHeaderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStatics4Impl: Sized {
    fn ReduceViewportForCoreInputViewOcclusionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalAnchorRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalAnchorRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanContentRenderOutsideBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetCanContentRenderOutsideBounds(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&mut self, element: &::core::option::Option<super::DependencyObject>, cancontentrenderoutsidebounds: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerStatics4Vtbl {
        unsafe extern "system" fn ReduceViewportForCoreInputViewOcclusionsProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReduceViewportForCoreInputViewOcclusionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalAnchorRatioProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalAnchorRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalAnchorRatioProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalAnchorRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanContentRenderOutsideBoundsProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCanContentRenderOutsideBounds<Impl: IScrollViewerStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCanContentRenderOutsideBounds(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollViewerStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, cancontentrenderoutsidebounds: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), cancontentrenderoutsidebounds).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerStatics4, BASE_OFFSET>(),
            ReduceViewportForCoreInputViewOcclusionsProperty: ReduceViewportForCoreInputViewOcclusionsProperty::<Impl, IMPL_OFFSET>,
            HorizontalAnchorRatioProperty: HorizontalAnchorRatioProperty::<Impl, IMPL_OFFSET>,
            VerticalAnchorRatioProperty: VerticalAnchorRatioProperty::<Impl, IMPL_OFFSET>,
            CanContentRenderOutsideBoundsProperty: CanContentRenderOutsideBoundsProperty::<Impl, IMPL_OFFSET>,
            GetCanContentRenderOutsideBounds: GetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SetCanContentRenderOutsideBounds: SetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewImpl: Sized {
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ZoomFactor(&mut self) -> ::windows::core::Result<f32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerView";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerViewVtbl {
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollViewerViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollViewerViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomFactor<Impl: IScrollViewerViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerView, BASE_OFFSET>(),
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            ZoomFactor: ZoomFactor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewChangedEventArgsImpl: Sized {
    fn IsIntermediate(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerViewChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerViewChangedEventArgsVtbl {
        unsafe extern "system" fn IsIntermediate<Impl: IScrollViewerViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIntermediate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerViewChangedEventArgs, BASE_OFFSET>(),
            IsIntermediate: IsIntermediate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerViewChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewChangingEventArgsImpl: Sized {
    fn NextView(&mut self) -> ::windows::core::Result<ScrollViewerView>;
    fn FinalView(&mut self) -> ::windows::core::Result<ScrollViewerView>;
    fn IsInertial(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerViewChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerViewChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerViewChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerViewChangingEventArgsVtbl {
        unsafe extern "system" fn NextView<Impl: IScrollViewerViewChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NextView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FinalView<Impl: IScrollViewerViewChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FinalView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInertial<Impl: IScrollViewerViewChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInertial() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerViewChangingEventArgs, BASE_OFFSET>(),
            NextView: NextView::<Impl, IMPL_OFFSET>,
            FinalView: FinalView::<Impl, IMPL_OFFSET>,
            IsInertial: IsInertial::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerViewChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISearchBoxImpl: Sized {
    fn SearchHistoryEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetSearchHistoryEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SearchHistoryContext(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSearchHistoryContext(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetQueryText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FocusOnKeyboardInput(&mut self) -> ::windows::core::Result<bool>;
    fn SetFocusOnKeyboardInput(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ChooseSuggestionOnEnter(&mut self) -> ::windows::core::Result<bool>;
    fn SetChooseSuggestionOnEnter(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn QueryChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQueryChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SuggestionsRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSuggestionsRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn QuerySubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQuerySubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ResultSuggestionChosen(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveResultSuggestionChosen(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PrepareForFocusOnKeyboardInput(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePrepareForFocusOnKeyboardInput(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetLocalContentSuggestionSettings(&mut self, settings: &::core::option::Option<super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBox";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "Foundation", feature = "implement_exclusive"))]
impl ISearchBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxVtbl {
        unsafe extern "system" fn SearchHistoryEnabled<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSearchHistoryEnabled<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSearchHistoryEnabled(value).into()
        }
        unsafe extern "system" fn SearchHistoryContext<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryContext() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSearchHistoryContext<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSearchHistoryContext(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QueryText<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQueryText<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetQueryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusOnKeyboardInput() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocusOnKeyboardInput(value).into()
        }
        unsafe extern "system" fn ChooseSuggestionOnEnter<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChooseSuggestionOnEnter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChooseSuggestionOnEnter<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChooseSuggestionOnEnter(value).into()
        }
        unsafe extern "system" fn QueryChanged<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQueryChanged<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveQueryChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SuggestionsRequested<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SuggestionsRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSuggestionsRequested<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSuggestionsRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QuerySubmitted<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QuerySubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQuerySubmitted<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveQuerySubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ResultSuggestionChosen<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ResultSuggestionChosen(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveResultSuggestionChosen<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveResultSuggestionChosen(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrepareForFocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrepareForFocusOnKeyboardInput(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePrepareForFocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePrepareForFocusOnKeyboardInput(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetLocalContentSuggestionSettings<Impl: ISearchBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, settings: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalContentSuggestionSettings(&*(&settings as *const <super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings as ::windows::core::Abi>::Abi as *const <super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBox, BASE_OFFSET>(),
            SearchHistoryEnabled: SearchHistoryEnabled::<Impl, IMPL_OFFSET>,
            SetSearchHistoryEnabled: SetSearchHistoryEnabled::<Impl, IMPL_OFFSET>,
            SearchHistoryContext: SearchHistoryContext::<Impl, IMPL_OFFSET>,
            SetSearchHistoryContext: SetSearchHistoryContext::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            SetQueryText: SetQueryText::<Impl, IMPL_OFFSET>,
            FocusOnKeyboardInput: FocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            SetFocusOnKeyboardInput: SetFocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            ChooseSuggestionOnEnter: ChooseSuggestionOnEnter::<Impl, IMPL_OFFSET>,
            SetChooseSuggestionOnEnter: SetChooseSuggestionOnEnter::<Impl, IMPL_OFFSET>,
            QueryChanged: QueryChanged::<Impl, IMPL_OFFSET>,
            RemoveQueryChanged: RemoveQueryChanged::<Impl, IMPL_OFFSET>,
            SuggestionsRequested: SuggestionsRequested::<Impl, IMPL_OFFSET>,
            RemoveSuggestionsRequested: RemoveSuggestionsRequested::<Impl, IMPL_OFFSET>,
            QuerySubmitted: QuerySubmitted::<Impl, IMPL_OFFSET>,
            RemoveQuerySubmitted: RemoveQuerySubmitted::<Impl, IMPL_OFFSET>,
            ResultSuggestionChosen: ResultSuggestionChosen::<Impl, IMPL_OFFSET>,
            RemoveResultSuggestionChosen: RemoveResultSuggestionChosen::<Impl, IMPL_OFFSET>,
            PrepareForFocusOnKeyboardInput: PrepareForFocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            RemovePrepareForFocusOnKeyboardInput: RemovePrepareForFocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            SetLocalContentSuggestionSettings: SetLocalContentSuggestionSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SearchBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISearchBoxFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
pub trait ISearchBoxQueryChangedEventArgsImpl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxQueryChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxQueryChangedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ISearchBoxQueryChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxQueryChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxQueryChangedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxQueryChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxQueryChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxQueryChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxQueryChangedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            Language: Language::<Impl, IMPL_OFFSET>,
            LinguisticDetails: LinguisticDetails::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxQueryChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "System", feature = "implement_exclusive"))]
pub trait ISearchBoxQuerySubmittedEventArgsImpl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
    fn KeyModifiers(&mut self) -> ::windows::core::Result<super::super::super::System::VirtualKeyModifiers>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "System", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxQuerySubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxQuerySubmittedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "System", feature = "implement_exclusive"))]
impl ISearchBoxQuerySubmittedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxQuerySubmittedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxQuerySubmittedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyModifiers<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::System::VirtualKeyModifiers) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyModifiers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxQuerySubmittedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            Language: Language::<Impl, IMPL_OFFSET>,
            LinguisticDetails: LinguisticDetails::<Impl, IMPL_OFFSET>,
            KeyModifiers: KeyModifiers::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxQuerySubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "System", feature = "implement_exclusive"))]
pub trait ISearchBoxResultSuggestionChosenEventArgsImpl: Sized {
    fn Tag(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn KeyModifiers(&mut self) -> ::windows::core::Result<super::super::super::System::VirtualKeyModifiers>;
}
#[cfg(all(feature = "System", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxResultSuggestionChosenEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxResultSuggestionChosenEventArgs";
}
#[cfg(all(feature = "System", feature = "implement_exclusive"))]
impl ISearchBoxResultSuggestionChosenEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxResultSuggestionChosenEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxResultSuggestionChosenEventArgsVtbl {
        unsafe extern "system" fn Tag<Impl: ISearchBoxResultSuggestionChosenEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Tag() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyModifiers<Impl: ISearchBoxResultSuggestionChosenEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::System::VirtualKeyModifiers) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyModifiers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxResultSuggestionChosenEventArgs, BASE_OFFSET>(),
            Tag: Tag::<Impl, IMPL_OFFSET>,
            KeyModifiers: KeyModifiers::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxResultSuggestionChosenEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxStaticsImpl: Sized {
    fn SearchHistoryEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SearchHistoryContextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn QueryTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusOnKeyboardInputProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChooseSuggestionOnEnterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxStaticsVtbl {
        unsafe extern "system" fn SearchHistoryEnabledProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SearchHistoryContextProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryContextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryTextProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusOnKeyboardInputProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusOnKeyboardInputProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChooseSuggestionOnEnterProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChooseSuggestionOnEnterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxStatics, BASE_OFFSET>(),
            SearchHistoryEnabledProperty: SearchHistoryEnabledProperty::<Impl, IMPL_OFFSET>,
            SearchHistoryContextProperty: SearchHistoryContextProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            QueryTextProperty: QueryTextProperty::<Impl, IMPL_OFFSET>,
            FocusOnKeyboardInputProperty: FocusOnKeyboardInputProperty::<Impl, IMPL_OFFSET>,
            ChooseSuggestionOnEnterProperty: ChooseSuggestionOnEnterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
pub trait ISearchBoxSuggestionsRequestedEventArgsImpl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
    fn Request(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchSuggestionsRequest>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxSuggestionsRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxSuggestionsRequestedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ISearchBoxSuggestionsRequestedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxSuggestionsRequestedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Request<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Request() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxSuggestionsRequestedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            Language: Language::<Impl, IMPL_OFFSET>,
            LinguisticDetails: LinguisticDetails::<Impl, IMPL_OFFSET>,
            Request: Request::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxSuggestionsRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ISectionsInViewChangedEventArgsImpl: Sized {
    fn AddedSections(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn RemovedSections(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISectionsInViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ISectionsInViewChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISectionsInViewChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISectionsInViewChangedEventArgsVtbl {
        unsafe extern "system" fn AddedSections<Impl: ISectionsInViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedSections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedSections<Impl: ISectionsInViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedSections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISectionsInViewChangedEventArgs, BASE_OFFSET>(),
            AddedSections: AddedSections::<Impl, IMPL_OFFSET>,
            RemovedSections: RemovedSections::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISectionsInViewChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISectionsInViewChangedEventArgsFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISectionsInViewChangedEventArgsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISectionsInViewChangedEventArgsFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISectionsInViewChangedEventArgsFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISectionsInViewChangedEventArgsFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISectionsInViewChangedEventArgsFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISectionsInViewChangedEventArgsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ISelectionChangedEventArgsImpl: Sized {
    fn AddedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn RemovedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISelectionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ISelectionChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISelectionChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISelectionChangedEventArgsVtbl {
        unsafe extern "system" fn AddedItems<Impl: ISelectionChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedItems<Impl: ISelectionChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISelectionChangedEventArgs, BASE_OFFSET>(),
            AddedItems: AddedItems::<Impl, IMPL_OFFSET>,
            RemovedItems: RemovedItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISelectionChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ISelectionChangedEventArgsFactoryImpl: Sized {
    fn CreateInstanceWithRemovedItemsAndAddedItems(&mut self, removeditems: &::core::option::Option<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>, addeditems: &::core::option::Option<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SelectionChangedEventArgs>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISelectionChangedEventArgsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgsFactory";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ISelectionChangedEventArgsFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISelectionChangedEventArgsFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISelectionChangedEventArgsFactoryVtbl {
        unsafe extern "system" fn CreateInstanceWithRemovedItemsAndAddedItems<Impl: ISelectionChangedEventArgsFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, removeditems: ::windows::core::RawPtr, addeditems: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithRemovedItemsAndAddedItems(
                &*(&removeditems as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType),
                &*(&addeditems as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType),
                &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&innerinterface),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISelectionChangedEventArgsFactory, BASE_OFFSET>(),
            CreateInstanceWithRemovedItemsAndAddedItems: CreateInstanceWithRemovedItemsAndAddedItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISelectionChangedEventArgsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISemanticZoomImpl: Sized {
    fn ZoomedInView(&mut self) -> ::windows::core::Result<ISemanticZoomInformation>;
    fn SetZoomedInView(&mut self, value: &::core::option::Option<ISemanticZoomInformation>) -> ::windows::core::Result<()>;
    fn ZoomedOutView(&mut self) -> ::windows::core::Result<ISemanticZoomInformation>;
    fn SetZoomedOutView(&mut self, value: &::core::option::Option<ISemanticZoomInformation>) -> ::windows::core::Result<()>;
    fn IsZoomedInViewActive(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomedInViewActive(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanChangeViews(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanChangeViews(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ViewChangeStarted(&mut self, handler: &::core::option::Option<SemanticZoomViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChangeStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ViewChangeCompleted(&mut self, handler: &::core::option::Option<SemanticZoomViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChangeCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ToggleActiveView(&mut self) -> ::windows::core::Result<()>;
    fn IsZoomOutButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomOutButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISemanticZoom {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoom";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ISemanticZoomVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomVtbl {
        unsafe extern "system" fn ZoomedInView<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomedInView<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomedInView(&*(&value as *const <ISemanticZoomInformation as ::windows::core::Abi>::Abi as *const <ISemanticZoomInformation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ZoomedOutView<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedOutView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomedOutView<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomedOutView(&*(&value as *const <ISemanticZoomInformation as ::windows::core::Abi>::Abi as *const <ISemanticZoomInformation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsZoomedInViewActive<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewActive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomedInViewActive<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomedInViewActive(value).into()
        }
        unsafe extern "system" fn CanChangeViews<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanChangeViews() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanChangeViews<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanChangeViews(value).into()
        }
        unsafe extern "system" fn ViewChangeStarted<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChangeStarted(&*(&handler as *const <SemanticZoomViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SemanticZoomViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChangeStarted<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChangeStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ViewChangeCompleted<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChangeCompleted(&*(&handler as *const <SemanticZoomViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SemanticZoomViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChangeCompleted<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChangeCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ToggleActiveView<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ToggleActiveView().into()
        }
        unsafe extern "system" fn IsZoomOutButtonEnabled<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomOutButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomOutButtonEnabled<Impl: ISemanticZoomImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomOutButtonEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoom, BASE_OFFSET>(),
            ZoomedInView: ZoomedInView::<Impl, IMPL_OFFSET>,
            SetZoomedInView: SetZoomedInView::<Impl, IMPL_OFFSET>,
            ZoomedOutView: ZoomedOutView::<Impl, IMPL_OFFSET>,
            SetZoomedOutView: SetZoomedOutView::<Impl, IMPL_OFFSET>,
            IsZoomedInViewActive: IsZoomedInViewActive::<Impl, IMPL_OFFSET>,
            SetIsZoomedInViewActive: SetIsZoomedInViewActive::<Impl, IMPL_OFFSET>,
            CanChangeViews: CanChangeViews::<Impl, IMPL_OFFSET>,
            SetCanChangeViews: SetCanChangeViews::<Impl, IMPL_OFFSET>,
            ViewChangeStarted: ViewChangeStarted::<Impl, IMPL_OFFSET>,
            RemoveViewChangeStarted: RemoveViewChangeStarted::<Impl, IMPL_OFFSET>,
            ViewChangeCompleted: ViewChangeCompleted::<Impl, IMPL_OFFSET>,
            RemoveViewChangeCompleted: RemoveViewChangeCompleted::<Impl, IMPL_OFFSET>,
            ToggleActiveView: ToggleActiveView::<Impl, IMPL_OFFSET>,
            IsZoomOutButtonEnabled: IsZoomOutButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomOutButtonEnabled: SetIsZoomOutButtonEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoom as ::windows::core::Interface>::IID
    }
}
pub trait ISemanticZoomInformationImpl: Sized {
    fn SemanticZoomOwner(&mut self) -> ::windows::core::Result<SemanticZoom>;
    fn SetSemanticZoomOwner(&mut self, value: &::core::option::Option<SemanticZoom>) -> ::windows::core::Result<()>;
    fn IsActiveView(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsActiveView(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomedInView(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomedInView(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn InitializeViewChange(&mut self) -> ::windows::core::Result<()>;
    fn CompleteViewChange(&mut self) -> ::windows::core::Result<()>;
    fn MakeVisible(&mut self, item: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn StartViewChangeFrom(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn StartViewChangeTo(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn CompleteViewChangeFrom(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn CompleteViewChangeTo(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ISemanticZoomInformation {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomInformation";
}
impl ISemanticZoomInformationVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomInformationImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomInformationVtbl {
        unsafe extern "system" fn SemanticZoomOwner<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwner() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSemanticZoomOwner<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSemanticZoomOwner(&*(&value as *const <SemanticZoom as ::windows::core::Abi>::Abi as *const <SemanticZoom as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsActiveView<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsActiveView<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsActiveView(value).into()
        }
        unsafe extern "system" fn IsZoomedInView<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomedInView<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomedInView(value).into()
        }
        unsafe extern "system" fn InitializeViewChange<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeViewChange().into()
        }
        unsafe extern "system" fn CompleteViewChange<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompleteViewChange().into()
        }
        unsafe extern "system" fn MakeVisible<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MakeVisible(&*(&item as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn StartViewChangeFrom<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartViewChangeFrom(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn StartViewChangeTo<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartViewChangeTo(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompleteViewChangeFrom<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompleteViewChangeFrom(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompleteViewChangeTo<Impl: ISemanticZoomInformationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompleteViewChangeTo(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomInformation, BASE_OFFSET>(),
            SemanticZoomOwner: SemanticZoomOwner::<Impl, IMPL_OFFSET>,
            SetSemanticZoomOwner: SetSemanticZoomOwner::<Impl, IMPL_OFFSET>,
            IsActiveView: IsActiveView::<Impl, IMPL_OFFSET>,
            SetIsActiveView: SetIsActiveView::<Impl, IMPL_OFFSET>,
            IsZoomedInView: IsZoomedInView::<Impl, IMPL_OFFSET>,
            SetIsZoomedInView: SetIsZoomedInView::<Impl, IMPL_OFFSET>,
            InitializeViewChange: InitializeViewChange::<Impl, IMPL_OFFSET>,
            CompleteViewChange: CompleteViewChange::<Impl, IMPL_OFFSET>,
            MakeVisible: MakeVisible::<Impl, IMPL_OFFSET>,
            StartViewChangeFrom: StartViewChangeFrom::<Impl, IMPL_OFFSET>,
            StartViewChangeTo: StartViewChangeTo::<Impl, IMPL_OFFSET>,
            CompleteViewChangeFrom: CompleteViewChangeFrom::<Impl, IMPL_OFFSET>,
            CompleteViewChangeTo: CompleteViewChangeTo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomInformation as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISemanticZoomLocationImpl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Bounds(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
    fn SetBounds(&mut self, value: &super::super::super::Foundation::Rect) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISemanticZoomLocation {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomLocation";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ISemanticZoomLocationVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomLocationImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomLocationVtbl {
        unsafe extern "system" fn Item<Impl: ISemanticZoomLocationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: ISemanticZoomLocationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Bounds<Impl: ISemanticZoomLocationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Bounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBounds<Impl: ISemanticZoomLocationImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBounds(&*(&value as *const <super::super::super::Foundation::Rect as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Rect as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomLocation, BASE_OFFSET>(),
            Item: Item::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
            Bounds: Bounds::<Impl, IMPL_OFFSET>,
            SetBounds: SetBounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomLocation as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomStaticsImpl: Sized {
    fn ZoomedInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomedOutViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewActiveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanChangeViewsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomOutButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoomStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomStaticsVtbl {
        unsafe extern "system" fn ZoomedInViewProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomedOutViewProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedOutViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewActiveProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewActiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanChangeViewsProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanChangeViewsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomOutButtonEnabledProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomOutButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomStatics, BASE_OFFSET>(),
            ZoomedInViewProperty: ZoomedInViewProperty::<Impl, IMPL_OFFSET>,
            ZoomedOutViewProperty: ZoomedOutViewProperty::<Impl, IMPL_OFFSET>,
            IsZoomedInViewActiveProperty: IsZoomedInViewActiveProperty::<Impl, IMPL_OFFSET>,
            CanChangeViewsProperty: CanChangeViewsProperty::<Impl, IMPL_OFFSET>,
            IsZoomOutButtonEnabledProperty: IsZoomOutButtonEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomViewChangedEventArgsImpl: Sized {
    fn IsSourceZoomedInView(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSourceZoomedInView(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SourceItem(&mut self) -> ::windows::core::Result<SemanticZoomLocation>;
    fn SetSourceItem(&mut self, value: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn DestinationItem(&mut self) -> ::windows::core::Result<SemanticZoomLocation>;
    fn SetDestinationItem(&mut self, value: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoomViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomViewChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomViewChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomViewChangedEventArgsVtbl {
        unsafe extern "system" fn IsSourceZoomedInView<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSourceZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSourceZoomedInView<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSourceZoomedInView(value).into()
        }
        unsafe extern "system" fn SourceItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceItem(&*(&value as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DestinationItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DestinationItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationItem(&*(&value as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomViewChangedEventArgs, BASE_OFFSET>(),
            IsSourceZoomedInView: IsSourceZoomedInView::<Impl, IMPL_OFFSET>,
            SetIsSourceZoomedInView: SetIsSourceZoomedInView::<Impl, IMPL_OFFSET>,
            SourceItem: SourceItem::<Impl, IMPL_OFFSET>,
            SetSourceItem: SetSourceItem::<Impl, IMPL_OFFSET>,
            DestinationItem: DestinationItem::<Impl, IMPL_OFFSET>,
            SetDestinationItem: SetDestinationItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomViewChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ISettingsFlyoutImpl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTitle(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn HeaderBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHeaderBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HeaderForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHeaderForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IconSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetIconSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::SettingsFlyoutTemplateSettings>;
    fn BackClick(&mut self, handler: &::core::option::Option<BackClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBackClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Show(&mut self) -> ::windows::core::Result<()>;
    fn ShowIndependent(&mut self) -> ::windows::core::Result<()>;
    fn Hide(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISettingsFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyout";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ISettingsFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISettingsFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISettingsFlyoutVtbl {
        unsafe extern "system" fn Title<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderBackground<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderBackground<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderForeground<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderForeground<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IconSource<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackClick<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackClick(&*(&handler as *const <BackClickEventHandler as ::windows::core::Abi>::Abi as *const <BackClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBackClick<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBackClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Show<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Show().into()
        }
        unsafe extern "system" fn ShowIndependent<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowIndependent().into()
        }
        unsafe extern "system" fn Hide<Impl: ISettingsFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISettingsFlyout, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            HeaderBackground: HeaderBackground::<Impl, IMPL_OFFSET>,
            SetHeaderBackground: SetHeaderBackground::<Impl, IMPL_OFFSET>,
            HeaderForeground: HeaderForeground::<Impl, IMPL_OFFSET>,
            SetHeaderForeground: SetHeaderForeground::<Impl, IMPL_OFFSET>,
            IconSource: IconSource::<Impl, IMPL_OFFSET>,
            SetIconSource: SetIconSource::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            BackClick: BackClick::<Impl, IMPL_OFFSET>,
            RemoveBackClick: RemoveBackClick::<Impl, IMPL_OFFSET>,
            Show: Show::<Impl, IMPL_OFFSET>,
            ShowIndependent: ShowIndependent::<Impl, IMPL_OFFSET>,
            Hide: Hide::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISettingsFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISettingsFlyoutFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SettingsFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISettingsFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISettingsFlyoutFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISettingsFlyoutFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISettingsFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISettingsFlyoutFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISettingsFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISettingsFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISettingsFlyoutStaticsImpl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISettingsFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISettingsFlyoutStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISettingsFlyoutStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISettingsFlyoutStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderBackgroundProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderForegroundProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconSourceProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISettingsFlyoutStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            HeaderBackgroundProperty: HeaderBackgroundProperty::<Impl, IMPL_OFFSET>,
            HeaderForegroundProperty: HeaderForegroundProperty::<Impl, IMPL_OFFSET>,
            IconSourceProperty: IconSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISettingsFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
pub trait ISliderImpl: Sized {
    fn IntermediateValue(&mut self) -> ::windows::core::Result<f64>;
    fn SetIntermediateValue(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn StepFrequency(&mut self) -> ::windows::core::Result<f64>;
    fn SetStepFrequency(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn SnapsTo(&mut self) -> ::windows::core::Result<Primitives::SliderSnapsTo>;
    fn SetSnapsTo(&mut self, value: Primitives::SliderSnapsTo) -> ::windows::core::Result<()>;
    fn TickFrequency(&mut self) -> ::windows::core::Result<f64>;
    fn SetTickFrequency(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn TickPlacement(&mut self) -> ::windows::core::Result<Primitives::TickPlacement>;
    fn SetTickPlacement(&mut self, value: Primitives::TickPlacement) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn IsDirectionReversed(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDirectionReversed(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsThumbToolTipEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsThumbToolTipEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ThumbToolTipValueConverter(&mut self) -> ::windows::core::Result<super::Data::IValueConverter>;
    fn SetThumbToolTipValueConverter(&mut self, value: &::core::option::Option<super::Data::IValueConverter>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISlider {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISlider";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl ISliderVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISliderImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISliderVtbl {
        unsafe extern "system" fn IntermediateValue<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IntermediateValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIntermediateValue<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIntermediateValue(value).into()
        }
        unsafe extern "system" fn StepFrequency<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StepFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStepFrequency<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStepFrequency(value).into()
        }
        unsafe extern "system" fn SnapsTo<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SliderSnapsTo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SnapsTo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSnapsTo<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::SliderSnapsTo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSnapsTo(value).into()
        }
        unsafe extern "system" fn TickFrequency<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTickFrequency<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTickFrequency(value).into()
        }
        unsafe extern "system" fn TickPlacement<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::TickPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTickPlacement<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::TickPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTickPlacement(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn IsDirectionReversed<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDirectionReversed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDirectionReversed<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDirectionReversed(value).into()
        }
        unsafe extern "system" fn IsThumbToolTipEnabled<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsThumbToolTipEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsThumbToolTipEnabled<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsThumbToolTipEnabled(value).into()
        }
        unsafe extern "system" fn ThumbToolTipValueConverter<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ThumbToolTipValueConverter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetThumbToolTipValueConverter<Impl: ISliderImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetThumbToolTipValueConverter(&*(&value as *const <super::Data::IValueConverter as ::windows::core::Abi>::Abi as *const <super::Data::IValueConverter as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISlider, BASE_OFFSET>(),
            IntermediateValue: IntermediateValue::<Impl, IMPL_OFFSET>,
            SetIntermediateValue: SetIntermediateValue::<Impl, IMPL_OFFSET>,
            StepFrequency: StepFrequency::<Impl, IMPL_OFFSET>,
            SetStepFrequency: SetStepFrequency::<Impl, IMPL_OFFSET>,
            SnapsTo: SnapsTo::<Impl, IMPL_OFFSET>,
            SetSnapsTo: SetSnapsTo::<Impl, IMPL_OFFSET>,
            TickFrequency: TickFrequency::<Impl, IMPL_OFFSET>,
            SetTickFrequency: SetTickFrequency::<Impl, IMPL_OFFSET>,
            TickPlacement: TickPlacement::<Impl, IMPL_OFFSET>,
            SetTickPlacement: SetTickPlacement::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            IsDirectionReversed: IsDirectionReversed::<Impl, IMPL_OFFSET>,
            SetIsDirectionReversed: SetIsDirectionReversed::<Impl, IMPL_OFFSET>,
            IsThumbToolTipEnabled: IsThumbToolTipEnabled::<Impl, IMPL_OFFSET>,
            SetIsThumbToolTipEnabled: SetIsThumbToolTipEnabled::<Impl, IMPL_OFFSET>,
            ThumbToolTipValueConverter: ThumbToolTipValueConverter::<Impl, IMPL_OFFSET>,
            SetThumbToolTipValueConverter: SetThumbToolTipValueConverter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISlider as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISlider2Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISlider2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISlider2";
}
#[cfg(feature = "implement_exclusive")]
impl ISlider2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISlider2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISlider2Vtbl {
        unsafe extern "system" fn Header<Impl: ISlider2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ISlider2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ISlider2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ISlider2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISlider2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISlider2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Slider>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISliderFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISliderFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISliderFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISliderFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISliderFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderStaticsImpl: Sized {
    fn IntermediateValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StepFrequencyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SnapsToProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TickFrequencyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TickPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsDirectionReversedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsThumbToolTipEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ThumbToolTipValueConverterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISliderStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISliderStaticsVtbl {
        unsafe extern "system" fn IntermediateValueProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IntermediateValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StepFrequencyProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StepFrequencyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SnapsToProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SnapsToProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TickFrequencyProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickFrequencyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TickPlacementProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDirectionReversedProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDirectionReversedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsThumbToolTipEnabledProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsThumbToolTipEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ThumbToolTipValueConverterProperty<Impl: ISliderStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ThumbToolTipValueConverterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISliderStatics, BASE_OFFSET>(),
            IntermediateValueProperty: IntermediateValueProperty::<Impl, IMPL_OFFSET>,
            StepFrequencyProperty: StepFrequencyProperty::<Impl, IMPL_OFFSET>,
            SnapsToProperty: SnapsToProperty::<Impl, IMPL_OFFSET>,
            TickFrequencyProperty: TickFrequencyProperty::<Impl, IMPL_OFFSET>,
            TickPlacementProperty: TickPlacementProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            IsDirectionReversedProperty: IsDirectionReversedProperty::<Impl, IMPL_OFFSET>,
            IsThumbToolTipEnabledProperty: IsThumbToolTipEnabledProperty::<Impl, IMPL_OFFSET>,
            ThumbToolTipValueConverterProperty: ThumbToolTipValueConverterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISliderStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderStatics2Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISliderStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISliderStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ISliderStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ISliderStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISliderStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISliderStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait ISplitButtonImpl: Sized {
    fn Flyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn Command(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Click(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISplitButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButton";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ISplitButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonVtbl {
        unsafe extern "system" fn Flyout<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Flyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyout<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Click<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Click(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClick<Impl: ISplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButton, BASE_OFFSET>(),
            Flyout: Flyout::<Impl, IMPL_OFFSET>,
            SetFlyout: SetFlyout::<Impl, IMPL_OFFSET>,
            Command: Command::<Impl, IMPL_OFFSET>,
            SetCommand: SetCommand::<Impl, IMPL_OFFSET>,
            CommandParameter: CommandParameter::<Impl, IMPL_OFFSET>,
            SetCommandParameter: SetCommandParameter::<Impl, IMPL_OFFSET>,
            Click: Click::<Impl, IMPL_OFFSET>,
            RemoveClick: RemoveClick::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonAutomationPeerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonAutomationPeerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonAutomationPeerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonAutomationPeerVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonAutomationPeer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonAutomationPeer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonAutomationPeerFactoryImpl: Sized {
    fn CreateInstance(&mut self, owner: &::core::option::Option<SplitButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonAutomationPeerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonAutomationPeerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonAutomationPeerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitButtonAutomationPeerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <SplitButton as ::windows::core::Abi>::Abi as *const <SplitButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonAutomationPeerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonAutomationPeerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonClickEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonClickEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonClickEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonClickEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonClickEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonStaticsImpl: Sized {
    fn FlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonStaticsVtbl {
        unsafe extern "system" fn FlyoutProperty<Impl: ISplitButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: ISplitButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: ISplitButtonStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonStatics, BASE_OFFSET>(),
            FlyoutProperty: FlyoutProperty::<Impl, IMPL_OFFSET>,
            CommandProperty: CommandProperty::<Impl, IMPL_OFFSET>,
            CommandParameterProperty: CommandParameterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ISplitViewImpl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn IsPaneOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn OpenPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetOpenPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCompactPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn PanePlacement(&mut self) -> ::windows::core::Result<SplitViewPanePlacement>;
    fn SetPanePlacement(&mut self, value: SplitViewPanePlacement) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<SplitViewDisplayMode>;
    fn SetDisplayMode(&mut self, value: SplitViewDisplayMode) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::SplitViewTemplateSettings>;
    fn PaneBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPaneBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PaneClosing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISplitView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ISplitViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewVtbl {
        unsafe extern "system" fn Content<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPaneOpen<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneOpen<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneOpen(value).into()
        }
        unsafe extern "system" fn OpenPaneLength<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpenPaneLength<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpenPaneLength(value).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactPaneLength<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCompactPaneLength(value).into()
        }
        unsafe extern "system" fn PanePlacement<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SplitViewPanePlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanePlacement<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SplitViewPanePlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanePlacement(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SplitViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SplitViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneBackground<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneBackground<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosing<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosing<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosed<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosed<Impl: ISplitViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitView, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            Pane: Pane::<Impl, IMPL_OFFSET>,
            SetPane: SetPane::<Impl, IMPL_OFFSET>,
            IsPaneOpen: IsPaneOpen::<Impl, IMPL_OFFSET>,
            SetIsPaneOpen: SetIsPaneOpen::<Impl, IMPL_OFFSET>,
            OpenPaneLength: OpenPaneLength::<Impl, IMPL_OFFSET>,
            SetOpenPaneLength: SetOpenPaneLength::<Impl, IMPL_OFFSET>,
            CompactPaneLength: CompactPaneLength::<Impl, IMPL_OFFSET>,
            SetCompactPaneLength: SetCompactPaneLength::<Impl, IMPL_OFFSET>,
            PanePlacement: PanePlacement::<Impl, IMPL_OFFSET>,
            SetPanePlacement: SetPanePlacement::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            SetDisplayMode: SetDisplayMode::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            PaneBackground: PaneBackground::<Impl, IMPL_OFFSET>,
            SetPaneBackground: SetPaneBackground::<Impl, IMPL_OFFSET>,
            PaneClosing: PaneClosing::<Impl, IMPL_OFFSET>,
            RemovePaneClosing: RemovePaneClosing::<Impl, IMPL_OFFSET>,
            PaneClosed: PaneClosed::<Impl, IMPL_OFFSET>,
            RemovePaneClosed: RemovePaneClosed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitView2Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView2";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitView2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitView2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitView2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ISplitView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ISplitView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitView2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISplitView3Impl: Sized {
    fn PaneOpening(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISplitView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ISplitView3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitView3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitView3Vtbl {
        unsafe extern "system" fn PaneOpening<Impl: ISplitView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpening(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpening<Impl: ISplitView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpened<Impl: ISplitView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpened<Impl: ISplitView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitView3, BASE_OFFSET>(),
            PaneOpening: PaneOpening::<Impl, IMPL_OFFSET>,
            RemovePaneOpening: RemovePaneOpening::<Impl, IMPL_OFFSET>,
            PaneOpened: PaneOpened::<Impl, IMPL_OFFSET>,
            RemovePaneOpened: RemovePaneOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitView3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewPaneClosingEventArgsImpl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewPaneClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewPaneClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewPaneClosingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewPaneClosingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewPaneClosingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: ISplitViewPaneClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ISplitViewPaneClosingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewPaneClosingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewPaneClosingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewStaticsImpl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpenPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PanePlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneOpenProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenPaneLengthProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanePlacementProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneBackgroundProperty<Impl: ISplitViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            PaneProperty: PaneProperty::<Impl, IMPL_OFFSET>,
            IsPaneOpenProperty: IsPaneOpenProperty::<Impl, IMPL_OFFSET>,
            OpenPaneLengthProperty: OpenPaneLengthProperty::<Impl, IMPL_OFFSET>,
            CompactPaneLengthProperty: CompactPaneLengthProperty::<Impl, IMPL_OFFSET>,
            PanePlacementProperty: PanePlacementProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            TemplateSettingsProperty: TemplateSettingsProperty::<Impl, IMPL_OFFSET>,
            PaneBackgroundProperty: PaneBackgroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ISplitViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelImpl: Sized {
    fn AreScrollSnapPointsRegular(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreScrollSnapPointsRegular(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegular<Impl: IStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegular() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreScrollSnapPointsRegular<Impl: IStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreScrollSnapPointsRegular(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel, BASE_OFFSET>(),
            AreScrollSnapPointsRegular: AreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            SetAreScrollSnapPointsRegular: SetAreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IStackPanel2Impl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IStackPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IStackPanel2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanel2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanel2Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IStackPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel2, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel4Impl: Sized {
    fn Spacing(&mut self) -> ::windows::core::Result<f64>;
    fn SetSpacing(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel4";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanel4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanel4Vtbl {
        unsafe extern "system" fn Spacing<Impl: IStackPanel4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Spacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSpacing<Impl: IStackPanel4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSpacing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel4, BASE_OFFSET>(),
            Spacing: Spacing::<Impl, IMPL_OFFSET>,
            SetSpacing: SetSpacing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel5Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel5";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanel5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanel5Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IStackPanel5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IStackPanel5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel5, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<StackPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IStackPanelFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStaticsImpl: Sized {
    fn AreScrollSnapPointsRegularProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStaticsVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegularProperty<Impl: IStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegularProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics, BASE_OFFSET>(),
            AreScrollSnapPointsRegularProperty: AreScrollSnapPointsRegularProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics2Impl: Sized {
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStatics2Vtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IStackPanelStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IStackPanelStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IStackPanelStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IStackPanelStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics2, BASE_OFFSET>(),
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics4Impl: Sized {
    fn SpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStatics4Vtbl {
        unsafe extern "system" fn SpacingProperty<Impl: IStackPanelStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics4, BASE_OFFSET>(),
            SpacingProperty: SpacingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics5Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStatics5Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IStackPanelStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics5, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorImpl: Sized {
    fn SelectStyle(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::Style>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStyleSelectorImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStyleSelectorVtbl {
        unsafe extern "system" fn SelectStyle<Impl: IStyleSelectorImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectStyle(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IStyleSelector, BASE_OFFSET>(), SelectStyle: SelectStyle::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStyleSelector as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<StyleSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStyleSelectorFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStyleSelectorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IStyleSelectorFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStyleSelectorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStyleSelectorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorOverridesImpl: Sized {
    fn SelectStyleCore(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::Style>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStyleSelectorOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStyleSelectorOverridesVtbl {
        unsafe extern "system" fn SelectStyleCore<Impl: IStyleSelectorOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectStyleCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStyleSelectorOverrides, BASE_OFFSET>(),
            SelectStyleCore: SelectStyleCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStyleSelectorOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainBackgroundPanelImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainBackgroundPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainBackgroundPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainBackgroundPanelVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainBackgroundPanel, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainBackgroundPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Core", feature = "implement_exclusive"))]
pub trait ISwapChainBackgroundPanel2Impl: Sized {
    fn CreateCoreIndependentInputSource(&mut self, devicetypes: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<super::super::Core::CoreIndependentInputSource>;
}
#[cfg(all(feature = "UI_Core", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel2";
}
#[cfg(all(feature = "UI_Core", feature = "implement_exclusive"))]
impl ISwapChainBackgroundPanel2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainBackgroundPanel2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainBackgroundPanel2Vtbl {
        unsafe extern "system" fn CreateCoreIndependentInputSource<Impl: ISwapChainBackgroundPanel2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, devicetypes: super::super::Core::CoreInputDeviceTypes, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateCoreIndependentInputSource(devicetypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainBackgroundPanel2, BASE_OFFSET>(),
            CreateCoreIndependentInputSource: CreateCoreIndependentInputSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainBackgroundPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainBackgroundPanelFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwapChainBackgroundPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainBackgroundPanelFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainBackgroundPanelFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainBackgroundPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwapChainBackgroundPanelFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainBackgroundPanelFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainBackgroundPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Core", feature = "implement_exclusive"))]
pub trait ISwapChainPanelImpl: Sized {
    fn CompositionScaleX(&mut self) -> ::windows::core::Result<f32>;
    fn CompositionScaleY(&mut self) -> ::windows::core::Result<f32>;
    fn CompositionScaleChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCompositionScaleChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CreateCoreIndependentInputSource(&mut self, devicetypes: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<super::super::Core::CoreIndependentInputSource>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Core", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISwapChainPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanel";
}
#[cfg(all(feature = "Foundation", feature = "UI_Core", feature = "implement_exclusive"))]
impl ISwapChainPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainPanelVtbl {
        unsafe extern "system" fn CompositionScaleX<Impl: ISwapChainPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleX() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleY<Impl: ISwapChainPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleY() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleChanged<Impl: ISwapChainPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCompositionScaleChanged<Impl: ISwapChainPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCompositionScaleChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CreateCoreIndependentInputSource<Impl: ISwapChainPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, devicetypes: super::super::Core::CoreInputDeviceTypes, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateCoreIndependentInputSource(devicetypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainPanel, BASE_OFFSET>(),
            CompositionScaleX: CompositionScaleX::<Impl, IMPL_OFFSET>,
            CompositionScaleY: CompositionScaleY::<Impl, IMPL_OFFSET>,
            CompositionScaleChanged: CompositionScaleChanged::<Impl, IMPL_OFFSET>,
            RemoveCompositionScaleChanged: RemoveCompositionScaleChanged::<Impl, IMPL_OFFSET>,
            CreateCoreIndependentInputSource: CreateCoreIndependentInputSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainPanelFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwapChainPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainPanelFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainPanelFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwapChainPanelFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainPanelFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainPanelStaticsImpl: Sized {
    fn CompositionScaleXProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompositionScaleYProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainPanelStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainPanelStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainPanelStaticsVtbl {
        unsafe extern "system" fn CompositionScaleXProperty<Impl: ISwapChainPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleXProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleYProperty<Impl: ISwapChainPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleYProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainPanelStatics, BASE_OFFSET>(),
            CompositionScaleXProperty: CompositionScaleXProperty::<Impl, IMPL_OFFSET>,
            CompositionScaleYProperty: CompositionScaleYProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlImpl: Sized {
    fn LeftItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetLeftItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn RightItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetRightItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn TopItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetTopItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn BottomItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetBottomItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControl";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeControlImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeControlVtbl {
        unsafe extern "system" fn LeftItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TopItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BottomItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBottomItems<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBottomItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Close<Impl: ISwipeControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeControl, BASE_OFFSET>(),
            LeftItems: LeftItems::<Impl, IMPL_OFFSET>,
            SetLeftItems: SetLeftItems::<Impl, IMPL_OFFSET>,
            RightItems: RightItems::<Impl, IMPL_OFFSET>,
            SetRightItems: SetRightItems::<Impl, IMPL_OFFSET>,
            TopItems: TopItems::<Impl, IMPL_OFFSET>,
            SetTopItems: SetTopItems::<Impl, IMPL_OFFSET>,
            BottomItems: BottomItems::<Impl, IMPL_OFFSET>,
            SetBottomItems: SetBottomItems::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeControlFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeControlFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlStaticsImpl: Sized {
    fn LeftItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BottomItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeControlStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeControlStaticsVtbl {
        unsafe extern "system" fn LeftItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BottomItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeControlStatics, BASE_OFFSET>(),
            LeftItemsProperty: LeftItemsProperty::<Impl, IMPL_OFFSET>,
            RightItemsProperty: RightItemsProperty::<Impl, IMPL_OFFSET>,
            TopItemsProperty: TopItemsProperty::<Impl, IMPL_OFFSET>,
            BottomItemsProperty: BottomItemsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ISwipeItemImpl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IconSource(&mut self) -> ::windows::core::Result<IconSource>;
    fn SetIconSource(&mut self, value: &::core::option::Option<IconSource>) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn Command(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn BehaviorOnInvoked(&mut self) -> ::windows::core::Result<SwipeBehaviorOnInvoked>;
    fn SetBehaviorOnInvoked(&mut self, value: SwipeBehaviorOnInvoked) -> ::windows::core::Result<()>;
    fn Invoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISwipeItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItem";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ISwipeItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemVtbl {
        unsafe extern "system" fn Text<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IconSource<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <IconSource as ::windows::core::Abi>::Abi as *const <IconSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Foreground<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BehaviorOnInvoked<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SwipeBehaviorOnInvoked) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BehaviorOnInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBehaviorOnInvoked<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SwipeBehaviorOnInvoked) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBehaviorOnInvoked(value).into()
        }
        unsafe extern "system" fn Invoked<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Invoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveInvoked<Impl: ISwipeItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItem, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            IconSource: IconSource::<Impl, IMPL_OFFSET>,
            SetIconSource: SetIconSource::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            Command: Command::<Impl, IMPL_OFFSET>,
            SetCommand: SetCommand::<Impl, IMPL_OFFSET>,
            CommandParameter: CommandParameter::<Impl, IMPL_OFFSET>,
            SetCommandParameter: SetCommandParameter::<Impl, IMPL_OFFSET>,
            BehaviorOnInvoked: BehaviorOnInvoked::<Impl, IMPL_OFFSET>,
            SetBehaviorOnInvoked: SetBehaviorOnInvoked::<Impl, IMPL_OFFSET>,
            Invoked: Invoked::<Impl, IMPL_OFFSET>,
            RemoveInvoked: RemoveInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemInvokedEventArgsImpl: Sized {
    fn SwipeControl(&mut self) -> ::windows::core::Result<SwipeControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemInvokedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemInvokedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemInvokedEventArgsVtbl {
        unsafe extern "system" fn SwipeControl<Impl: ISwipeItemInvokedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SwipeControl() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemInvokedEventArgs, BASE_OFFSET>(),
            SwipeControl: SwipeControl::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemInvokedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemStaticsImpl: Sized {
    fn IconSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BehaviorOnInvokedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemStaticsVtbl {
        unsafe extern "system" fn IconSourceProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BehaviorOnInvokedProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BehaviorOnInvokedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemStatics, BASE_OFFSET>(),
            IconSourceProperty: IconSourceProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            CommandProperty: CommandProperty::<Impl, IMPL_OFFSET>,
            CommandParameterProperty: CommandParameterProperty::<Impl, IMPL_OFFSET>,
            BehaviorOnInvokedProperty: BehaviorOnInvokedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsImpl: Sized {
    fn Mode(&mut self) -> ::windows::core::Result<SwipeMode>;
    fn SetMode(&mut self, value: SwipeMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItems {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItems";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemsVtbl {
        unsafe extern "system" fn Mode<Impl: ISwipeItemsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SwipeMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: ISwipeItemsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SwipeMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItems, BASE_OFFSET>(),
            Mode: Mode::<Impl, IMPL_OFFSET>,
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItems as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeItems>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemsFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeItemsFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemsFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsStaticsImpl: Sized {
    fn ModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemsStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemsStaticsVtbl {
        unsafe extern "system" fn ModeProperty<Impl: ISwipeItemsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemsStatics, BASE_OFFSET>(), ModeProperty: ModeProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconImpl: Sized {
    fn Symbol(&mut self) -> ::windows::core::Result<Symbol>;
    fn SetSymbol(&mut self, value: Symbol) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIcon";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconVtbl {
        unsafe extern "system" fn Symbol<Impl: ISymbolIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Symbol() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbol<Impl: ISymbolIconImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSymbol(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIcon, BASE_OFFSET>(),
            Symbol: Symbol::<Impl, IMPL_OFFSET>,
            SetSymbol: SetSymbol::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconFactoryImpl: Sized {
    fn CreateInstanceWithSymbol(&mut self, symbol: Symbol) -> ::windows::core::Result<SymbolIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconFactoryVtbl {
        unsafe extern "system" fn CreateInstanceWithSymbol<Impl: ISymbolIconFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symbol: Symbol, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithSymbol(symbol) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconFactory, BASE_OFFSET>(),
            CreateInstanceWithSymbol: CreateInstanceWithSymbol::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceImpl: Sized {
    fn Symbol(&mut self) -> ::windows::core::Result<Symbol>;
    fn SetSymbol(&mut self, value: Symbol) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSource";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconSourceImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconSourceVtbl {
        unsafe extern "system" fn Symbol<Impl: ISymbolIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Symbol() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbol<Impl: ISymbolIconSourceImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSymbol(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconSource, BASE_OFFSET>(),
            Symbol: Symbol::<Impl, IMPL_OFFSET>,
            SetSymbol: SetSymbol::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SymbolIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconSourceFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISymbolIconSourceFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceStaticsImpl: Sized {
    fn SymbolProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconSourceStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconSourceStaticsVtbl {
        unsafe extern "system" fn SymbolProperty<Impl: ISymbolIconSourceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SymbolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconSourceStatics, BASE_OFFSET>(),
            SymbolProperty: SymbolProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconStaticsImpl: Sized {
    fn SymbolProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconStaticsVtbl {
        unsafe extern "system" fn SymbolProperty<Impl: ISymbolIconStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SymbolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconStatics, BASE_OFFSET>(), SymbolProperty: SymbolProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBlockImpl: Sized {
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn TextTrimming(&mut self) -> ::windows::core::Result<super::TextTrimming>;
    fn SetTextTrimming(&mut self, value: super::TextTrimming) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Inlines(&mut self) -> ::windows::core::Result<super::Documents::InlineCollection>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn LineHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&mut self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&mut self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn IsTextSelectionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextSelectionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SelectedText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ContentStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn Select(&mut self, start: &::core::option::Option<super::Documents::TextPointer>, end: &::core::option::Option<super::Documents::TextPointer>) -> ::windows::core::Result<()>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBlockVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockVtbl {
        unsafe extern "system" fn FontSize<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn TextTrimming<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimming() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextTrimming<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextTrimming(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn Text<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Inlines<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Inlines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Padding<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineHeight<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn IsTextSelectionEnabled<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSelectionEnabled<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextSelectionEnabled(value).into()
        }
        unsafe extern "system" fn SelectedText<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionStart<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionEnd<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn Select<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: ::windows::core::RawPtr, end: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Select(&*(&start as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType), &*(&end as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Focus<Impl: ITextBlockImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock, BASE_OFFSET>(),
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            TextTrimming: TextTrimming::<Impl, IMPL_OFFSET>,
            SetTextTrimming: SetTextTrimming::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            Inlines: Inlines::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            LineHeight: LineHeight::<Impl, IMPL_OFFSET>,
            SetLineHeight: SetLineHeight::<Impl, IMPL_OFFSET>,
            LineStackingStrategy: LineStackingStrategy::<Impl, IMPL_OFFSET>,
            SetLineStackingStrategy: SetLineStackingStrategy::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabled: IsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextSelectionEnabled: SetIsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            SelectedText: SelectedText::<Impl, IMPL_OFFSET>,
            ContentStart: ContentStart::<Impl, IMPL_OFFSET>,
            ContentEnd: ContentEnd::<Impl, IMPL_OFFSET>,
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionEnd: SelectionEnd::<Impl, IMPL_OFFSET>,
            BaselineOffset: BaselineOffset::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            Select: Select::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBlock2Impl: Sized {
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TextLineBounds(&mut self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&mut self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
    fn OpticalMarginAlignment(&mut self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&mut self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBlock2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock2Vtbl {
        unsafe extern "system" fn SelectionHighlightColor<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxLines<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        unsafe extern "system" fn OpticalMarginAlignment<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: ITextBlock2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock2, BASE_OFFSET>(),
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
            TextLineBounds: TextLineBounds::<Impl, IMPL_OFFSET>,
            SetTextLineBounds: SetTextLineBounds::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignment: OpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            SetOpticalMarginAlignment: SetOpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock3Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: ITextBlock3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: ITextBlock3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock3, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
pub trait ITextBlock4Impl: Sized {
    fn GetAlphaMask(&mut self) -> ::windows::core::Result<super::super::Composition::CompositionBrush>;
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock4";
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl ITextBlock4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock4Vtbl {
        unsafe extern "system" fn GetAlphaMask<Impl: ITextBlock4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlphaMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock4, BASE_OFFSET>(), GetAlphaMask: GetAlphaMask::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
pub trait ITextBlock5Impl: Sized {
    fn TextDecorations(&mut self) -> ::windows::core::Result<super::super::Text::TextDecorations>;
    fn SetTextDecorations(&mut self, value: super::super::Text::TextDecorations) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock5";
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl ITextBlock5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock5Vtbl {
        unsafe extern "system" fn TextDecorations<Impl: ITextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorations() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextDecorations<Impl: ITextBlock5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextDecorations(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock5, BASE_OFFSET>(),
            TextDecorations: TextDecorations::<Impl, IMPL_OFFSET>,
            SetTextDecorations: SetTextDecorations::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait ITextBlock6Impl: Sized {
    fn IsTextTrimmed(&mut self) -> ::windows::core::Result<bool>;
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextHighlighters(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Documents::TextHighlighter>>;
    fn IsTextTrimmedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock6";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ITextBlock6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock6Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: ITextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignment<Impl: ITextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: ITextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn TextHighlighters<Impl: ITextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextHighlighters() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: ITextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: ITextBlock6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock6, BASE_OFFSET>(),
            IsTextTrimmed: IsTextTrimmed::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            TextHighlighters: TextHighlighters::<Impl, IMPL_OFFSET>,
            IsTextTrimmedChanged: IsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsTextTrimmedChanged: RemoveIsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait ITextBlock7Impl: Sized {
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock7";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ITextBlock7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock7Vtbl {
        unsafe extern "system" fn SelectionFlyout<Impl: ITextBlock7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: ITextBlock7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: ITextBlock7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock7, BASE_OFFSET>(),
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            CopySelectionToClipboard: CopySelectionToClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStaticsImpl: Sized {
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextTrimmingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSelectionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStaticsVtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextTrimmingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimmingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSelectionEnabledProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedTextProperty<Impl: ITextBlockStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics, BASE_OFFSET>(),
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            TextTrimmingProperty: TextTrimmingProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            LineHeightProperty: LineHeightProperty::<Impl, IMPL_OFFSET>,
            LineStackingStrategyProperty: LineStackingStrategyProperty::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabledProperty: IsTextSelectionEnabledProperty::<Impl, IMPL_OFFSET>,
            SelectedTextProperty: SelectedTextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics2Impl: Sized {
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpticalMarginAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics2Vtbl {
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: ITextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLinesProperty<Impl: ITextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: ITextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: ITextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: ITextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: ITextBlockStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics2, BASE_OFFSET>(),
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
            TextLineBoundsProperty: TextLineBoundsProperty::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignmentProperty: OpticalMarginAlignmentProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics3Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: ITextBlockStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics3, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics5Impl: Sized {
    fn TextDecorationsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics5Vtbl {
        unsafe extern "system" fn TextDecorationsProperty<Impl: ITextBlockStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorationsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics5, BASE_OFFSET>(),
            TextDecorationsProperty: TextDecorationsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics6Impl: Sized {
    fn IsTextTrimmedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics6Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: ITextBlockStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: ITextBlockStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics6, BASE_OFFSET>(),
            IsTextTrimmedProperty: IsTextTrimmedProperty::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics7Impl: Sized {
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics7Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: ITextBlockStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics7, BASE_OFFSET>(),
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait ITextBoxImpl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectedText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSelectedText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectionLength(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectionStart(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectionStart(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn IsReadOnly(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AcceptsReturn(&mut self) -> ::windows::core::Result<bool>;
    fn SetAcceptsReturn(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn IsSpellCheckEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSpellCheckEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsTextPredictionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextPredictionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn InputScope(&mut self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&mut self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
    fn TextChanged(&mut self, handler: &::core::option::Option<TextChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Select(&mut self, start: i32, length: i32) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn GetRectFromCharacterIndex(&mut self, charindex: i32, trailingedge: bool) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ITextBoxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxVtbl {
        unsafe extern "system" fn Text<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedText<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedText<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionLength<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionLength<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionLength(value).into()
        }
        unsafe extern "system" fn SelectionStart<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionStart<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionStart(value).into()
        }
        unsafe extern "system" fn MaxLength<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        unsafe extern "system" fn IsReadOnly<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn AcceptsReturn<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAcceptsReturn<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAcceptsReturn(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn IsSpellCheckEnabled<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSpellCheckEnabled<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSpellCheckEnabled(value).into()
        }
        unsafe extern "system" fn IsTextPredictionEnabled<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextPredictionEnabled<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextPredictionEnabled(value).into()
        }
        unsafe extern "system" fn InputScope<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <TextChangedEventHandler as ::windows::core::Abi>::Abi as *const <TextChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Select<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: i32, length: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Select(start, length).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn GetRectFromCharacterIndex<Impl: ITextBoxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, charindex: i32, trailingedge: bool, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRectFromCharacterIndex(charindex, trailingedge) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            SelectedText: SelectedText::<Impl, IMPL_OFFSET>,
            SetSelectedText: SetSelectedText::<Impl, IMPL_OFFSET>,
            SelectionLength: SelectionLength::<Impl, IMPL_OFFSET>,
            SetSelectionLength: SetSelectionLength::<Impl, IMPL_OFFSET>,
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SetSelectionStart: SetSelectionStart::<Impl, IMPL_OFFSET>,
            MaxLength: MaxLength::<Impl, IMPL_OFFSET>,
            SetMaxLength: SetMaxLength::<Impl, IMPL_OFFSET>,
            IsReadOnly: IsReadOnly::<Impl, IMPL_OFFSET>,
            SetIsReadOnly: SetIsReadOnly::<Impl, IMPL_OFFSET>,
            AcceptsReturn: AcceptsReturn::<Impl, IMPL_OFFSET>,
            SetAcceptsReturn: SetAcceptsReturn::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabled: IsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            SetIsSpellCheckEnabled: SetIsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabled: IsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextPredictionEnabled: SetIsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            InputScope: InputScope::<Impl, IMPL_OFFSET>,
            SetInputScope: SetInputScope::<Impl, IMPL_OFFSET>,
            TextChanged: TextChanged::<Impl, IMPL_OFFSET>,
            RemoveTextChanged: RemoveTextChanged::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            Select: Select::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            GetRectFromCharacterIndex: GetRectFromCharacterIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBox2Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&mut self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBox2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox2Vtbl {
        unsafe extern "system" fn Header<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn Paste<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: ITextBox2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus: PreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus: SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            Paste: Paste::<Impl, IMPL_OFFSET>,
            RemovePaste: RemovePaste::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITextBox3Impl: Sized {
    fn TextCompositionStarted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionEnded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionEnded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn DesiredCandidateWindowAlignment(&mut self) -> ::windows::core::Result<CandidateWindowAlignment>;
    fn SetDesiredCandidateWindowAlignment(&mut self, value: CandidateWindowAlignment) -> ::windows::core::Result<()>;
    fn CandidateWindowBoundsChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidateWindowBoundsChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITextBox3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox3Vtbl {
        unsafe extern "system" fn TextCompositionStarted<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionStarted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionStarted<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionChanged<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionChanged<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionEnded<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionEnded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionEnded<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn DesiredCandidateWindowAlignment<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDesiredCandidateWindowAlignment<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDesiredCandidateWindowAlignment(value).into()
        }
        unsafe extern "system" fn CandidateWindowBoundsChanged<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidateWindowBoundsChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidateWindowBoundsChanged<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCandidateWindowBoundsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanging<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanging<Impl: ITextBox3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox3, BASE_OFFSET>(),
            TextCompositionStarted: TextCompositionStarted::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionStarted: RemoveTextCompositionStarted::<Impl, IMPL_OFFSET>,
            TextCompositionChanged: TextCompositionChanged::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionChanged: RemoveTextCompositionChanged::<Impl, IMPL_OFFSET>,
            TextCompositionEnded: TextCompositionEnded::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionEnded: RemoveTextCompositionEnded::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
            DesiredCandidateWindowAlignment: DesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            SetDesiredCandidateWindowAlignment: SetDesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            CandidateWindowBoundsChanged: CandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            RemoveCandidateWindowBoundsChanged: RemoveCandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            TextChanging: TextChanging::<Impl, IMPL_OFFSET>,
            RemoveTextChanging: RemoveTextChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITextBox4Impl: Sized {
    fn GetLinguisticAlternativesAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITextBox4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox4Vtbl {
        unsafe extern "system" fn GetLinguisticAlternativesAsync<Impl: ITextBox4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLinguisticAlternativesAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox4, BASE_OFFSET>(),
            GetLinguisticAlternativesAsync: GetLinguisticAlternativesAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBox5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocused(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColorWhenNotFocused(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox5";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBox5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocused<Impl: ITextBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColorWhenNotFocused<Impl: ITextBox5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColorWhenNotFocused(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocused: SelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColorWhenNotFocused: SetSelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBox6Impl: Sized {
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn CharacterCasing(&mut self) -> ::windows::core::Result<CharacterCasing>;
    fn SetCharacterCasing(&mut self, value: CharacterCasing) -> ::windows::core::Result<()>;
    fn PlaceholderForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPlaceholderForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CopyingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCopyingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CuttingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCuttingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn BeforeTextChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBeforeTextChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox6";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBox6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignment<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn CharacterCasing<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterCasing<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterCasing(value).into()
        }
        unsafe extern "system" fn PlaceholderForeground<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderForeground<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopyingToClipboard<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CopyingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCopyingToClipboard<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCopyingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CuttingToClipboard<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CuttingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCuttingToClipboard<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCuttingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BeforeTextChanging<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BeforeTextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBeforeTextChanging<Impl: ITextBox6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBeforeTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox6, BASE_OFFSET>(),
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            CharacterCasing: CharacterCasing::<Impl, IMPL_OFFSET>,
            SetCharacterCasing: SetCharacterCasing::<Impl, IMPL_OFFSET>,
            PlaceholderForeground: PlaceholderForeground::<Impl, IMPL_OFFSET>,
            SetPlaceholderForeground: SetPlaceholderForeground::<Impl, IMPL_OFFSET>,
            CopyingToClipboard: CopyingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCopyingToClipboard: RemoveCopyingToClipboard::<Impl, IMPL_OFFSET>,
            CuttingToClipboard: CuttingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCuttingToClipboard: RemoveCuttingToClipboard::<Impl, IMPL_OFFSET>,
            BeforeTextChanging: BeforeTextChanging::<Impl, IMPL_OFFSET>,
            RemoveBeforeTextChanging: RemoveBeforeTextChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox7Impl: Sized {
    fn HandwritingView(&mut self) -> ::windows::core::Result<HandwritingView>;
    fn SetHandwritingView(&mut self, value: &::core::option::Option<HandwritingView>) -> ::windows::core::Result<()>;
    fn IsHandwritingViewEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHandwritingViewEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox7Vtbl {
        unsafe extern "system" fn HandwritingView<Impl: ITextBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandwritingView<Impl: ITextBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandwritingView(&*(&value as *const <HandwritingView as ::windows::core::Abi>::Abi as *const <HandwritingView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHandwritingViewEnabled<Impl: ITextBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHandwritingViewEnabled<Impl: ITextBox7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHandwritingViewEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox7, BASE_OFFSET>(),
            HandwritingView: HandwritingView::<Impl, IMPL_OFFSET>,
            SetHandwritingView: SetHandwritingView::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabled: IsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
            SetIsHandwritingViewEnabled: SetIsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait ITextBox8Impl: Sized {
    fn CanPasteClipboardContent(&mut self) -> ::windows::core::Result<bool>;
    fn CanUndo(&mut self) -> ::windows::core::Result<bool>;
    fn CanRedo(&mut self) -> ::windows::core::Result<bool>;
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn ProofingMenuFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectionChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Undo(&mut self) -> ::windows::core::Result<()>;
    fn Redo(&mut self) -> ::windows::core::Result<()>;
    fn PasteFromClipboard(&mut self) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
    fn CutSelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
    fn ClearUndoRedoHistory(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox8";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ITextBox8Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox8Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox8Vtbl {
        unsafe extern "system" fn CanPasteClipboardContent<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUndo<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanUndo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanRedo<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanRedo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ProofingMenuFlyout<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanging<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanging<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Undo<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Undo().into()
        }
        unsafe extern "system" fn Redo<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Redo().into()
        }
        unsafe extern "system" fn PasteFromClipboard<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PasteFromClipboard().into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        unsafe extern "system" fn CutSelectionToClipboard<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CutSelectionToClipboard().into()
        }
        unsafe extern "system" fn ClearUndoRedoHistory<Impl: ITextBox8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearUndoRedoHistory().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox8, BASE_OFFSET>(),
            CanPasteClipboardContent: CanPasteClipboardContent::<Impl, IMPL_OFFSET>,
            CanUndo: CanUndo::<Impl, IMPL_OFFSET>,
            CanRedo: CanRedo::<Impl, IMPL_OFFSET>,
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyout: ProofingMenuFlyout::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            SelectionChanging: SelectionChanging::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanging: RemoveSelectionChanging::<Impl, IMPL_OFFSET>,
            Undo: Undo::<Impl, IMPL_OFFSET>,
            Redo: Redo::<Impl, IMPL_OFFSET>,
            PasteFromClipboard: PasteFromClipboard::<Impl, IMPL_OFFSET>,
            CopySelectionToClipboard: CopySelectionToClipboard::<Impl, IMPL_OFFSET>,
            CutSelectionToClipboard: CutSelectionToClipboard::<Impl, IMPL_OFFSET>,
            ClearUndoRedoHistory: ClearUndoRedoHistory::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxBeforeTextChangingEventArgsImpl: Sized {
    fn NewText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxBeforeTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxBeforeTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxBeforeTextChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxBeforeTextChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxBeforeTextChangingEventArgsVtbl {
        unsafe extern "system" fn NewText<Impl: ITextBoxBeforeTextChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ITextBoxBeforeTextChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITextBoxBeforeTextChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxBeforeTextChangingEventArgs, BASE_OFFSET>(),
            NewText: NewText::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxBeforeTextChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TextBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITextBoxFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxSelectionChangingEventArgsImpl: Sized {
    fn SelectionStart(&mut self) -> ::windows::core::Result<i32>;
    fn SelectionLength(&mut self) -> ::windows::core::Result<i32>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxSelectionChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxSelectionChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxSelectionChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxSelectionChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxSelectionChangingEventArgsVtbl {
        unsafe extern "system" fn SelectionStart<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionLength<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxSelectionChangingEventArgs, BASE_OFFSET>(),
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionLength: SelectionLength::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxSelectionChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStaticsImpl: Sized {
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsReadOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AcceptsReturnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSpellCheckEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextPredictionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStaticsVtbl {
        unsafe extern "system" fn TextProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsReadOnlyProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptsReturnProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSpellCheckEnabledProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextPredictionEnabledProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: ITextBoxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics, BASE_OFFSET>(),
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            MaxLengthProperty: MaxLengthProperty::<Impl, IMPL_OFFSET>,
            IsReadOnlyProperty: IsReadOnlyProperty::<Impl, IMPL_OFFSET>,
            AcceptsReturnProperty: AcceptsReturnProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabledProperty: IsSpellCheckEnabledProperty::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabledProperty: IsTextPredictionEnabledProperty::<Impl, IMPL_OFFSET>,
            InputScopeProperty: InputScopeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics2Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ITextBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ITextBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ITextBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: ITextBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: ITextBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: ITextBoxStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocusProperty: PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics3Impl: Sized {
    fn DesiredCandidateWindowAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics3Vtbl {
        unsafe extern "system" fn DesiredCandidateWindowAlignmentProperty<Impl: ITextBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: ITextBoxStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics3, BASE_OFFSET>(),
            DesiredCandidateWindowAlignmentProperty: DesiredCandidateWindowAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocusedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocusedProperty<Impl: ITextBoxStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocusedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocusedProperty: SelectionHighlightColorWhenNotFocusedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics6Impl: Sized {
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterCasingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: ITextBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterCasingProperty<Impl: ITextBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderForegroundProperty<Impl: ITextBoxStatics6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics6, BASE_OFFSET>(),
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
            CharacterCasingProperty: CharacterCasingProperty::<Impl, IMPL_OFFSET>,
            PlaceholderForegroundProperty: PlaceholderForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics7Impl: Sized {
    fn HandwritingViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHandwritingViewEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics7Vtbl {
        unsafe extern "system" fn HandwritingViewProperty<Impl: ITextBoxStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHandwritingViewEnabledProperty<Impl: ITextBoxStatics7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics7, BASE_OFFSET>(),
            HandwritingViewProperty: HandwritingViewProperty::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabledProperty: IsHandwritingViewEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics8Impl: Sized {
    fn CanPasteClipboardContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanUndoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanRedoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProofingMenuFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics8";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics8Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics8Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics8Vtbl {
        unsafe extern "system" fn CanPasteClipboardContentProperty<Impl: ITextBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUndoProperty<Impl: ITextBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanUndoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanRedoProperty<Impl: ITextBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanRedoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: ITextBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProofingMenuFlyoutProperty<Impl: ITextBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: ITextBoxStatics8Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics8, BASE_OFFSET>(),
            CanPasteClipboardContentProperty: CanPasteClipboardContentProperty::<Impl, IMPL_OFFSET>,
            CanUndoProperty: CanUndoProperty::<Impl, IMPL_OFFSET>,
            CanRedoProperty: CanRedoProperty::<Impl, IMPL_OFFSET>,
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyoutProperty: ProofingMenuFlyoutProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxTextChangingEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxTextChangingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxTextChangingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxTextChangingEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxTextChangingEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxTextChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxTextChangingEventArgs2Impl: Sized {
    fn IsContentChanging(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxTextChangingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxTextChangingEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxTextChangingEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxTextChangingEventArgs2Vtbl {
        unsafe extern "system" fn IsContentChanging<Impl: ITextBoxTextChangingEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxTextChangingEventArgs2, BASE_OFFSET>(),
            IsContentChanging: IsContentChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxTextChangingEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextChangedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextChangedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextChangedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCommandBarFlyoutImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCommandBarFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCommandBarFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCommandBarFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCommandBarFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCommandBarFlyoutVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCommandBarFlyout, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCommandBarFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCommandBarFlyoutFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TextCommandBarFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCommandBarFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCommandBarFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCommandBarFlyoutFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCommandBarFlyoutFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCommandBarFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITextCommandBarFlyoutFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCommandBarFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCommandBarFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionChangedEventArgsImpl: Sized {
    fn StartIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Length(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCompositionChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCompositionChangedEventArgsVtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCompositionChangedEventArgs, BASE_OFFSET>(),
            StartIndex: StartIndex::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCompositionChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionEndedEventArgsImpl: Sized {
    fn StartIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Length(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionEndedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionEndedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionEndedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCompositionEndedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCompositionEndedEventArgsVtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionEndedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionEndedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCompositionEndedEventArgs, BASE_OFFSET>(),
            StartIndex: StartIndex::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCompositionEndedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionStartedEventArgsImpl: Sized {
    fn StartIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Length(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionStartedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionStartedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionStartedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCompositionStartedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCompositionStartedEventArgsVtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionStartedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionStartedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCompositionStartedEventArgs, BASE_OFFSET>(),
            StartIndex: StartIndex::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCompositionStartedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlCopyingToClipboardEventArgsImpl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlCopyingToClipboardEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlCopyingToClipboardEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlCopyingToClipboardEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextControlCopyingToClipboardEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextControlCopyingToClipboardEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlCopyingToClipboardEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlCopyingToClipboardEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextControlCopyingToClipboardEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextControlCopyingToClipboardEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlCuttingToClipboardEventArgsImpl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlCuttingToClipboardEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlCuttingToClipboardEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlCuttingToClipboardEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextControlCuttingToClipboardEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextControlCuttingToClipboardEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlCuttingToClipboardEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlCuttingToClipboardEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextControlCuttingToClipboardEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextControlCuttingToClipboardEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlPasteEventArgsImpl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlPasteEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlPasteEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlPasteEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextControlPasteEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextControlPasteEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlPasteEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlPasteEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextControlPasteEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextControlPasteEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickedEventArgsImpl: Sized {
    fn OldTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn NewTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickedEventArgsVtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickedEventArgs, BASE_OFFSET>(),
            OldTime: OldTime::<Impl, IMPL_OFFSET>,
            NewTime: NewTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickerImpl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ClockIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetClockIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MinuteIncrement(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinuteIncrement(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Time(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetTime(&mut self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn TimeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTimeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerVtbl {
        unsafe extern "system" fn Header<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ClockIdentifier<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockIdentifier<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClockIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinuteIncrement<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinuteIncrement<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinuteIncrement(value).into()
        }
        unsafe extern "system" fn Time<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Time() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTime(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TimeChanged<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimeChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTimeChanged<Impl: ITimePickerImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTimeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePicker, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            ClockIdentifier: ClockIdentifier::<Impl, IMPL_OFFSET>,
            SetClockIdentifier: SetClockIdentifier::<Impl, IMPL_OFFSET>,
            MinuteIncrement: MinuteIncrement::<Impl, IMPL_OFFSET>,
            SetMinuteIncrement: SetMinuteIncrement::<Impl, IMPL_OFFSET>,
            Time: Time::<Impl, IMPL_OFFSET>,
            SetTime: SetTime::<Impl, IMPL_OFFSET>,
            TimeChanged: TimeChanged::<Impl, IMPL_OFFSET>,
            RemoveTimeChanged: RemoveTimeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePicker2Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePicker2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePicker2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePicker2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ITimePicker2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ITimePicker2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePicker2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePicker2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePicker3Impl: Sized {
    fn SelectedTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
    fn SetSelectedTime(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>) -> ::windows::core::Result<()>;
    fn SelectedTimeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedTimeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePicker3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePicker3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePicker3Vtbl {
        unsafe extern "system" fn SelectedTime<Impl: ITimePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedTime<Impl: ITimePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedTime(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedTimeChanged<Impl: ITimePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTimeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedTimeChanged<Impl: ITimePicker3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectedTimeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePicker3, BASE_OFFSET>(),
            SelectedTime: SelectedTime::<Impl, IMPL_OFFSET>,
            SetSelectedTime: SetSelectedTime::<Impl, IMPL_OFFSET>,
            SelectedTimeChanged: SelectedTimeChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectedTimeChanged: RemoveSelectedTimeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePicker3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TimePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITimePickerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickerFlyoutImpl: Sized {
    fn ClockIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetClockIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Time(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetTime(&mut self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn MinuteIncrement(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinuteIncrement(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TimePicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTimePicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickerFlyoutVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutVtbl {
        unsafe extern "system" fn ClockIdentifier<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockIdentifier<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClockIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Time<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Time() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTime(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinuteIncrement<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinuteIncrement<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinuteIncrement(value).into()
        }
        unsafe extern "system" fn TimePicked<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimePicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTimePicked<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTimePicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: ITimePickerFlyoutImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyout, BASE_OFFSET>(),
            ClockIdentifier: ClockIdentifier::<Impl, IMPL_OFFSET>,
            SetClockIdentifier: SetClockIdentifier::<Impl, IMPL_OFFSET>,
            Time: Time::<Impl, IMPL_OFFSET>,
            SetTime: SetTime::<Impl, IMPL_OFFSET>,
            MinuteIncrement: MinuteIncrement::<Impl, IMPL_OFFSET>,
            SetMinuteIncrement: SetMinuteIncrement::<Impl, IMPL_OFFSET>,
            TimePicked: TimePicked::<Impl, IMPL_OFFSET>,
            RemoveTimePicked: RemoveTimePicked::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenterVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutPresenterImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutPresenterVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenter2Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenter2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutPresenter2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutPresenter2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: ITimePickerFlyoutPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: ITimePickerFlyoutPresenter2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutPresenter2, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenterStatics2Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenterStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutPresenterStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutPresenterStatics2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: ITimePickerFlyoutPresenterStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutPresenterStatics2, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutStaticsImpl: Sized {
    fn ClockIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TimeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinuteIncrementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutStaticsVtbl {
        unsafe extern "system" fn ClockIdentifierProperty<Impl: ITimePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeProperty<Impl: ITimePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinuteIncrementProperty<Impl: ITimePickerFlyoutStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutStatics, BASE_OFFSET>(),
            ClockIdentifierProperty: ClockIdentifierProperty::<Impl, IMPL_OFFSET>,
            TimeProperty: TimeProperty::<Impl, IMPL_OFFSET>,
            MinuteIncrementProperty: MinuteIncrementProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickerSelectedValueChangedEventArgsImpl: Sized {
    fn OldTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
    fn NewTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickerSelectedValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerSelectedValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickerSelectedValueChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerSelectedValueChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerSelectedValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickerSelectedValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickerSelectedValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerSelectedValueChangedEventArgs, BASE_OFFSET>(),
            OldTime: OldTime::<Impl, IMPL_OFFSET>,
            NewTime: NewTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerSelectedValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStaticsImpl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ClockIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinuteIncrementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TimeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ITimePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ITimePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClockIdentifierProperty<Impl: ITimePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinuteIncrementProperty<Impl: ITimePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeProperty<Impl: ITimePickerStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            ClockIdentifierProperty: ClockIdentifierProperty::<Impl, IMPL_OFFSET>,
            MinuteIncrementProperty: MinuteIncrementProperty::<Impl, IMPL_OFFSET>,
            TimeProperty: TimeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ITimePickerStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStatics3Impl: Sized {
    fn SelectedTimeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerStatics3Vtbl {
        unsafe extern "system" fn SelectedTimeProperty<Impl: ITimePickerStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerStatics3, BASE_OFFSET>(),
            SelectedTimeProperty: SelectedTimeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickerValueChangedEventArgsImpl: Sized {
    fn OldTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn NewTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickerValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickerValueChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerValueChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickerValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickerValueChangedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerValueChangedEventArgs, BASE_OFFSET>(),
            OldTime: OldTime::<Impl, IMPL_OFFSET>,
            NewTime: NewTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemImpl: Sized {
    fn IsChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleMenuFlyoutItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleMenuFlyoutItemVtbl {
        unsafe extern "system" fn IsChecked<Impl: IToggleMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IToggleMenuFlyoutItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleMenuFlyoutItem, BASE_OFFSET>(),
            IsChecked: IsChecked::<Impl, IMPL_OFFSET>,
            SetIsChecked: SetIsChecked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleMenuFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleMenuFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleMenuFlyoutItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleMenuFlyoutItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleMenuFlyoutItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleMenuFlyoutItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleMenuFlyoutItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemStaticsImpl: Sized {
    fn IsCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleMenuFlyoutItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleMenuFlyoutItemStaticsVtbl {
        unsafe extern "system" fn IsCheckedProperty<Impl: IToggleMenuFlyoutItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleMenuFlyoutItemStatics, BASE_OFFSET>(),
            IsCheckedProperty: IsCheckedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleMenuFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IToggleSplitButtonImpl: Sized {
    fn IsChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCheckedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsCheckedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToggleSplitButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButton";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IToggleSplitButtonVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonVtbl {
        unsafe extern "system" fn IsChecked<Impl: IToggleSplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IToggleSplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        unsafe extern "system" fn IsCheckedChanged<Impl: IToggleSplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsCheckedChanged<Impl: IToggleSplitButtonImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButton, BASE_OFFSET>(),
            IsChecked: IsChecked::<Impl, IMPL_OFFSET>,
            SetIsChecked: SetIsChecked::<Impl, IMPL_OFFSET>,
            IsCheckedChanged: IsCheckedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsCheckedChanged: RemoveIsCheckedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonAutomationPeerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonAutomationPeerVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonAutomationPeerImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonAutomationPeerVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonAutomationPeer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonAutomationPeer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonAutomationPeerFactoryImpl: Sized {
    fn CreateInstance(&mut self, owner: &::core::option::Option<ToggleSplitButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleSplitButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonAutomationPeerFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonAutomationPeerFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonAutomationPeerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleSplitButtonAutomationPeerFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <ToggleSplitButton as ::windows::core::Abi>::Abi as *const <ToggleSplitButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonAutomationPeerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonAutomationPeerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleSplitButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleSplitButtonFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonIsCheckedChangedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonIsCheckedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonIsCheckedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonIsCheckedChangedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonIsCheckedChangedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonIsCheckedChangedEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonIsCheckedChangedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonIsCheckedChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IToggleSwitchImpl: Sized {
    fn IsOn(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOn(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContent(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetOnContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetOnContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OffContent(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetOffContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OffContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetOffContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ToggleSwitchTemplateSettings>;
    fn Toggled(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveToggled(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToggleSwitch {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitch";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IToggleSwitchVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSwitchImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSwitchVtbl {
        unsafe extern "system" fn IsOn<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOn<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOn(value).into()
        }
        unsafe extern "system" fn Header<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContent<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOnContent<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOnContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOnContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOnContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OffContent<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOffContent<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOffContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OffContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOffContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOffContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Toggled<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Toggled(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveToggled<Impl: IToggleSwitchImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveToggled(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSwitch, BASE_OFFSET>(),
            IsOn: IsOn::<Impl, IMPL_OFFSET>,
            SetIsOn: SetIsOn::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            OnContent: OnContent::<Impl, IMPL_OFFSET>,
            SetOnContent: SetOnContent::<Impl, IMPL_OFFSET>,
            OnContentTemplate: OnContentTemplate::<Impl, IMPL_OFFSET>,
            SetOnContentTemplate: SetOnContentTemplate::<Impl, IMPL_OFFSET>,
            OffContent: OffContent::<Impl, IMPL_OFFSET>,
            SetOffContent: SetOffContent::<Impl, IMPL_OFFSET>,
            OffContentTemplate: OffContentTemplate::<Impl, IMPL_OFFSET>,
            SetOffContentTemplate: SetOffContentTemplate::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            Toggled: Toggled::<Impl, IMPL_OFFSET>,
            RemoveToggled: RemoveToggled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSwitch as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSwitchOverridesImpl: Sized {
    fn OnToggled(&mut self) -> ::windows::core::Result<()>;
    fn OnOnContentChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOffContentChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnHeaderChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSwitchOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitchOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSwitchOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSwitchOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSwitchOverridesVtbl {
        unsafe extern "system" fn OnToggled<Impl: IToggleSwitchOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnToggled().into()
        }
        unsafe extern "system" fn OnOnContentChanged<Impl: IToggleSwitchOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOnContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOffContentChanged<Impl: IToggleSwitchOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOffContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnHeaderChanged<Impl: IToggleSwitchOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnHeaderChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSwitchOverrides, BASE_OFFSET>(),
            OnToggled: OnToggled::<Impl, IMPL_OFFSET>,
            OnOnContentChanged: OnOnContentChanged::<Impl, IMPL_OFFSET>,
            OnOffContentChanged: OnOffContentChanged::<Impl, IMPL_OFFSET>,
            OnHeaderChanged: OnHeaderChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSwitchOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSwitchStaticsImpl: Sized {
    fn IsOnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OnContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OnContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OffContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OffContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSwitchStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitchStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSwitchStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSwitchStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSwitchStaticsVtbl {
        unsafe extern "system" fn IsOnProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnContentProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnContentTemplateProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OffContentProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OffContentTemplateProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSwitchStatics, BASE_OFFSET>(),
            IsOnProperty: IsOnProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            OnContentProperty: OnContentProperty::<Impl, IMPL_OFFSET>,
            OnContentTemplateProperty: OnContentTemplateProperty::<Impl, IMPL_OFFSET>,
            OffContentProperty: OffContentProperty::<Impl, IMPL_OFFSET>,
            OffContentTemplateProperty: OffContentTemplateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSwitchStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IToolTipImpl: Sized {
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Placement(&mut self) -> ::windows::core::Result<Primitives::PlacementMode>;
    fn SetPlacement(&mut self, value: Primitives::PlacementMode) -> ::windows::core::Result<()>;
    fn PlacementTarget(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ToolTipTemplateSettings>;
    fn Closed(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToolTip {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTip";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IToolTipVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipVtbl {
        unsafe extern "system" fn HorizontalOffset<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalOffset<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalOffset(value).into()
        }
        unsafe extern "system" fn IsOpen<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOpen<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOpen(value).into()
        }
        unsafe extern "system" fn Placement<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Placement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacement<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacement(value).into()
        }
        unsafe extern "system" fn PlacementTarget<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VerticalOffset<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalOffset<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalOffset(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Closed<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IToolTipImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTip, BASE_OFFSET>(),
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            SetHorizontalOffset: SetHorizontalOffset::<Impl, IMPL_OFFSET>,
            IsOpen: IsOpen::<Impl, IMPL_OFFSET>,
            SetIsOpen: SetIsOpen::<Impl, IMPL_OFFSET>,
            Placement: Placement::<Impl, IMPL_OFFSET>,
            SetPlacement: SetPlacement::<Impl, IMPL_OFFSET>,
            PlacementTarget: PlacementTarget::<Impl, IMPL_OFFSET>,
            SetPlacementTarget: SetPlacementTarget::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            SetVerticalOffset: SetVerticalOffset::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTip as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IToolTip2Impl: Sized {
    fn PlacementRect(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::Rect>>;
    fn SetPlacementRect(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::Rect>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToolTip2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTip2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IToolTip2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTip2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTip2Vtbl {
        unsafe extern "system" fn PlacementRect<Impl: IToolTip2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementRect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementRect<Impl: IToolTip2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementRect(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::Rect> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::Rect> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTip2, BASE_OFFSET>(),
            PlacementRect: PlacementRect::<Impl, IMPL_OFFSET>,
            SetPlacementRect: SetPlacementRect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTip2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToolTip>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToolTipFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipServiceImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipService {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipService";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipServiceVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipServiceImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipServiceVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipService, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipService as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IToolTipServiceStaticsImpl: Sized {
    fn PlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetPlacement(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<Primitives::PlacementMode>;
    fn SetPlacement(&mut self, element: &::core::option::Option<super::DependencyObject>, value: Primitives::PlacementMode) -> ::windows::core::Result<()>;
    fn PlacementTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetPlacementTarget(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&mut self, element: &::core::option::Option<super::DependencyObject>, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ToolTipProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetToolTip(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetToolTip(&mut self, element: &::core::option::Option<super::DependencyObject>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToolTipServiceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipServiceStatics";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IToolTipServiceStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipServiceStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipServiceStaticsVtbl {
        unsafe extern "system" fn PlacementProperty<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlacement<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPlacement(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacement<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacement(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn PlacementTargetProperty<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlacementTarget<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPlacementTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ToolTipProperty<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ToolTipProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToolTip<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetToolTip(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetToolTip<Impl: IToolTipServiceStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetToolTip(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipServiceStatics, BASE_OFFSET>(),
            PlacementProperty: PlacementProperty::<Impl, IMPL_OFFSET>,
            GetPlacement: GetPlacement::<Impl, IMPL_OFFSET>,
            SetPlacement: SetPlacement::<Impl, IMPL_OFFSET>,
            PlacementTargetProperty: PlacementTargetProperty::<Impl, IMPL_OFFSET>,
            GetPlacementTarget: GetPlacementTarget::<Impl, IMPL_OFFSET>,
            SetPlacementTarget: SetPlacementTarget::<Impl, IMPL_OFFSET>,
            ToolTipProperty: ToolTipProperty::<Impl, IMPL_OFFSET>,
            GetToolTip: GetToolTip::<Impl, IMPL_OFFSET>,
            SetToolTip: SetToolTip::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipServiceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipStaticsImpl: Sized {
    fn HorizontalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipStaticsVtbl {
        unsafe extern "system" fn HorizontalOffsetProperty<Impl: IToolTipStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOpenProperty<Impl: IToolTipStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementProperty<Impl: IToolTipStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementTargetProperty<Impl: IToolTipStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffsetProperty<Impl: IToolTipStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipStatics, BASE_OFFSET>(),
            HorizontalOffsetProperty: HorizontalOffsetProperty::<Impl, IMPL_OFFSET>,
            IsOpenProperty: IsOpenProperty::<Impl, IMPL_OFFSET>,
            PlacementProperty: PlacementProperty::<Impl, IMPL_OFFSET>,
            PlacementTargetProperty: PlacementTargetProperty::<Impl, IMPL_OFFSET>,
            VerticalOffsetProperty: VerticalOffsetProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipStatics2Impl: Sized {
    fn PlacementRectProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipStatics2Vtbl {
        unsafe extern "system" fn PlacementRectProperty<Impl: IToolTipStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementRectProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipStatics2, BASE_OFFSET>(),
            PlacementRectProperty: PlacementRectProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeViewImpl: Sized {
    fn RootNodes(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<TreeViewSelectionMode>;
    fn SetSelectionMode(&mut self, value: TreeViewSelectionMode) -> ::windows::core::Result<()>;
    fn SelectedNodes(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
    fn Expand(&mut self, value: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<()>;
    fn Collapse(&mut self, value: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn ItemInvoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Expanding(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveExpanding(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Collapsed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCollapsed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeView";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewVtbl {
        unsafe extern "system" fn RootNodes<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RootNodes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TreeViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TreeViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn SelectedNodes<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedNodes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Expand<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Expand(&*(&value as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Collapse<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Collapse(&*(&value as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn ItemInvoked<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemInvoked<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Expanding<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Expanding(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveExpanding<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveExpanding(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Collapsed<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Collapsed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCollapsed<Impl: ITreeViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCollapsed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeView, BASE_OFFSET>(),
            RootNodes: RootNodes::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            SelectedNodes: SelectedNodes::<Impl, IMPL_OFFSET>,
            Expand: Expand::<Impl, IMPL_OFFSET>,
            Collapse: Collapse::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            ItemInvoked: ItemInvoked::<Impl, IMPL_OFFSET>,
            RemoveItemInvoked: RemoveItemInvoked::<Impl, IMPL_OFFSET>,
            Expanding: Expanding::<Impl, IMPL_OFFSET>,
            RemoveExpanding: RemoveExpanding::<Impl, IMPL_OFFSET>,
            Collapsed: Collapsed::<Impl, IMPL_OFFSET>,
            RemoveCollapsed: RemoveCollapsed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait ITreeView2Impl: Sized {
    fn NodeFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<TreeViewNode>;
    fn ContainerFromNode(&mut self, node: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<super::DependencyObject>;
    fn ItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn CanDragItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanDragItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanReorderItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanReorderItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ItemTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetItemTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetItemContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ItemContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetItemContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetItemContainerTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn DragItemsStarting(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DragItemsCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeView2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ITreeView2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeView2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeView2Vtbl {
        unsafe extern "system" fn NodeFromContainer<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NodeFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromNode<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, node: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromNode(&*(&node as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemFromContainer<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanDragItems<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanDragItems<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanDragItems(value).into()
        }
        unsafe extern "system" fn CanReorderItems<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanReorderItems<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanReorderItems(value).into()
        }
        unsafe extern "system" fn ItemTemplate<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplateSelector<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplateSelector<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyle<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyle<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyleSelector<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyleSelector<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerTransitions<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerTransitions<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemsSource<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsStarting<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsStarting<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsCompleted<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsCompleted<Impl: ITreeView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeView2, BASE_OFFSET>(),
            NodeFromContainer: NodeFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromNode: ContainerFromNode::<Impl, IMPL_OFFSET>,
            ItemFromContainer: ItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromItem: ContainerFromItem::<Impl, IMPL_OFFSET>,
            CanDragItems: CanDragItems::<Impl, IMPL_OFFSET>,
            SetCanDragItems: SetCanDragItems::<Impl, IMPL_OFFSET>,
            CanReorderItems: CanReorderItems::<Impl, IMPL_OFFSET>,
            SetCanReorderItems: SetCanReorderItems::<Impl, IMPL_OFFSET>,
            ItemTemplate: ItemTemplate::<Impl, IMPL_OFFSET>,
            SetItemTemplate: SetItemTemplate::<Impl, IMPL_OFFSET>,
            ItemTemplateSelector: ItemTemplateSelector::<Impl, IMPL_OFFSET>,
            SetItemTemplateSelector: SetItemTemplateSelector::<Impl, IMPL_OFFSET>,
            ItemContainerStyle: ItemContainerStyle::<Impl, IMPL_OFFSET>,
            SetItemContainerStyle: SetItemContainerStyle::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelector: ItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetItemContainerStyleSelector: SetItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            ItemContainerTransitions: ItemContainerTransitions::<Impl, IMPL_OFFSET>,
            SetItemContainerTransitions: SetItemContainerTransitions::<Impl, IMPL_OFFSET>,
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
            DragItemsStarting: DragItemsStarting::<Impl, IMPL_OFFSET>,
            RemoveDragItemsStarting: RemoveDragItemsStarting::<Impl, IMPL_OFFSET>,
            DragItemsCompleted: DragItemsCompleted::<Impl, IMPL_OFFSET>,
            RemoveDragItemsCompleted: RemoveDragItemsCompleted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewCollapsedEventArgsImpl: Sized {
    fn Node(&mut self) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewCollapsedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewCollapsedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewCollapsedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewCollapsedEventArgsVtbl {
        unsafe extern "system" fn Node<Impl: ITreeViewCollapsedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Node() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewCollapsedEventArgs, BASE_OFFSET>(), Node: Node::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewCollapsedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewCollapsedEventArgs2Impl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewCollapsedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewCollapsedEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewCollapsedEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewCollapsedEventArgs2Vtbl {
        unsafe extern "system" fn Item<Impl: ITreeViewCollapsedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewCollapsedEventArgs2, BASE_OFFSET>(), Item: Item::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewCollapsedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeViewDragItemsCompletedEventArgsImpl: Sized {
    fn DropResult(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackageOperation>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewDragItemsCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewDragItemsCompletedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeViewDragItemsCompletedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewDragItemsCompletedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewDragItemsCompletedEventArgsVtbl {
        unsafe extern "system" fn DropResult<Impl: ITreeViewDragItemsCompletedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::ApplicationModel::DataTransfer::DataPackageOperation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropResult() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Items<Impl: ITreeViewDragItemsCompletedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewDragItemsCompletedEventArgs, BASE_OFFSET>(),
            DropResult: DropResult::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewDragItemsCompletedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeViewDragItemsStartingEventArgsImpl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Data(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewDragItemsStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewDragItemsStartingEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeViewDragItemsStartingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewDragItemsStartingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewDragItemsStartingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn Data<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Items<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewDragItemsStartingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            Data: Data::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewDragItemsStartingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewExpandingEventArgsImpl: Sized {
    fn Node(&mut self) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewExpandingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewExpandingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewExpandingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewExpandingEventArgsVtbl {
        unsafe extern "system" fn Node<Impl: ITreeViewExpandingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Node() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewExpandingEventArgs, BASE_OFFSET>(), Node: Node::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewExpandingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewExpandingEventArgs2Impl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewExpandingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewExpandingEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewExpandingEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewExpandingEventArgs2Vtbl {
        unsafe extern "system" fn Item<Impl: ITreeViewExpandingEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewExpandingEventArgs2, BASE_OFFSET>(), Item: Item::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewExpandingEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITreeViewItemImpl: Sized {
    fn GlyphOpacity(&mut self) -> ::windows::core::Result<f64>;
    fn SetGlyphOpacity(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn GlyphBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetGlyphBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn ExpandedGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetExpandedGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CollapsedGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCollapsedGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn GlyphSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetGlyphSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsExpanded(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExpanded(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TreeViewItemTemplateSettings(&mut self) -> ::windows::core::Result<TreeViewItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItem";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITreeViewItemVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemVtbl {
        unsafe extern "system" fn GlyphOpacity<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphOpacity() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphOpacity<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyphOpacity(value).into()
        }
        unsafe extern "system" fn GlyphBrush<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphBrush<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyphBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ExpandedGlyph<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExpandedGlyph<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetExpandedGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CollapsedGlyph<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCollapsedGlyph<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCollapsedGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GlyphSize<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphSize<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyphSize(value).into()
        }
        unsafe extern "system" fn IsExpanded<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpanded() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExpanded<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExpanded(value).into()
        }
        unsafe extern "system" fn TreeViewItemTemplateSettings<Impl: ITreeViewItemImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TreeViewItemTemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItem, BASE_OFFSET>(),
            GlyphOpacity: GlyphOpacity::<Impl, IMPL_OFFSET>,
            SetGlyphOpacity: SetGlyphOpacity::<Impl, IMPL_OFFSET>,
            GlyphBrush: GlyphBrush::<Impl, IMPL_OFFSET>,
            SetGlyphBrush: SetGlyphBrush::<Impl, IMPL_OFFSET>,
            ExpandedGlyph: ExpandedGlyph::<Impl, IMPL_OFFSET>,
            SetExpandedGlyph: SetExpandedGlyph::<Impl, IMPL_OFFSET>,
            CollapsedGlyph: CollapsedGlyph::<Impl, IMPL_OFFSET>,
            SetCollapsedGlyph: SetCollapsedGlyph::<Impl, IMPL_OFFSET>,
            GlyphSize: GlyphSize::<Impl, IMPL_OFFSET>,
            SetGlyphSize: SetGlyphSize::<Impl, IMPL_OFFSET>,
            IsExpanded: IsExpanded::<Impl, IMPL_OFFSET>,
            SetIsExpanded: SetIsExpanded::<Impl, IMPL_OFFSET>,
            TreeViewItemTemplateSettings: TreeViewItemTemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItem2Impl: Sized {
    fn HasUnrealizedChildren(&mut self) -> ::windows::core::Result<bool>;
    fn SetHasUnrealizedChildren(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItem2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItem2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItem2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItem2Vtbl {
        unsafe extern "system" fn HasUnrealizedChildren<Impl: ITreeViewItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHasUnrealizedChildren<Impl: ITreeViewItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHasUnrealizedChildren(value).into()
        }
        unsafe extern "system" fn ItemsSource<Impl: ITreeViewItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: ITreeViewItem2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItem2, BASE_OFFSET>(),
            HasUnrealizedChildren: HasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            SetHasUnrealizedChildren: SetHasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewItemFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemInvokedEventArgsImpl: Sized {
    fn InvokedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemInvokedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemInvokedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemInvokedEventArgsVtbl {
        unsafe extern "system" fn InvokedItem<Impl: ITreeViewItemInvokedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITreeViewItemInvokedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn Handled<Impl: ITreeViewItemInvokedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemInvokedEventArgs, BASE_OFFSET>(),
            InvokedItem: InvokedItem::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemInvokedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemStaticsImpl: Sized {
    fn GlyphOpacityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExpandedGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CollapsedGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsExpandedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TreeViewItemTemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemStaticsVtbl {
        unsafe extern "system" fn GlyphOpacityProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphOpacityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphBrushProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExpandedGlyphProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphSizeProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpandedProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpandedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TreeViewItemTemplateSettingsProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TreeViewItemTemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemStatics, BASE_OFFSET>(),
            GlyphOpacityProperty: GlyphOpacityProperty::<Impl, IMPL_OFFSET>,
            GlyphBrushProperty: GlyphBrushProperty::<Impl, IMPL_OFFSET>,
            ExpandedGlyphProperty: ExpandedGlyphProperty::<Impl, IMPL_OFFSET>,
            CollapsedGlyphProperty: CollapsedGlyphProperty::<Impl, IMPL_OFFSET>,
            GlyphSizeProperty: GlyphSizeProperty::<Impl, IMPL_OFFSET>,
            IsExpandedProperty: IsExpandedProperty::<Impl, IMPL_OFFSET>,
            TreeViewItemTemplateSettingsProperty: TreeViewItemTemplateSettingsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemStatics2Impl: Sized {
    fn HasUnrealizedChildrenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemStatics2Vtbl {
        unsafe extern "system" fn HasUnrealizedChildrenProperty<Impl: ITreeViewItemStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsSourceProperty<Impl: ITreeViewItemStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemStatics2, BASE_OFFSET>(),
            HasUnrealizedChildrenProperty: HasUnrealizedChildrenProperty::<Impl, IMPL_OFFSET>,
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsImpl: Sized {
    fn ExpandedGlyphVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn CollapsedGlyphVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn Indentation(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn DragItemsCount(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemTemplateSettingsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemTemplateSettingsVtbl {
        unsafe extern "system" fn ExpandedGlyphVisibility<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphVisibility<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Indentation<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Indentation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DragItemsCount<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemTemplateSettings, BASE_OFFSET>(),
            ExpandedGlyphVisibility: ExpandedGlyphVisibility::<Impl, IMPL_OFFSET>,
            CollapsedGlyphVisibility: CollapsedGlyphVisibility::<Impl, IMPL_OFFSET>,
            Indentation: Indentation::<Impl, IMPL_OFFSET>,
            DragItemsCount: DragItemsCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemTemplateSettings as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewItemTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettingsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemTemplateSettingsFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemTemplateSettingsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewItemTemplateSettingsFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemTemplateSettingsFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemTemplateSettingsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsStaticsImpl: Sized {
    fn ExpandedGlyphVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CollapsedGlyphVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IndentationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DragItemsCountProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettingsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemTemplateSettingsStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemTemplateSettingsStaticsVtbl {
        unsafe extern "system" fn ExpandedGlyphVisibilityProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphVisibilityProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndentationProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndentationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DragItemsCountProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCountProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemTemplateSettingsStatics, BASE_OFFSET>(),
            ExpandedGlyphVisibilityProperty: ExpandedGlyphVisibilityProperty::<Impl, IMPL_OFFSET>,
            CollapsedGlyphVisibilityProperty: CollapsedGlyphVisibilityProperty::<Impl, IMPL_OFFSET>,
            IndentationProperty: IndentationProperty::<Impl, IMPL_OFFSET>,
            DragItemsCountProperty: DragItemsCountProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemTemplateSettingsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewListImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewList {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewList";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewListVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewListImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewListVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewList, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewListFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewList>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewListFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewListFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewListFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewListFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewListFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewListFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewListFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewListFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeViewNodeImpl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Parent(&mut self) -> ::windows::core::Result<TreeViewNode>;
    fn IsExpanded(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExpanded(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HasChildren(&mut self) -> ::windows::core::Result<bool>;
    fn Depth(&mut self) -> ::windows::core::Result<i32>;
    fn HasUnrealizedChildren(&mut self) -> ::windows::core::Result<bool>;
    fn SetHasUnrealizedChildren(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Children(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewNode {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNode";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeViewNodeVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewNodeImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewNodeVtbl {
        unsafe extern "system" fn Content<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Parent<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Parent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpanded<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpanded() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExpanded<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExpanded(value).into()
        }
        unsafe extern "system" fn HasChildren<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Depth<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Depth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasUnrealizedChildren<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHasUnrealizedChildren<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHasUnrealizedChildren(value).into()
        }
        unsafe extern "system" fn Children<Impl: ITreeViewNodeImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewNode, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            Parent: Parent::<Impl, IMPL_OFFSET>,
            IsExpanded: IsExpanded::<Impl, IMPL_OFFSET>,
            SetIsExpanded: SetIsExpanded::<Impl, IMPL_OFFSET>,
            HasChildren: HasChildren::<Impl, IMPL_OFFSET>,
            Depth: Depth::<Impl, IMPL_OFFSET>,
            HasUnrealizedChildren: HasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            SetHasUnrealizedChildren: SetHasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            Children: Children::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewNode as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewNodeFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewNodeFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNodeFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewNodeFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewNodeFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewNodeFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewNodeFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewNodeFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewNodeFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewNodeStaticsImpl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DepthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsExpandedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasChildrenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewNodeStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNodeStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewNodeStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewNodeStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewNodeStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DepthProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DepthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpandedProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpandedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasChildrenProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewNodeStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            DepthProperty: DepthProperty::<Impl, IMPL_OFFSET>,
            IsExpandedProperty: IsExpandedProperty::<Impl, IMPL_OFFSET>,
            HasChildrenProperty: HasChildrenProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewNodeStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewStaticsImpl: Sized {
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewStaticsVtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: ITreeViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewStatics, BASE_OFFSET>(),
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewStatics2Impl: Sized {
    fn CanDragItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanReorderItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewStatics2Vtbl {
        unsafe extern "system" fn CanDragItemsProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanReorderItemsProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateSelectorProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleSelectorProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitionsProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsSourceProperty<Impl: ITreeViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewStatics2, BASE_OFFSET>(),
            CanDragItemsProperty: CanDragItemsProperty::<Impl, IMPL_OFFSET>,
            CanReorderItemsProperty: CanReorderItemsProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateProperty: ItemTemplateProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateSelectorProperty: ItemTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleProperty: ItemContainerStyleProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelectorProperty: ItemContainerStyleSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemContainerTransitionsProperty: ItemContainerTransitionsProperty::<Impl, IMPL_OFFSET>,
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITwoPaneViewImpl: Sized {
    fn Pane1(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane1(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane2(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane2(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane1Length(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetPane1Length(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn Pane2Length(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetPane2Length(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn PanePriority(&mut self) -> ::windows::core::Result<TwoPaneViewPriority>;
    fn SetPanePriority(&mut self, value: TwoPaneViewPriority) -> ::windows::core::Result<()>;
    fn Mode(&mut self) -> ::windows::core::Result<TwoPaneViewMode>;
    fn WideModeConfiguration(&mut self) -> ::windows::core::Result<TwoPaneViewWideModeConfiguration>;
    fn SetWideModeConfiguration(&mut self, value: TwoPaneViewWideModeConfiguration) -> ::windows::core::Result<()>;
    fn TallModeConfiguration(&mut self) -> ::windows::core::Result<TwoPaneViewTallModeConfiguration>;
    fn SetTallModeConfiguration(&mut self, value: TwoPaneViewTallModeConfiguration) -> ::windows::core::Result<()>;
    fn MinWideModeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinWideModeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MinTallModeHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinTallModeHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ModeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveModeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITwoPaneView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneView";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITwoPaneViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITwoPaneViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITwoPaneViewVtbl {
        unsafe extern "system" fn Pane1<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane1<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane1(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane2<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane2<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane2(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane1Length<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane1Length<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane1Length(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane2Length<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane2Length<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane2Length(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PanePriority<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewPriority) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePriority() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanePriority<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewPriority) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanePriority(value).into()
        }
        unsafe extern "system" fn Mode<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WideModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewWideModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WideModeConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWideModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewWideModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWideModeConfiguration(value).into()
        }
        unsafe extern "system" fn TallModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewTallModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TallModeConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTallModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewTallModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTallModeConfiguration(value).into()
        }
        unsafe extern "system" fn MinWideModeWidth<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWideModeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinWideModeWidth<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinWideModeWidth(value).into()
        }
        unsafe extern "system" fn MinTallModeHeight<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinTallModeHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinTallModeHeight<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinTallModeHeight(value).into()
        }
        unsafe extern "system" fn ModeChanged<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ModeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveModeChanged<Impl: ITwoPaneViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveModeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITwoPaneView, BASE_OFFSET>(),
            Pane1: Pane1::<Impl, IMPL_OFFSET>,
            SetPane1: SetPane1::<Impl, IMPL_OFFSET>,
            Pane2: Pane2::<Impl, IMPL_OFFSET>,
            SetPane2: SetPane2::<Impl, IMPL_OFFSET>,
            Pane1Length: Pane1Length::<Impl, IMPL_OFFSET>,
            SetPane1Length: SetPane1Length::<Impl, IMPL_OFFSET>,
            Pane2Length: Pane2Length::<Impl, IMPL_OFFSET>,
            SetPane2Length: SetPane2Length::<Impl, IMPL_OFFSET>,
            PanePriority: PanePriority::<Impl, IMPL_OFFSET>,
            SetPanePriority: SetPanePriority::<Impl, IMPL_OFFSET>,
            Mode: Mode::<Impl, IMPL_OFFSET>,
            WideModeConfiguration: WideModeConfiguration::<Impl, IMPL_OFFSET>,
            SetWideModeConfiguration: SetWideModeConfiguration::<Impl, IMPL_OFFSET>,
            TallModeConfiguration: TallModeConfiguration::<Impl, IMPL_OFFSET>,
            SetTallModeConfiguration: SetTallModeConfiguration::<Impl, IMPL_OFFSET>,
            MinWideModeWidth: MinWideModeWidth::<Impl, IMPL_OFFSET>,
            SetMinWideModeWidth: SetMinWideModeWidth::<Impl, IMPL_OFFSET>,
            MinTallModeHeight: MinTallModeHeight::<Impl, IMPL_OFFSET>,
            SetMinTallModeHeight: SetMinTallModeHeight::<Impl, IMPL_OFFSET>,
            ModeChanged: ModeChanged::<Impl, IMPL_OFFSET>,
            RemoveModeChanged: RemoveModeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITwoPaneView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITwoPaneViewFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TwoPaneView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITwoPaneViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITwoPaneViewFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITwoPaneViewFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITwoPaneViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITwoPaneViewFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITwoPaneViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITwoPaneViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITwoPaneViewStaticsImpl: Sized {
    fn Pane1Property(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane2Property(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane1LengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane2LengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PanePriorityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn WideModeConfigurationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TallModeConfigurationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinWideModeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinTallModeHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITwoPaneViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITwoPaneViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITwoPaneViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITwoPaneViewStaticsVtbl {
        unsafe extern "system" fn Pane1Property<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1Property() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane2Property<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2Property() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane1LengthProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1LengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane2LengthProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2LengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanePriorityProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePriorityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ModeProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WideModeConfigurationProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WideModeConfigurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TallModeConfigurationProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TallModeConfigurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinWideModeWidthProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWideModeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinTallModeHeightProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinTallModeHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITwoPaneViewStatics, BASE_OFFSET>(),
            Pane1Property: Pane1Property::<Impl, IMPL_OFFSET>,
            Pane2Property: Pane2Property::<Impl, IMPL_OFFSET>,
            Pane1LengthProperty: Pane1LengthProperty::<Impl, IMPL_OFFSET>,
            Pane2LengthProperty: Pane2LengthProperty::<Impl, IMPL_OFFSET>,
            PanePriorityProperty: PanePriorityProperty::<Impl, IMPL_OFFSET>,
            ModeProperty: ModeProperty::<Impl, IMPL_OFFSET>,
            WideModeConfigurationProperty: WideModeConfigurationProperty::<Impl, IMPL_OFFSET>,
            TallModeConfigurationProperty: TallModeConfigurationProperty::<Impl, IMPL_OFFSET>,
            MinWideModeWidthProperty: MinWideModeWidthProperty::<Impl, IMPL_OFFSET>,
            MinTallModeHeightProperty: MinTallModeHeightProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITwoPaneViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUIElementCollectionImpl: Sized {
    fn Move(&mut self, oldindex: u32, newindex: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUIElementCollection {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUIElementCollection";
}
#[cfg(feature = "implement_exclusive")]
impl IUIElementCollectionVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUIElementCollectionImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUIElementCollectionVtbl {
        unsafe extern "system" fn Move<Impl: IUIElementCollectionImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldindex: u32, newindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Move(oldindex, newindex).into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IUIElementCollection, BASE_OFFSET>(), Move: Move::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUIElementCollection as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlImpl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControl";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUserControlImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUserControlVtbl {
        unsafe extern "system" fn Content<Impl: IUserControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IUserControlImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IUserControl, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUserControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlFactoryImpl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<UserControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUserControlFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUserControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IUserControlFactoryImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IUserControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUserControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlStaticsImpl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUserControlStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUserControlStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IUserControlStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IUserControlStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUserControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVariableSizedWrapGridImpl: Sized {
    fn ItemHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn HorizontalChildrenAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalChildrenAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalChildrenAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalChildrenAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVariableSizedWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVariableSizedWrapGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IVariableSizedWrapGridVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVariableSizedWrapGridImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVariableSizedWrapGridVtbl {
        unsafe extern "system" fn ItemHeight<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn ItemWidth<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn HorizontalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn VerticalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IVariableSizedWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVariableSizedWrapGrid, BASE_OFFSET>(),
            ItemHeight: ItemHeight::<Impl, IMPL_OFFSET>,
            SetItemHeight: SetItemHeight::<Impl, IMPL_OFFSET>,
            ItemWidth: ItemWidth::<Impl, IMPL_OFFSET>,
            SetItemWidth: SetItemWidth::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignment: HorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalChildrenAlignment: SetHorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignment: VerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalChildrenAlignment: SetVerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumns: MaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            SetMaximumRowsOrColumns: SetMaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVariableSizedWrapGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVariableSizedWrapGridStaticsImpl: Sized {
    fn ItemHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RowSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRowSpan(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetRowSpan(&mut self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumnSpan(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetColumnSpan(&mut self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVariableSizedWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IVariableSizedWrapGridStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVariableSizedWrapGridStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVariableSizedWrapGridStaticsVtbl {
        unsafe extern "system" fn ItemHeightProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemWidthProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalChildrenAlignmentProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalChildrenAlignmentProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RowSpanProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRowSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRowSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRowSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnSpanProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumnSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColumnSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumnSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVariableSizedWrapGridStatics, BASE_OFFSET>(),
            ItemHeightProperty: ItemHeightProperty::<Impl, IMPL_OFFSET>,
            ItemWidthProperty: ItemWidthProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignmentProperty: HorizontalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignmentProperty: VerticalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumnsProperty: MaximumRowsOrColumnsProperty::<Impl, IMPL_OFFSET>,
            RowSpanProperty: RowSpanProperty::<Impl, IMPL_OFFSET>,
            GetRowSpan: GetRowSpan::<Impl, IMPL_OFFSET>,
            SetRowSpan: SetRowSpan::<Impl, IMPL_OFFSET>,
            ColumnSpanProperty: ColumnSpanProperty::<Impl, IMPL_OFFSET>,
            GetColumnSpan: GetColumnSpan::<Impl, IMPL_OFFSET>,
            SetColumnSpan: SetColumnSpan::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVariableSizedWrapGridStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IViewboxImpl: Sized {
    fn Child(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn StretchDirection(&mut self) -> ::windows::core::Result<StretchDirection>;
    fn SetStretchDirection(&mut self, value: StretchDirection) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IViewbox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IViewbox";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IViewboxVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IViewboxImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IViewboxVtbl {
        unsafe extern "system" fn Child<Impl: IViewboxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IViewboxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IViewboxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IViewboxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn StretchDirection<Impl: IViewboxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut StretchDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretchDirection<Impl: IViewboxImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: StretchDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretchDirection(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IViewbox, BASE_OFFSET>(),
            Child: Child::<Impl, IMPL_OFFSET>,
            SetChild: SetChild::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            StretchDirection: StretchDirection::<Impl, IMPL_OFFSET>,
            SetStretchDirection: SetStretchDirection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IViewbox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IViewboxStaticsImpl: Sized {
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchDirectionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IViewboxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IViewboxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IViewboxStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IViewboxStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IViewboxStaticsVtbl {
        unsafe extern "system" fn StretchProperty<Impl: IViewboxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchDirectionProperty<Impl: IViewboxStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchDirectionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IViewboxStatics, BASE_OFFSET>(),
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            StretchDirectionProperty: StretchDirectionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IViewboxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelImpl: Sized {
    fn ItemContainerGenerator(&mut self) -> ::windows::core::Result<ItemContainerGenerator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanelVtbl {
        unsafe extern "system" fn ItemContainerGenerator<Impl: IVirtualizingPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerGenerator() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanel, BASE_OFFSET>(),
            ItemContainerGenerator: ItemContainerGenerator::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelFactoryVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanelFactoryImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanelFactoryVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanelFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IVirtualizingPanelOverridesImpl: Sized {
    fn OnItemsChanged(&mut self, sender: &::core::option::Option<::windows::core::IInspectable>, args: &::core::option::Option<Primitives::ItemsChangedEventArgs>) -> ::windows::core::Result<()>;
    fn OnClearChildren(&mut self) -> ::windows::core::Result<()>;
    fn BringIndexIntoView(&mut self, index: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IVirtualizingPanelOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IVirtualizingPanelOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanelOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanelOverridesVtbl {
        unsafe extern "system" fn OnItemsChanged<Impl: IVirtualizingPanelOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sender: *mut ::core::ffi::c_void, args: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemsChanged(&*(&sender as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&args as *const <Primitives::ItemsChangedEventArgs as ::windows::core::Abi>::Abi as *const <Primitives::ItemsChangedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnClearChildren<Impl: IVirtualizingPanelOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClearChildren().into()
        }
        unsafe extern "system" fn BringIndexIntoView<Impl: IVirtualizingPanelOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BringIndexIntoView(index).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanelOverrides, BASE_OFFSET>(),
            OnItemsChanged: OnItemsChanged::<Impl, IMPL_OFFSET>,
            OnClearChildren: OnClearChildren::<Impl, IMPL_OFFSET>,
            BringIndexIntoView: BringIndexIntoView::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanelOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelProtectedImpl: Sized {
    fn AddInternalChild(&mut self, child: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn InsertInternalChild(&mut self, index: i32, child: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn RemoveInternalChildRange(&mut self, index: i32, range: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanelProtected {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelProtected";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelProtectedVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanelProtectedImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanelProtectedVtbl {
        unsafe extern "system" fn AddInternalChild<Impl: IVirtualizingPanelProtectedImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, child: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddInternalChild(&*(&child as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InsertInternalChild<Impl: IVirtualizingPanelProtectedImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, child: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InsertInternalChild(index, &*(&child as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveInternalChildRange<Impl: IVirtualizingPanelProtectedImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, range: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveInternalChildRange(index, range).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanelProtected, BASE_OFFSET>(),
            AddInternalChild: AddInternalChild::<Impl, IMPL_OFFSET>,
            InsertInternalChild: InsertInternalChild::<Impl, IMPL_OFFSET>,
            RemoveInternalChildRange: RemoveInternalChildRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanelProtected as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IVirtualizingStackPanelImpl: Sized {
    fn AreScrollSnapPointsRegular(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreScrollSnapPointsRegular(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn CleanUpVirtualizedItemEvent(&mut self, handler: &::core::option::Option<CleanUpVirtualizedItemEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCleanUpVirtualizedItemEvent(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IVirtualizingStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanel";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IVirtualizingStackPanelVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingStackPanelImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingStackPanelVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegular<Impl: IVirtualizingStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegular() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreScrollSnapPointsRegular<Impl: IVirtualizingStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreScrollSnapPointsRegular(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IVirtualizingStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IVirtualizingStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn CleanUpVirtualizedItemEvent<Impl: IVirtualizingStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CleanUpVirtualizedItemEvent(&*(&handler as *const <CleanUpVirtualizedItemEventHandler as ::windows::core::Abi>::Abi as *const <CleanUpVirtualizedItemEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCleanUpVirtualizedItemEvent<Impl: IVirtualizingStackPanelImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCleanUpVirtualizedItemEvent(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingStackPanel, BASE_OFFSET>(),
            AreScrollSnapPointsRegular: AreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            SetAreScrollSnapPointsRegular: SetAreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            CleanUpVirtualizedItemEvent: CleanUpVirtualizedItemEvent::<Impl, IMPL_OFFSET>,
            RemoveCleanUpVirtualizedItemEvent: RemoveCleanUpVirtualizedItemEvent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingStackPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingStackPanelOverridesImpl: Sized {
    fn OnCleanUpVirtualizedItem(&mut self, e: &::core::option::Option<CleanUpVirtualizedItemEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingStackPanelOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingStackPanelOverridesVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingStackPanelOverridesImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingStackPanelOverridesVtbl {
        unsafe extern "system" fn OnCleanUpVirtualizedItem<Impl: IVirtualizingStackPanelOverridesImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnCleanUpVirtualizedItem(&*(&e as *const <CleanUpVirtualizedItemEventArgs as ::windows::core::Abi>::Abi as *const <CleanUpVirtualizedItemEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingStackPanelOverrides, BASE_OFFSET>(),
            OnCleanUpVirtualizedItem: OnCleanUpVirtualizedItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingStackPanelOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingStackPanelStaticsImpl: Sized {
    fn AreScrollSnapPointsRegularProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VirtualizationModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVirtualizationMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<VirtualizationMode>;
    fn SetVirtualizationMode(&mut self, element: &::core::option::Option<super::DependencyObject>, value: VirtualizationMode) -> ::windows::core::Result<()>;
    fn IsVirtualizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVirtualizing(&mut self, o: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingStackPanelStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingStackPanelStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingStackPanelStaticsVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegularProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegularProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VirtualizationModeProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VirtualizationModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVirtualizationMode<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut VirtualizationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVirtualizationMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVirtualizationMode<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: VirtualizationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVirtualizationMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn IsVirtualizingProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVirtualizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVirtualizing<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, o: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsVirtualizing(&*(&o as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingStackPanelStatics, BASE_OFFSET>(),
            AreScrollSnapPointsRegularProperty: AreScrollSnapPointsRegularProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            VirtualizationModeProperty: VirtualizationModeProperty::<Impl, IMPL_OFFSET>,
            GetVirtualizationMode: GetVirtualizationMode::<Impl, IMPL_OFFSET>,
            SetVirtualizationMode: SetVirtualizationMode::<Impl, IMPL_OFFSET>,
            IsVirtualizingProperty: IsVirtualizingProperty::<Impl, IMPL_OFFSET>,
            GetIsVirtualizing: GetIsVirtualizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingStackPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IWebViewImpl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn AllowedScriptNotifyUris(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>;
    fn SetAllowedScriptNotifyUris(&mut self, value: &::core::option::Option<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>) -> ::windows::core::Result<()>;
    fn DataTransferPackage(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
    fn LoadCompleted(&mut self, handler: &::core::option::Option<super::Navigation::LoadCompletedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveLoadCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScriptNotify(&mut self, handler: &::core::option::Option<NotifyEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveScriptNotify(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationFailed(&mut self, handler: &::core::option::Option<WebViewNavigationFailedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn InvokeScript(&mut self, scriptname: &::windows::core::HSTRING, arguments: &[<::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType]) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Navigate(&mut self, source: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn NavigateToString(&mut self, text: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IWebViewVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewVtbl {
        unsafe extern "system" fn Source<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AllowedScriptNotifyUris<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AllowedScriptNotifyUris() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllowedScriptNotifyUris<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllowedScriptNotifyUris(&*(&value as *const <super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DataTransferPackage<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataTransferPackage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LoadCompleted<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LoadCompleted(&*(&handler as *const <super::Navigation::LoadCompletedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::LoadCompletedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveLoadCompleted<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveLoadCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScriptNotify<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScriptNotify(&*(&handler as *const <NotifyEventHandler as ::windows::core::Abi>::Abi as *const <NotifyEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveScriptNotify<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveScriptNotify(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationFailed<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationFailed(&*(&handler as *const <WebViewNavigationFailedEventHandler as ::windows::core::Abi>::Abi as *const <WebViewNavigationFailedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationFailed<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InvokeScript<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, scriptname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, arguments_array_size: u32, arguments: *const ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokeScript(&*(&scriptname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), ::core::slice::from_raw_parts(::core::mem::transmute_copy(&arguments), arguments_array_size as _)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigate<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Navigate(&*(&source as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigateToString<Impl: IWebViewImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, text: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NavigateToString(&*(&text as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            AllowedScriptNotifyUris: AllowedScriptNotifyUris::<Impl, IMPL_OFFSET>,
            SetAllowedScriptNotifyUris: SetAllowedScriptNotifyUris::<Impl, IMPL_OFFSET>,
            DataTransferPackage: DataTransferPackage::<Impl, IMPL_OFFSET>,
            LoadCompleted: LoadCompleted::<Impl, IMPL_OFFSET>,
            RemoveLoadCompleted: RemoveLoadCompleted::<Impl, IMPL_OFFSET>,
            ScriptNotify: ScriptNotify::<Impl, IMPL_OFFSET>,
            RemoveScriptNotify: RemoveScriptNotify::<Impl, IMPL_OFFSET>,
            NavigationFailed: NavigationFailed::<Impl, IMPL_OFFSET>,
            RemoveNavigationFailed: RemoveNavigationFailed::<Impl, IMPL_OFFSET>,
            InvokeScript: InvokeScript::<Impl, IMPL_OFFSET>,
            Navigate: Navigate::<Impl, IMPL_OFFSET>,
            NavigateToString: NavigateToString::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Storage_Streams", feature = "Web", feature = "Web_Http", feature = "implement_exclusive"))]
pub trait IWebView2Impl: Sized {
    fn CanGoBack(&mut self) -> ::windows::core::Result<bool>;
    fn CanGoForward(&mut self) -> ::windows::core::Result<bool>;
    fn DocumentTitle(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn NavigationStarting(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContentLoading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLoading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DOMContentLoaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDOMContentLoaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GoForward(&mut self) -> ::windows::core::Result<()>;
    fn GoBack(&mut self) -> ::windows::core::Result<()>;
    fn Refresh(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn CapturePreviewToStreamAsync(&mut self, stream: &::core::option::Option<super::super::super::Storage::Streams::IRandomAccessStream>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
    fn InvokeScriptAsync(&mut self, scriptname: &::windows::core::HSTRING, arguments: &::core::option::Option<super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING>>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<::windows::core::HSTRING>>;
    fn CaptureSelectedContentToDataPackageAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::ApplicationModel::DataTransfer::DataPackage>>;
    fn NavigateToLocalStreamUri(&mut self, source: &::core::option::Option<super::super::super::Foundation::Uri>, streamresolver: &::core::option::Option<super::super::super::Web::IUriToStreamResolver>) -> ::windows::core::Result<()>;
    fn BuildLocalStreamUri(&mut self, contentidentifier: &::windows::core::HSTRING, relativepath: &::windows::core::HSTRING) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn DefaultBackgroundColor(&mut self) -> ::windows::core::Result<super::super::Color>;
    fn SetDefaultBackgroundColor(&mut self, value: &super::super::Color) -> ::windows::core::Result<()>;
    fn NavigationCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameNavigationStarting(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameNavigationStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameContentLoading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameContentLoading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameDOMContentLoaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameDOMContentLoaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameNavigationCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameNavigationCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn LongRunningScriptDetected(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveLongRunningScriptDetected(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn UnsafeContentWarningDisplaying(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnsafeContentWarningDisplaying(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn UnviewableContentIdentified(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnviewableContentIdentified(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigateWithHttpRequestMessage(&mut self, requestmessage: &::core::option::Option<super::super::super::Web::Http::HttpRequestMessage>) -> ::windows::core::Result<()>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Storage_Streams", feature = "Web", feature = "Web_Http", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Storage_Streams", feature = "Web", feature = "Web_Http", feature = "implement_exclusive"))]
impl IWebView2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView2Vtbl {
        unsafe extern "system" fn CanGoBack<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForward<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForward() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DocumentTitle<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DocumentTitle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigationStarting<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationStarting<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLoading<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLoading<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContentLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DOMContentLoaded<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DOMContentLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDOMContentLoaded<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDOMContentLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GoForward<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoForward().into()
        }
        unsafe extern "system" fn GoBack<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoBack().into()
        }
        unsafe extern "system" fn Refresh<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Refresh().into()
        }
        unsafe extern "system" fn Stop<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn CapturePreviewToStreamAsync<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stream: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CapturePreviewToStreamAsync(&*(&stream as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::Abi>::Abi as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InvokeScriptAsync<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, scriptname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, arguments: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokeScriptAsync(&*(&scriptname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&arguments as *const <super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CaptureSelectedContentToDataPackageAsync<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CaptureSelectedContentToDataPackageAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigateToLocalStreamUri<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, streamresolver: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NavigateToLocalStreamUri(&*(&source as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType), &*(&streamresolver as *const <super::super::super::Web::IUriToStreamResolver as ::windows::core::Abi>::Abi as *const <super::super::super::Web::IUriToStreamResolver as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BuildLocalStreamUri<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, contentidentifier: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, relativepath: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BuildLocalStreamUri(&*(&contentidentifier as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&relativepath as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultBackgroundColor<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultBackgroundColor<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultBackgroundColor(&*(&value as *const <super::super::Color as ::windows::core::Abi>::Abi as *const <super::super::Color as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationCompleted<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationCompleted<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameNavigationStarting<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameNavigationStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameNavigationStarting<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameNavigationStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameContentLoading<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameContentLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameContentLoading<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameContentLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameDOMContentLoaded<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameDOMContentLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameDOMContentLoaded<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameDOMContentLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameNavigationCompleted<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameNavigationCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameNavigationCompleted<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameNavigationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LongRunningScriptDetected<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LongRunningScriptDetected(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveLongRunningScriptDetected<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveLongRunningScriptDetected(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsafeContentWarningDisplaying<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsafeContentWarningDisplaying(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnsafeContentWarningDisplaying<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnsafeContentWarningDisplaying(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnviewableContentIdentified<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnviewableContentIdentified(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnviewableContentIdentified<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnviewableContentIdentified(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigateWithHttpRequestMessage<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, requestmessage: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NavigateWithHttpRequestMessage(&*(&requestmessage as *const <super::super::super::Web::Http::HttpRequestMessage as ::windows::core::Abi>::Abi as *const <super::super::super::Web::Http::HttpRequestMessage as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Focus<Impl: IWebView2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView2, BASE_OFFSET>(),
            CanGoBack: CanGoBack::<Impl, IMPL_OFFSET>,
            CanGoForward: CanGoForward::<Impl, IMPL_OFFSET>,
            DocumentTitle: DocumentTitle::<Impl, IMPL_OFFSET>,
            NavigationStarting: NavigationStarting::<Impl, IMPL_OFFSET>,
            RemoveNavigationStarting: RemoveNavigationStarting::<Impl, IMPL_OFFSET>,
            ContentLoading: ContentLoading::<Impl, IMPL_OFFSET>,
            RemoveContentLoading: RemoveContentLoading::<Impl, IMPL_OFFSET>,
            DOMContentLoaded: DOMContentLoaded::<Impl, IMPL_OFFSET>,
            RemoveDOMContentLoaded: RemoveDOMContentLoaded::<Impl, IMPL_OFFSET>,
            GoForward: GoForward::<Impl, IMPL_OFFSET>,
            GoBack: GoBack::<Impl, IMPL_OFFSET>,
            Refresh: Refresh::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            CapturePreviewToStreamAsync: CapturePreviewToStreamAsync::<Impl, IMPL_OFFSET>,
            InvokeScriptAsync: InvokeScriptAsync::<Impl, IMPL_OFFSET>,
            CaptureSelectedContentToDataPackageAsync: CaptureSelectedContentToDataPackageAsync::<Impl, IMPL_OFFSET>,
            NavigateToLocalStreamUri: NavigateToLocalStreamUri::<Impl, IMPL_OFFSET>,
            BuildLocalStreamUri: BuildLocalStreamUri::<Impl, IMPL_OFFSET>,
            DefaultBackgroundColor: DefaultBackgroundColor::<Impl, IMPL_OFFSET>,
            SetDefaultBackgroundColor: SetDefaultBackgroundColor::<Impl, IMPL_OFFSET>,
            NavigationCompleted: NavigationCompleted::<Impl, IMPL_OFFSET>,
            RemoveNavigationCompleted: RemoveNavigationCompleted::<Impl, IMPL_OFFSET>,
            FrameNavigationStarting: FrameNavigationStarting::<Impl, IMPL_OFFSET>,
            RemoveFrameNavigationStarting: RemoveFrameNavigationStarting::<Impl, IMPL_OFFSET>,
            FrameContentLoading: FrameContentLoading::<Impl, IMPL_OFFSET>,
            RemoveFrameContentLoading: RemoveFrameContentLoading::<Impl, IMPL_OFFSET>,
            FrameDOMContentLoaded: FrameDOMContentLoaded::<Impl, IMPL_OFFSET>,
            RemoveFrameDOMContentLoaded: RemoveFrameDOMContentLoaded::<Impl, IMPL_OFFSET>,
            FrameNavigationCompleted: FrameNavigationCompleted::<Impl, IMPL_OFFSET>,
            RemoveFrameNavigationCompleted: RemoveFrameNavigationCompleted::<Impl, IMPL_OFFSET>,
            LongRunningScriptDetected: LongRunningScriptDetected::<Impl, IMPL_OFFSET>,
            RemoveLongRunningScriptDetected: RemoveLongRunningScriptDetected::<Impl, IMPL_OFFSET>,
            UnsafeContentWarningDisplaying: UnsafeContentWarningDisplaying::<Impl, IMPL_OFFSET>,
            RemoveUnsafeContentWarningDisplaying: RemoveUnsafeContentWarningDisplaying::<Impl, IMPL_OFFSET>,
            UnviewableContentIdentified: UnviewableContentIdentified::<Impl, IMPL_OFFSET>,
            RemoveUnviewableContentIdentified: RemoveUnviewableContentIdentified::<Impl, IMPL_OFFSET>,
            NavigateWithHttpRequestMessage: NavigateWithHttpRequestMessage::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebView3Impl: Sized {
    fn ContainsFullScreenElement(&mut self) -> ::windows::core::Result<bool>;
    fn ContainsFullScreenElementChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContainsFullScreenElementChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebView3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView3Vtbl {
        unsafe extern "system" fn ContainsFullScreenElement<Impl: IWebView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainsFullScreenElementChanged<Impl: IWebView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElementChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContainsFullScreenElementChanged<Impl: IWebView3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContainsFullScreenElementChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView3, BASE_OFFSET>(),
            ContainsFullScreenElement: ContainsFullScreenElement::<Impl, IMPL_OFFSET>,
            ContainsFullScreenElementChanged: ContainsFullScreenElementChanged::<Impl, IMPL_OFFSET>,
            RemoveContainsFullScreenElementChanged: RemoveContainsFullScreenElementChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IWebView4Impl: Sized {
    fn ExecutionMode(&mut self) -> ::windows::core::Result<WebViewExecutionMode>;
    fn DeferredPermissionRequests(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<WebViewDeferredPermissionRequest>>;
    fn Settings(&mut self) -> ::windows::core::Result<WebViewSettings>;
    fn UnsupportedUriSchemeIdentified(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnsupportedUriSchemeIdentified(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NewWindowRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNewWindowRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PermissionRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePermissionRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn AddWebAllowedObject(&mut self, name: &::windows::core::HSTRING, pobject: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn DeferredPermissionRequestById(&mut self, id: u32) -> ::windows::core::Result<WebViewDeferredPermissionRequest>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IWebView4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView4Vtbl {
        unsafe extern "system" fn ExecutionMode<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewExecutionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExecutionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeferredPermissionRequests<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DeferredPermissionRequests() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Settings<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Settings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsupportedUriSchemeIdentified<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsupportedUriSchemeIdentified(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnsupportedUriSchemeIdentified<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnsupportedUriSchemeIdentified(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NewWindowRequested<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewWindowRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNewWindowRequested<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNewWindowRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PermissionRequested<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePermissionRequested<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePermissionRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AddWebAllowedObject<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, pobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddWebAllowedObject(&*(&name as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&pobject as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DeferredPermissionRequestById<Impl: IWebView4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DeferredPermissionRequestById(id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView4, BASE_OFFSET>(),
            ExecutionMode: ExecutionMode::<Impl, IMPL_OFFSET>,
            DeferredPermissionRequests: DeferredPermissionRequests::<Impl, IMPL_OFFSET>,
            Settings: Settings::<Impl, IMPL_OFFSET>,
            UnsupportedUriSchemeIdentified: UnsupportedUriSchemeIdentified::<Impl, IMPL_OFFSET>,
            RemoveUnsupportedUriSchemeIdentified: RemoveUnsupportedUriSchemeIdentified::<Impl, IMPL_OFFSET>,
            NewWindowRequested: NewWindowRequested::<Impl, IMPL_OFFSET>,
            RemoveNewWindowRequested: RemoveNewWindowRequested::<Impl, IMPL_OFFSET>,
            PermissionRequested: PermissionRequested::<Impl, IMPL_OFFSET>,
            RemovePermissionRequested: RemovePermissionRequested::<Impl, IMPL_OFFSET>,
            AddWebAllowedObject: AddWebAllowedObject::<Impl, IMPL_OFFSET>,
            DeferredPermissionRequestById: DeferredPermissionRequestById::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView5Impl: Sized {
    fn XYFocusLeft(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusLeft(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusRight(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusRight(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusUp(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusUp(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusDown(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusDown(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView5";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView5Vtbl {
        unsafe extern "system" fn XYFocusLeft<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusLeft<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusLeft(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusRight<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusRight<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusRight(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusUp<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusUp<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusUp(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusDown<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusDown<Impl: IWebView5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusDown(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView5, BASE_OFFSET>(),
            XYFocusLeft: XYFocusLeft::<Impl, IMPL_OFFSET>,
            SetXYFocusLeft: SetXYFocusLeft::<Impl, IMPL_OFFSET>,
            XYFocusRight: XYFocusRight::<Impl, IMPL_OFFSET>,
            SetXYFocusRight: SetXYFocusRight::<Impl, IMPL_OFFSET>,
            XYFocusUp: XYFocusUp::<Impl, IMPL_OFFSET>,
            SetXYFocusUp: SetXYFocusUp::<Impl, IMPL_OFFSET>,
            XYFocusDown: XYFocusDown::<Impl, IMPL_OFFSET>,
            SetXYFocusDown: SetXYFocusDown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebView6Impl: Sized {
    fn SeparateProcessLost(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSeparateProcessLost(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView6";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebView6Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView6Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView6Vtbl {
        unsafe extern "system" fn SeparateProcessLost<Impl: IWebView6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SeparateProcessLost(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSeparateProcessLost<Impl: IWebView6Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSeparateProcessLost(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView6, BASE_OFFSET>(),
            SeparateProcessLost: SeparateProcessLost::<Impl, IMPL_OFFSET>,
            RemoveSeparateProcessLost: RemoveSeparateProcessLost::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebView7Impl: Sized {
    fn WebResourceRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveWebResourceRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView7";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebView7Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView7Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView7Vtbl {
        unsafe extern "system" fn WebResourceRequested<Impl: IWebView7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WebResourceRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveWebResourceRequested<Impl: IWebView7Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveWebResourceRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView7, BASE_OFFSET>(),
            WebResourceRequested: WebResourceRequested::<Impl, IMPL_OFFSET>,
            RemoveWebResourceRequested: RemoveWebResourceRequested::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewBrushImpl: Sized {
    fn SourceName(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSourceName(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Redraw(&mut self) -> ::windows::core::Result<()>;
    fn SetSource(&mut self, source: &::core::option::Option<WebView>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewBrush {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewBrush";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewBrushVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewBrushImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewBrushVtbl {
        unsafe extern "system" fn SourceName<Impl: IWebViewBrushImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceName<Impl: IWebViewBrushImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Redraw<Impl: IWebViewBrushImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Redraw().into()
        }
        unsafe extern "system" fn SetSource<Impl: IWebViewBrushImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&source as *const <WebView as ::windows::core::Abi>::Abi as *const <WebView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewBrush, BASE_OFFSET>(),
            SourceName: SourceName::<Impl, IMPL_OFFSET>,
            SetSourceName: SetSourceName::<Impl, IMPL_OFFSET>,
            Redraw: Redraw::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewBrush as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewBrushStaticsImpl: Sized {
    fn SourceNameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewBrushStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewBrushStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewBrushStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewBrushStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewBrushStaticsVtbl {
        unsafe extern "system" fn SourceNameProperty<Impl: IWebViewBrushStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewBrushStatics, BASE_OFFSET>(),
            SourceNameProperty: SourceNameProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewBrushStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewContentLoadingEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewContentLoadingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewContentLoadingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewContentLoadingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewContentLoadingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewContentLoadingEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewContentLoadingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewContentLoadingEventArgs, BASE_OFFSET>(), Uri: Uri::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewContentLoadingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewDOMContentLoadedEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewDOMContentLoadedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewDOMContentLoadedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewDOMContentLoadedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewDOMContentLoadedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewDOMContentLoadedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewDOMContentLoadedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewDOMContentLoadedEventArgs, BASE_OFFSET>(), Uri: Uri::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewDOMContentLoadedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewDeferredPermissionRequestImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn PermissionType(&mut self) -> ::windows::core::Result<WebViewPermissionType>;
    fn Id(&mut self) -> ::windows::core::Result<u32>;
    fn Allow(&mut self) -> ::windows::core::Result<()>;
    fn Deny(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewDeferredPermissionRequest {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewDeferredPermissionRequest";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewDeferredPermissionRequestVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewDeferredPermissionRequestImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewDeferredPermissionRequestVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PermissionType<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Id<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Id() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Allow<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Allow().into()
        }
        unsafe extern "system" fn Deny<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Deny().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewDeferredPermissionRequest, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            PermissionType: PermissionType::<Impl, IMPL_OFFSET>,
            Id: Id::<Impl, IMPL_OFFSET>,
            Allow: Allow::<Impl, IMPL_OFFSET>,
            Deny: Deny::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewDeferredPermissionRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewFactory4Impl: Sized {
    fn CreateInstanceWithExecutionMode(&mut self, executionmode: WebViewExecutionMode) -> ::windows::core::Result<WebView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewFactory4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewFactory4";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewFactory4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewFactory4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewFactory4Vtbl {
        unsafe extern "system" fn CreateInstanceWithExecutionMode<Impl: IWebViewFactory4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, executionmode: WebViewExecutionMode, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithExecutionMode(executionmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewFactory4, BASE_OFFSET>(),
            CreateInstanceWithExecutionMode: CreateInstanceWithExecutionMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewFactory4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewLongRunningScriptDetectedEventArgsImpl: Sized {
    fn ExecutionTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn StopPageScriptExecution(&mut self) -> ::windows::core::Result<bool>;
    fn SetStopPageScriptExecution(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewLongRunningScriptDetectedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewLongRunningScriptDetectedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewLongRunningScriptDetectedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewLongRunningScriptDetectedEventArgsVtbl {
        unsafe extern "system" fn ExecutionTime<Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExecutionTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopPageScriptExecution<Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StopPageScriptExecution() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStopPageScriptExecution<Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStopPageScriptExecution(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewLongRunningScriptDetectedEventArgs, BASE_OFFSET>(),
            ExecutionTime: ExecutionTime::<Impl, IMPL_OFFSET>,
            StopPageScriptExecution: StopPageScriptExecution::<Impl, IMPL_OFFSET>,
            SetStopPageScriptExecution: SetStopPageScriptExecution::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewLongRunningScriptDetectedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
pub trait IWebViewNavigationCompletedEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn IsSuccess(&mut self) -> ::windows::core::Result<bool>;
    fn WebErrorStatus(&mut self) -> ::windows::core::Result<super::super::super::Web::WebErrorStatus>;
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNavigationCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationCompletedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl IWebViewNavigationCompletedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNavigationCompletedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNavigationCompletedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationCompletedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSuccess<Impl: IWebViewNavigationCompletedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSuccess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WebErrorStatus<Impl: IWebViewNavigationCompletedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Web::WebErrorStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WebErrorStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNavigationCompletedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            IsSuccess: IsSuccess::<Impl, IMPL_OFFSET>,
            WebErrorStatus: WebErrorStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNavigationCompletedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
pub trait IWebViewNavigationFailedEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn WebErrorStatus(&mut self) -> ::windows::core::Result<super::super::super::Web::WebErrorStatus>;
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNavigationFailedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationFailedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl IWebViewNavigationFailedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNavigationFailedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNavigationFailedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationFailedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WebErrorStatus<Impl: IWebViewNavigationFailedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Web::WebErrorStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WebErrorStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNavigationFailedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            WebErrorStatus: WebErrorStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNavigationFailedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewNavigationStartingEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNavigationStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationStartingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewNavigationStartingEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNavigationStartingEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNavigationStartingEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IWebViewNavigationStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IWebViewNavigationStartingEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNavigationStartingEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNavigationStartingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewNewWindowRequestedEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Referrer(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNewWindowRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNewWindowRequestedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewNewWindowRequestedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNewWindowRequestedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNewWindowRequestedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Referrer<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Referrer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNewWindowRequestedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Referrer: Referrer::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNewWindowRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewPermissionRequestImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn PermissionType(&mut self) -> ::windows::core::Result<WebViewPermissionType>;
    fn Id(&mut self) -> ::windows::core::Result<u32>;
    fn State(&mut self) -> ::windows::core::Result<WebViewPermissionState>;
    fn Defer(&mut self) -> ::windows::core::Result<()>;
    fn Allow(&mut self) -> ::windows::core::Result<()>;
    fn Deny(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewPermissionRequest {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewPermissionRequest";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewPermissionRequestVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewPermissionRequestImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewPermissionRequestVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PermissionType<Impl: IWebViewPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Id<Impl: IWebViewPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Id() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn State<Impl: IWebViewPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).State() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Defer<Impl: IWebViewPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Defer().into()
        }
        unsafe extern "system" fn Allow<Impl: IWebViewPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Allow().into()
        }
        unsafe extern "system" fn Deny<Impl: IWebViewPermissionRequestImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Deny().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewPermissionRequest, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            PermissionType: PermissionType::<Impl, IMPL_OFFSET>,
            Id: Id::<Impl, IMPL_OFFSET>,
            State: State::<Impl, IMPL_OFFSET>,
            Defer: Defer::<Impl, IMPL_OFFSET>,
            Allow: Allow::<Impl, IMPL_OFFSET>,
            Deny: Deny::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewPermissionRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewPermissionRequestedEventArgsImpl: Sized {
    fn PermissionRequest(&mut self) -> ::windows::core::Result<WebViewPermissionRequest>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewPermissionRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewPermissionRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewPermissionRequestedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewPermissionRequestedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewPermissionRequestedEventArgsVtbl {
        unsafe extern "system" fn PermissionRequest<Impl: IWebViewPermissionRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionRequest() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewPermissionRequestedEventArgs, BASE_OFFSET>(),
            PermissionRequest: PermissionRequest::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewPermissionRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewSeparateProcessLostEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewSeparateProcessLostEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewSeparateProcessLostEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewSeparateProcessLostEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewSeparateProcessLostEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewSeparateProcessLostEventArgsVtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewSeparateProcessLostEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewSeparateProcessLostEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewSettingsImpl: Sized {
    fn IsJavaScriptEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsJavaScriptEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsIndexedDBEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsIndexedDBEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewSettings";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewSettingsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewSettingsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewSettingsVtbl {
        unsafe extern "system" fn IsJavaScriptEnabled<Impl: IWebViewSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsJavaScriptEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsJavaScriptEnabled<Impl: IWebViewSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsJavaScriptEnabled(value).into()
        }
        unsafe extern "system" fn IsIndexedDBEnabled<Impl: IWebViewSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIndexedDBEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsIndexedDBEnabled<Impl: IWebViewSettingsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsIndexedDBEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewSettings, BASE_OFFSET>(),
            IsJavaScriptEnabled: IsJavaScriptEnabled::<Impl, IMPL_OFFSET>,
            SetIsJavaScriptEnabled: SetIsJavaScriptEnabled::<Impl, IMPL_OFFSET>,
            IsIndexedDBEnabled: IsIndexedDBEnabled::<Impl, IMPL_OFFSET>,
            SetIsIndexedDBEnabled: SetIsIndexedDBEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewSettings as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IWebViewStaticsImpl: Sized {
    fn AnyScriptNotifyUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>;
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AllowedScriptNotifyUrisProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DataTransferPackageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IWebViewStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStaticsVtbl {
        unsafe extern "system" fn AnyScriptNotifyUri<Impl: IWebViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnyScriptNotifyUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IWebViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllowedScriptNotifyUrisProperty<Impl: IWebViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AllowedScriptNotifyUrisProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DataTransferPackageProperty<Impl: IWebViewStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataTransferPackageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics, BASE_OFFSET>(),
            AnyScriptNotifyUri: AnyScriptNotifyUri::<Impl, IMPL_OFFSET>,
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            AllowedScriptNotifyUrisProperty: AllowedScriptNotifyUrisProperty::<Impl, IMPL_OFFSET>,
            DataTransferPackageProperty: DataTransferPackageProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics2Impl: Sized {
    fn CanGoBackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoForwardProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DocumentTitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultBackgroundColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics2Vtbl {
        unsafe extern "system" fn CanGoBackProperty<Impl: IWebViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForwardProperty<Impl: IWebViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForwardProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DocumentTitleProperty<Impl: IWebViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DocumentTitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultBackgroundColorProperty<Impl: IWebViewStatics2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultBackgroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics2, BASE_OFFSET>(),
            CanGoBackProperty: CanGoBackProperty::<Impl, IMPL_OFFSET>,
            CanGoForwardProperty: CanGoForwardProperty::<Impl, IMPL_OFFSET>,
            DocumentTitleProperty: DocumentTitleProperty::<Impl, IMPL_OFFSET>,
            DefaultBackgroundColorProperty: DefaultBackgroundColorProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics3Impl: Sized {
    fn ContainsFullScreenElementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics3Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics3Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics3Vtbl {
        unsafe extern "system" fn ContainsFullScreenElementProperty<Impl: IWebViewStatics3Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics3, BASE_OFFSET>(),
            ContainsFullScreenElementProperty: ContainsFullScreenElementProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewStatics4Impl: Sized {
    fn DefaultExecutionMode(&mut self) -> ::windows::core::Result<WebViewExecutionMode>;
    fn ClearTemporaryWebDataAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewStatics4Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics4Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics4Vtbl {
        unsafe extern "system" fn DefaultExecutionMode<Impl: IWebViewStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewExecutionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultExecutionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearTemporaryWebDataAsync<Impl: IWebViewStatics4Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClearTemporaryWebDataAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics4, BASE_OFFSET>(),
            DefaultExecutionMode: DefaultExecutionMode::<Impl, IMPL_OFFSET>,
            ClearTemporaryWebDataAsync: ClearTemporaryWebDataAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics5Impl: Sized {
    fn XYFocusLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusRightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusUpProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusDownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics5Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics5Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics5Vtbl {
        unsafe extern "system" fn XYFocusLeftProperty<Impl: IWebViewStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusRightProperty<Impl: IWebViewStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusUpProperty<Impl: IWebViewStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUpProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusDownProperty<Impl: IWebViewStatics5Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics5, BASE_OFFSET>(),
            XYFocusLeftProperty: XYFocusLeftProperty::<Impl, IMPL_OFFSET>,
            XYFocusRightProperty: XYFocusRightProperty::<Impl, IMPL_OFFSET>,
            XYFocusUpProperty: XYFocusUpProperty::<Impl, IMPL_OFFSET>,
            XYFocusDownProperty: XYFocusDownProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewUnsupportedUriSchemeIdentifiedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnsupportedUriSchemeIdentifiedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewUnsupportedUriSchemeIdentifiedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewUnsupportedUriSchemeIdentifiedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewUnsupportedUriSchemeIdentifiedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewUnsupportedUriSchemeIdentifiedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewUnviewableContentIdentifiedEventArgsImpl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Referrer(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewUnviewableContentIdentifiedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewUnviewableContentIdentifiedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewUnviewableContentIdentifiedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewUnviewableContentIdentifiedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewUnviewableContentIdentifiedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Referrer<Impl: IWebViewUnviewableContentIdentifiedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Referrer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewUnviewableContentIdentifiedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Referrer: Referrer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewUnviewableContentIdentifiedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewUnviewableContentIdentifiedEventArgs2Impl: Sized {
    fn MediaType(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewUnviewableContentIdentifiedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewUnviewableContentIdentifiedEventArgs2Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewUnviewableContentIdentifiedEventArgs2Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewUnviewableContentIdentifiedEventArgs2Vtbl {
        unsafe extern "system" fn MediaType<Impl: IWebViewUnviewableContentIdentifiedEventArgs2Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewUnviewableContentIdentifiedEventArgs2, BASE_OFFSET>(),
            MediaType: MediaType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewUnviewableContentIdentifiedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Web_Http", feature = "implement_exclusive"))]
pub trait IWebViewWebResourceRequestedEventArgsImpl: Sized {
    fn Request(&mut self) -> ::windows::core::Result<super::super::super::Web::Http::HttpRequestMessage>;
    fn Response(&mut self) -> ::windows::core::Result<super::super::super::Web::Http::HttpResponseMessage>;
    fn SetResponse(&mut self, value: &::core::option::Option<super::super::super::Web::Http::HttpResponseMessage>) -> ::windows::core::Result<()>;
    fn GetDeferral(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Deferral>;
}
#[cfg(all(feature = "Foundation", feature = "Web_Http", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewWebResourceRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewWebResourceRequestedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Web_Http", feature = "implement_exclusive"))]
impl IWebViewWebResourceRequestedEventArgsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewWebResourceRequestedEventArgsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewWebResourceRequestedEventArgsVtbl {
        unsafe extern "system" fn Request<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Request() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Response<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Response() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetResponse<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetResponse(&*(&value as *const <super::super::super::Web::Http::HttpResponseMessage as ::windows::core::Abi>::Abi as *const <super::super::super::Web::Http::HttpResponseMessage as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewWebResourceRequestedEventArgs, BASE_OFFSET>(),
            Request: Request::<Impl, IMPL_OFFSET>,
            Response: Response::<Impl, IMPL_OFFSET>,
            SetResponse: SetResponse::<Impl, IMPL_OFFSET>,
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewWebResourceRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWrapGridImpl: Sized {
    fn ItemWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn HorizontalChildrenAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalChildrenAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalChildrenAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalChildrenAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWrapGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IWrapGridVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWrapGridImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWrapGridVtbl {
        unsafe extern "system" fn ItemWidth<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn ItemHeight<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn HorizontalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn VerticalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IWrapGridImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWrapGrid, BASE_OFFSET>(),
            ItemWidth: ItemWidth::<Impl, IMPL_OFFSET>,
            SetItemWidth: SetItemWidth::<Impl, IMPL_OFFSET>,
            ItemHeight: ItemHeight::<Impl, IMPL_OFFSET>,
            SetItemHeight: SetItemHeight::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignment: HorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalChildrenAlignment: SetHorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignment: VerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalChildrenAlignment: SetVerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumns: MaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            SetMaximumRowsOrColumns: SetMaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWrapGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWrapGridStaticsImpl: Sized {
    fn ItemWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IWrapGridStaticsVtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWrapGridStaticsImpl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWrapGridStaticsVtbl {
        unsafe extern "system" fn ItemWidthProperty<Impl: IWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemHeightProperty<Impl: IWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalChildrenAlignmentProperty<Impl: IWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalChildrenAlignmentProperty<Impl: IWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IWrapGridStaticsImpl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWrapGridStatics, BASE_OFFSET>(),
            ItemWidthProperty: ItemWidthProperty::<Impl, IMPL_OFFSET>,
            ItemHeightProperty: ItemHeightProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignmentProperty: HorizontalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignmentProperty: VerticalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumnsProperty: MaximumRowsOrColumnsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWrapGridStatics as ::windows::core::Interface>::IID
    }
}
