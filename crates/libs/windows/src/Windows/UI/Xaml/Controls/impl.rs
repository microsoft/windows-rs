#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IAnchorRequestedEventArgs_Impl: Sized {
    fn Anchor(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetAnchor(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn AnchorCandidates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::UIElement>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAnchorRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAnchorRequestedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IAnchorRequestedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAnchorRequestedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAnchorRequestedEventArgs_Vtbl {
        unsafe extern "system" fn Anchor<Impl: IAnchorRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Anchor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAnchor<Impl: IAnchorRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAnchor(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AnchorCandidates<Impl: IAnchorRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnchorCandidates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAnchorRequestedEventArgs, BASE_OFFSET>(),
            Anchor: Anchor::<Impl, IMPL_OFFSET>,
            SetAnchor: SetAnchor::<Impl, IMPL_OFFSET>,
            AnchorCandidates: AnchorCandidates::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAnchorRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IAppBar_Impl: Sized {
    fn IsOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSticky(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSticky(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IAppBar_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBar_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBar_Vtbl {
        unsafe extern "system" fn IsOpen<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOpen<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOpen(value).into()
        }
        unsafe extern "system" fn IsSticky<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSticky() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSticky<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSticky(value).into()
        }
        unsafe extern "system" fn Opened<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IAppBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar, BASE_OFFSET>(),
            IsOpen: IsOpen::<Impl, IMPL_OFFSET>,
            SetIsOpen: SetIsOpen::<Impl, IMPL_OFFSET>,
            IsSticky: IsSticky::<Impl, IMPL_OFFSET>,
            SetIsSticky: SetIsSticky::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBar2_Impl: Sized {
    fn ClosedDisplayMode(&mut self) -> ::windows::core::Result<AppBarClosedDisplayMode>;
    fn SetClosedDisplayMode(&mut self, value: AppBarClosedDisplayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar2";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBar2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBar2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBar2_Vtbl {
        unsafe extern "system" fn ClosedDisplayMode<Impl: IAppBar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut AppBarClosedDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClosedDisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClosedDisplayMode<Impl: IAppBar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: AppBarClosedDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClosedDisplayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar2, BASE_OFFSET>(),
            ClosedDisplayMode: ClosedDisplayMode::<Impl, IMPL_OFFSET>,
            SetClosedDisplayMode: SetClosedDisplayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IAppBar3_Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::AppBarTemplateSettings>;
    fn Opening(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar3";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IAppBar3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBar3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBar3_Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Opening<Impl: IAppBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opening(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpening<Impl: IAppBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closing<Impl: IAppBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closing(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosing<Impl: IAppBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar3, BASE_OFFSET>(),
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            Opening: Opening::<Impl, IMPL_OFFSET>,
            RemoveOpening: RemoveOpening::<Impl, IMPL_OFFSET>,
            Closing: Closing::<Impl, IMPL_OFFSET>,
            RemoveClosing: RemoveClosing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBar4_Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBar4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBar4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBar4_Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IAppBar4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IAppBar4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBar4, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBar4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton_Impl: Sized {
    fn Label(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetLabel(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButton_Vtbl {
        unsafe extern "system" fn Label<Impl: IAppBarButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Label() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IAppBarButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabel(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Icon<Impl: IAppBarButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IAppBarButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton, BASE_OFFSET>(),
            Label: Label::<Impl, IMPL_OFFSET>,
            SetLabel: SetLabel::<Impl, IMPL_OFFSET>,
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton3_Impl: Sized {
    fn LabelPosition(&mut self) -> ::windows::core::Result<CommandBarLabelPosition>;
    fn SetLabelPosition(&mut self, value: CommandBarLabelPosition) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButton3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButton3_Vtbl {
        unsafe extern "system" fn LabelPosition<Impl: IAppBarButton3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabelPosition<Impl: IAppBarButton3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabelPosition(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton3, BASE_OFFSET>(),
            LabelPosition: LabelPosition::<Impl, IMPL_OFFSET>,
            SetLabelPosition: SetLabelPosition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton4_Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButton4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButton4_Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IAppBarButton4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IAppBarButton4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverride: KeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            SetKeyboardAcceleratorTextOverride: SetKeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IAppBarButton5_Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::AppBarButtonTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBarButton5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton5";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IAppBarButton5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButton5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButton5_Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBarButton5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButton5, BASE_OFFSET>(), TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButton5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStatics_Impl: Sized {
    fn LabelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonStatics_Vtbl {
        unsafe extern "system" fn LabelProperty<Impl: IAppBarButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconProperty<Impl: IAppBarButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonStatics, BASE_OFFSET>(),
            LabelProperty: LabelProperty::<Impl, IMPL_OFFSET>,
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStatics3_Impl: Sized {
    fn LabelPositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonStatics3_Vtbl {
        unsafe extern "system" fn LabelPositionProperty<Impl: IAppBarButtonStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarButtonStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarButtonStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonStatics3, BASE_OFFSET>(),
            LabelPositionProperty: LabelPositionProperty::<Impl, IMPL_OFFSET>,
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStatics4_Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarButtonStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarButtonStatics4_Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IAppBarButtonStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarButtonStatics4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverrideProperty: KeyboardAcceleratorTextOverrideProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarButtonStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainer_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainer";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarElementContainer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarElementContainer_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarElementContainer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarElementContainer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarElementContainer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarElementContainerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarElementContainerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarElementContainerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarElementContainerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarElementContainerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerStatics_Impl: Sized {
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarElementContainerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarElementContainerStatics_Vtbl {
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarElementContainerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarElementContainerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarElementContainerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarElementContainerStatics, BASE_OFFSET>(),
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarElementContainerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarOverrides_Impl: Sized {
    fn OnClosed(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOpened(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarOverrides_Vtbl {
        unsafe extern "system" fn OnClosed<Impl: IAppBarOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClosed(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOpened<Impl: IAppBarOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOpened(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarOverrides, BASE_OFFSET>(),
            OnClosed: OnClosed::<Impl, IMPL_OFFSET>,
            OnOpened: OnOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarOverrides3_Impl: Sized {
    fn OnClosing(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOpening(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarOverrides3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarOverrides3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarOverrides3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarOverrides3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarOverrides3_Vtbl {
        unsafe extern "system" fn OnClosing<Impl: IAppBarOverrides3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClosing(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOpening<Impl: IAppBarOverrides3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOpening(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarOverrides3, BASE_OFFSET>(),
            OnClosing: OnClosing::<Impl, IMPL_OFFSET>,
            OnOpening: OnOpening::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarOverrides3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparator_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparator_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparator, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparatorFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparatorFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarSeparatorFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparatorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparatorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorStatics_Impl: Sized {
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparatorStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparatorStatics_Vtbl {
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarSeparatorStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparatorStatics, BASE_OFFSET>(),
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparatorStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorStatics3_Impl: Sized {
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarSeparatorStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarSeparatorStatics3_Vtbl {
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarSeparatorStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarSeparatorStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarSeparatorStatics3, BASE_OFFSET>(),
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarSeparatorStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStatics_Impl: Sized {
    fn IsOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStickyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarStatics_Vtbl {
        unsafe extern "system" fn IsOpenProperty<Impl: IAppBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStickyProperty<Impl: IAppBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStickyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarStatics, BASE_OFFSET>(),
            IsOpenProperty: IsOpenProperty::<Impl, IMPL_OFFSET>,
            IsStickyProperty: IsStickyProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStatics2_Impl: Sized {
    fn ClosedDisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarStatics2_Vtbl {
        unsafe extern "system" fn ClosedDisplayModeProperty<Impl: IAppBarStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClosedDisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarStatics2, BASE_OFFSET>(),
            ClosedDisplayModeProperty: ClosedDisplayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStatics4_Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarStatics4_Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IAppBarStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarStatics4, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton_Impl: Sized {
    fn Label(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetLabel(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButton_Vtbl {
        unsafe extern "system" fn Label<Impl: IAppBarToggleButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Label() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IAppBarToggleButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabel(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Icon<Impl: IAppBarToggleButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IAppBarToggleButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton, BASE_OFFSET>(),
            Label: Label::<Impl, IMPL_OFFSET>,
            SetLabel: SetLabel::<Impl, IMPL_OFFSET>,
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton3_Impl: Sized {
    fn LabelPosition(&mut self) -> ::windows::core::Result<CommandBarLabelPosition>;
    fn SetLabelPosition(&mut self, value: CommandBarLabelPosition) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButton3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButton3_Vtbl {
        unsafe extern "system" fn LabelPosition<Impl: IAppBarToggleButton3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabelPosition<Impl: IAppBarToggleButton3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabelPosition(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton3, BASE_OFFSET>(),
            LabelPosition: LabelPosition::<Impl, IMPL_OFFSET>,
            SetLabelPosition: SetLabelPosition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton4_Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButton4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButton4_Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IAppBarToggleButton4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IAppBarToggleButton4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverride: KeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            SetKeyboardAcceleratorTextOverride: SetKeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IAppBarToggleButton5_Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::AppBarToggleButtonTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAppBarToggleButton5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton5";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IAppBarToggleButton5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButton5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButton5_Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBarToggleButton5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButton5, BASE_OFFSET>(),
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButton5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarToggleButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarToggleButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStatics_Impl: Sized {
    fn LabelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonStatics_Vtbl {
        unsafe extern "system" fn LabelProperty<Impl: IAppBarToggleButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconProperty<Impl: IAppBarToggleButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarToggleButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonStatics, BASE_OFFSET>(),
            LabelProperty: LabelProperty::<Impl, IMPL_OFFSET>,
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStatics3_Impl: Sized {
    fn LabelPositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonStatics3_Vtbl {
        unsafe extern "system" fn LabelPositionProperty<Impl: IAppBarToggleButtonStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarToggleButtonStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarToggleButtonStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonStatics3, BASE_OFFSET>(),
            LabelPositionProperty: LabelPositionProperty::<Impl, IMPL_OFFSET>,
            IsInOverflowProperty: IsInOverflowProperty::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrderProperty: DynamicOverflowOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStatics4_Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAppBarToggleButtonStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAppBarToggleButtonStatics4_Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IAppBarToggleButtonStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAppBarToggleButtonStatics4, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverrideProperty: KeyboardAcceleratorTextOverrideProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAppBarToggleButtonStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IAutoSuggestBox_Impl: Sized {
    fn MaxSuggestionListHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxSuggestionListHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsSuggestionListOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSuggestionListOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextMemberPath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTextMemberPath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn UpdateTextOnSelect(&mut self) -> ::windows::core::Result<bool>;
    fn SetUpdateTextOnSelect(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AutoMaximizeSuggestionArea(&mut self) -> ::windows::core::Result<bool>;
    fn SetAutoMaximizeSuggestionArea(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextBoxStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetTextBoxStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SuggestionChosen(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSuggestionChosen(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAutoSuggestBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IAutoSuggestBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBox_Vtbl {
        unsafe extern "system" fn MaxSuggestionListHeight<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSuggestionListHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSuggestionListHeight<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxSuggestionListHeight(value).into()
        }
        unsafe extern "system" fn IsSuggestionListOpen<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSuggestionListOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSuggestionListOpen<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSuggestionListOpen(value).into()
        }
        unsafe extern "system" fn TextMemberPath<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextMemberPath<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Text<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UpdateTextOnSelect<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UpdateTextOnSelect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUpdateTextOnSelect<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUpdateTextOnSelect(value).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AutoMaximizeSuggestionArea<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoMaximizeSuggestionArea() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoMaximizeSuggestionArea<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoMaximizeSuggestionArea(value).into()
        }
        unsafe extern "system" fn TextBoxStyle<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextBoxStyle<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextBoxStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SuggestionChosen<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SuggestionChosen(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSuggestionChosen<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSuggestionChosen(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: IAutoSuggestBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox, BASE_OFFSET>(),
            MaxSuggestionListHeight: MaxSuggestionListHeight::<Impl, IMPL_OFFSET>,
            SetMaxSuggestionListHeight: SetMaxSuggestionListHeight::<Impl, IMPL_OFFSET>,
            IsSuggestionListOpen: IsSuggestionListOpen::<Impl, IMPL_OFFSET>,
            SetIsSuggestionListOpen: SetIsSuggestionListOpen::<Impl, IMPL_OFFSET>,
            TextMemberPath: TextMemberPath::<Impl, IMPL_OFFSET>,
            SetTextMemberPath: SetTextMemberPath::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            UpdateTextOnSelect: UpdateTextOnSelect::<Impl, IMPL_OFFSET>,
            SetUpdateTextOnSelect: SetUpdateTextOnSelect::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            AutoMaximizeSuggestionArea: AutoMaximizeSuggestionArea::<Impl, IMPL_OFFSET>,
            SetAutoMaximizeSuggestionArea: SetAutoMaximizeSuggestionArea::<Impl, IMPL_OFFSET>,
            TextBoxStyle: TextBoxStyle::<Impl, IMPL_OFFSET>,
            SetTextBoxStyle: SetTextBoxStyle::<Impl, IMPL_OFFSET>,
            SuggestionChosen: SuggestionChosen::<Impl, IMPL_OFFSET>,
            RemoveSuggestionChosen: RemoveSuggestionChosen::<Impl, IMPL_OFFSET>,
            TextChanged: TextChanged::<Impl, IMPL_OFFSET>,
            RemoveTextChanged: RemoveTextChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IAutoSuggestBox2_Impl: Sized {
    fn QueryIcon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetQueryIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
    fn QuerySubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQuerySubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IAutoSuggestBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IAutoSuggestBox2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBox2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBox2_Vtbl {
        unsafe extern "system" fn QueryIcon<Impl: IAutoSuggestBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryIcon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQueryIcon<Impl: IAutoSuggestBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetQueryIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QuerySubmitted<Impl: IAutoSuggestBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QuerySubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQuerySubmitted<Impl: IAutoSuggestBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveQuerySubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox2, BASE_OFFSET>(),
            QueryIcon: QueryIcon::<Impl, IMPL_OFFSET>,
            SetQueryIcon: SetQueryIcon::<Impl, IMPL_OFFSET>,
            QuerySubmitted: QuerySubmitted::<Impl, IMPL_OFFSET>,
            RemoveQuerySubmitted: RemoveQuerySubmitted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBox3_Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBox3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBox3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBox3_Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IAutoSuggestBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IAutoSuggestBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox3, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBox4_Impl: Sized {
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBox4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBox4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBox4_Vtbl {
        unsafe extern "system" fn Description<Impl: IAutoSuggestBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IAutoSuggestBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBox4, BASE_OFFSET>(),
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxQuerySubmittedEventArgs_Impl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ChosenSuggestion(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxQuerySubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxQuerySubmittedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxQuerySubmittedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxQuerySubmittedEventArgs_Vtbl {
        unsafe extern "system" fn QueryText<Impl: IAutoSuggestBoxQuerySubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChosenSuggestion<Impl: IAutoSuggestBoxQuerySubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChosenSuggestion() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxQuerySubmittedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            ChosenSuggestion: ChosenSuggestion::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxQuerySubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics_Impl: Sized {
    fn MaxSuggestionListHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSuggestionListOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextMemberPathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UpdateTextOnSelectProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoMaximizeSuggestionAreaProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextBoxStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStatics_Vtbl {
        unsafe extern "system" fn MaxSuggestionListHeightProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSuggestionListHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSuggestionListOpenProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSuggestionListOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextMemberPathProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateTextOnSelectProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UpdateTextOnSelectProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoMaximizeSuggestionAreaProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoMaximizeSuggestionAreaProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextBoxStyleProperty<Impl: IAutoSuggestBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics, BASE_OFFSET>(),
            MaxSuggestionListHeightProperty: MaxSuggestionListHeightProperty::<Impl, IMPL_OFFSET>,
            IsSuggestionListOpenProperty: IsSuggestionListOpenProperty::<Impl, IMPL_OFFSET>,
            TextMemberPathProperty: TextMemberPathProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            UpdateTextOnSelectProperty: UpdateTextOnSelectProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            AutoMaximizeSuggestionAreaProperty: AutoMaximizeSuggestionAreaProperty::<Impl, IMPL_OFFSET>,
            TextBoxStyleProperty: TextBoxStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics2_Impl: Sized {
    fn QueryIconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStatics2_Vtbl {
        unsafe extern "system" fn QueryIconProperty<Impl: IAutoSuggestBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryIconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics2, BASE_OFFSET>(),
            QueryIconProperty: QueryIconProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics3_Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStatics3_Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IAutoSuggestBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics3, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics4_Impl: Sized {
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxStatics4_Vtbl {
        unsafe extern "system" fn DescriptionProperty<Impl: IAutoSuggestBoxStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxStatics4, BASE_OFFSET>(),
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxSuggestionChosenEventArgs_Impl: Sized {
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxSuggestionChosenEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxSuggestionChosenEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxSuggestionChosenEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxSuggestionChosenEventArgs_Vtbl {
        unsafe extern "system" fn SelectedItem<Impl: IAutoSuggestBoxSuggestionChosenEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxSuggestionChosenEventArgs, BASE_OFFSET>(),
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxSuggestionChosenEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxTextChangedEventArgs_Impl: Sized {
    fn Reason(&mut self) -> ::windows::core::Result<AutoSuggestionBoxTextChangeReason>;
    fn SetReason(&mut self, value: AutoSuggestionBoxTextChangeReason) -> ::windows::core::Result<()>;
    fn CheckCurrent(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxTextChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxTextChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxTextChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxTextChangedEventArgs_Vtbl {
        unsafe extern "system" fn Reason<Impl: IAutoSuggestBoxTextChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut AutoSuggestionBoxTextChangeReason) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Reason() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReason<Impl: IAutoSuggestBoxTextChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: AutoSuggestionBoxTextChangeReason) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetReason(value).into()
        }
        unsafe extern "system" fn CheckCurrent<Impl: IAutoSuggestBoxTextChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CheckCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxTextChangedEventArgs, BASE_OFFSET>(),
            Reason: Reason::<Impl, IMPL_OFFSET>,
            SetReason: SetReason::<Impl, IMPL_OFFSET>,
            CheckCurrent: CheckCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxTextChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxTextChangedEventArgsStatics_Impl: Sized {
    fn ReasonProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxTextChangedEventArgsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxTextChangedEventArgsStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAutoSuggestBoxTextChangedEventArgsStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAutoSuggestBoxTextChangedEventArgsStatics_Vtbl {
        unsafe extern "system" fn ReasonProperty<Impl: IAutoSuggestBoxTextChangedEventArgsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReasonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IAutoSuggestBoxTextChangedEventArgsStatics, BASE_OFFSET>(),
            ReasonProperty: ReasonProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAutoSuggestBoxTextChangedEventArgsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBackClickEventArgs_Impl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBackClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBackClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IBackClickEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBackClickEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBackClickEventArgs_Vtbl {
        unsafe extern "system" fn Handled<Impl: IBackClickEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IBackClickEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBackClickEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBackClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IBitmapIcon_Impl: Sized {
    fn UriSource(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetUriSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IBitmapIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIcon";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IBitmapIcon_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIcon_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIcon_Vtbl {
        unsafe extern "system" fn UriSource<Impl: IBitmapIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUriSource<Impl: IBitmapIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUriSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIcon, BASE_OFFSET>(),
            UriSource: UriSource::<Impl, IMPL_OFFSET>,
            SetUriSource: SetUriSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIcon2_Impl: Sized {
    fn ShowAsMonochrome(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowAsMonochrome(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIcon2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIcon2";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIcon2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIcon2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIcon2_Vtbl {
        unsafe extern "system" fn ShowAsMonochrome<Impl: IBitmapIcon2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochrome() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAsMonochrome<Impl: IBitmapIcon2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowAsMonochrome(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIcon2, BASE_OFFSET>(),
            ShowAsMonochrome: ShowAsMonochrome::<Impl, IMPL_OFFSET>,
            SetShowAsMonochrome: SetShowAsMonochrome::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIcon2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<BitmapIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IBitmapIconFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IBitmapIconSource_Impl: Sized {
    fn UriSource(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetUriSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn ShowAsMonochrome(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowAsMonochrome(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IBitmapIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSource";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IBitmapIconSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconSource_Vtbl {
        unsafe extern "system" fn UriSource<Impl: IBitmapIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUriSource<Impl: IBitmapIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUriSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAsMonochrome<Impl: IBitmapIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochrome() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAsMonochrome<Impl: IBitmapIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowAsMonochrome(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconSource, BASE_OFFSET>(),
            UriSource: UriSource::<Impl, IMPL_OFFSET>,
            SetUriSource: SetUriSource::<Impl, IMPL_OFFSET>,
            ShowAsMonochrome: ShowAsMonochrome::<Impl, IMPL_OFFSET>,
            SetShowAsMonochrome: SetShowAsMonochrome::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconSourceFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<BitmapIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconSourceFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconSourceFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconSourceFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IBitmapIconSourceFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconSourceStatics_Impl: Sized {
    fn UriSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowAsMonochromeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconSourceStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconSourceStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconSourceStatics_Vtbl {
        unsafe extern "system" fn UriSourceProperty<Impl: IBitmapIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowAsMonochromeProperty<Impl: IBitmapIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochromeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconSourceStatics, BASE_OFFSET>(),
            UriSourceProperty: UriSourceProperty::<Impl, IMPL_OFFSET>,
            ShowAsMonochromeProperty: ShowAsMonochromeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconStatics_Impl: Sized {
    fn UriSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconStatics_Vtbl {
        unsafe extern "system" fn UriSourceProperty<Impl: IBitmapIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UriSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconStatics, BASE_OFFSET>(),
            UriSourceProperty: UriSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconStatics2_Impl: Sized {
    fn ShowAsMonochromeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBitmapIconStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBitmapIconStatics2_Vtbl {
        unsafe extern "system" fn ShowAsMonochromeProperty<Impl: IBitmapIconStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochromeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBitmapIconStatics2, BASE_OFFSET>(),
            ShowAsMonochromeProperty: ShowAsMonochromeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBitmapIconStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IBorder_Impl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Child(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ChildTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetChildTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IBorder {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorder";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IBorder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorder_Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Child<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChildTransitions<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChildTransitions<Impl: IBorder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChildTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorder, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            Child: Child::<Impl, IMPL_OFFSET>,
            SetChild: SetChild::<Impl, IMPL_OFFSET>,
            ChildTransitions: ChildTransitions::<Impl, IMPL_OFFSET>,
            SetChildTransitions: SetChildTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorder as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorder2_Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
    fn BackgroundTransition(&mut self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&mut self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorder2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorder2";
}
#[cfg(feature = "implement_exclusive")]
impl IBorder2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorder2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorder2_Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IBorder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IBorder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        unsafe extern "system" fn BackgroundTransition<Impl: IBorder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IBorder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorder2, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
            BackgroundTransition: BackgroundTransition::<Impl, IMPL_OFFSET>,
            SetBackgroundTransition: SetBackgroundTransition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorder2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorderStatics_Impl: Sized {
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorderStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorderStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBorderStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorderStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorderStatics_Vtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IBorderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IBorderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IBorderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IBorderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IBorderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildTransitionsProperty<Impl: IBorderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorderStatics, BASE_OFFSET>(),
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            ChildTransitionsProperty: ChildTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorderStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorderStatics2_Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorderStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorderStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IBorderStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBorderStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBorderStatics2_Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IBorderStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IBorderStatics2, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBorderStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButton_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButton";
}
#[cfg(feature = "implement_exclusive")]
impl IButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButton_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Button>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IButtonFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonStaticsWithFlyout_Impl: Sized {
    fn FlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButtonStaticsWithFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonStaticsWithFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonStaticsWithFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButtonStaticsWithFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButtonStaticsWithFlyout_Vtbl {
        unsafe extern "system" fn FlyoutProperty<Impl: IButtonStaticsWithFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IButtonStaticsWithFlyout, BASE_OFFSET>(),
            FlyoutProperty: FlyoutProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButtonStaticsWithFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IButtonWithFlyout_Impl: Sized {
    fn Flyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IButtonWithFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonWithFlyout";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IButtonWithFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IButtonWithFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IButtonWithFlyout_Vtbl {
        unsafe extern "system" fn Flyout<Impl: IButtonWithFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Flyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyout<Impl: IButtonWithFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IButtonWithFlyout, BASE_OFFSET>(),
            Flyout: Flyout::<Impl, IMPL_OFFSET>,
            SetFlyout: SetFlyout::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IButtonWithFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Globalization", feature = "implement_exclusive"))]
pub trait ICalendarDatePicker_Impl: Sized {
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn SetDate(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>) -> ::windows::core::Result<()>;
    fn IsCalendarOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCalendarOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DateFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDateFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn CalendarViewStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCalendarViewStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn MinDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn IsTodayHighlighted(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTodayHighlighted(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<CalendarViewDisplayMode>;
    fn SetDisplayMode(&mut self, value: CalendarViewDisplayMode) -> ::windows::core::Result<()>;
    fn FirstDayOfWeek(&mut self) -> ::windows::core::Result<super::super::super::Globalization::DayOfWeek>;
    fn SetFirstDayOfWeek(&mut self, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::Result<()>;
    fn DayOfWeekFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayOfWeekFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsOutOfScopeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOutOfScopeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsGroupLabelVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsGroupLabelVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemChanging(&mut self, handler: &::core::option::Option<CalendarViewDayItemChangingEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCalendarViewDayItemChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDisplayDate(&mut self, date: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn SetYearDecadeDisplayDimensions(&mut self, columns: i32, rows: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Globalization", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarDatePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker";
}
#[cfg(all(feature = "Foundation", feature = "Globalization", feature = "implement_exclusive"))]
impl ICalendarDatePicker_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePicker_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePicker_Vtbl {
        unsafe extern "system" fn Date<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsCalendarOpen<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCalendarOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCalendarOpen<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCalendarOpen(value).into()
        }
        unsafe extern "system" fn DateFormat<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDateFormat<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDateFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewStyle<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarViewStyle<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarViewStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinDate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinDate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxDate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTodayHighlighted<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTodayHighlighted<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTodayHighlighted(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn FirstDayOfWeek<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstDayOfWeek<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstDayOfWeek(value).into()
        }
        unsafe extern "system" fn DayOfWeekFormat<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayOfWeekFormat<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayOfWeekFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarIdentifier<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsOutOfScopeEnabled<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOutOfScopeEnabled<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOutOfScopeEnabled(value).into()
        }
        unsafe extern "system" fn IsGroupLabelVisible<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroupLabelVisible<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsGroupLabelVisible(value).into()
        }
        unsafe extern "system" fn CalendarViewDayItemChanging<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemChanging(&*(&handler as *const <CalendarViewDayItemChangingEventHandler as ::windows::core::Abi>::Abi as *const <CalendarViewDayItemChangingEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCalendarViewDayItemChanging<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCalendarViewDayItemChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DateChanged<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDateChanged<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDisplayDate<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, date: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayDate(&*(&date as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetYearDecadeDisplayDimensions<Impl: ICalendarDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, columns: i32, rows: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearDecadeDisplayDimensions(columns, rows).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePicker, BASE_OFFSET>(),
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDate: SetDate::<Impl, IMPL_OFFSET>,
            IsCalendarOpen: IsCalendarOpen::<Impl, IMPL_OFFSET>,
            SetIsCalendarOpen: SetIsCalendarOpen::<Impl, IMPL_OFFSET>,
            DateFormat: DateFormat::<Impl, IMPL_OFFSET>,
            SetDateFormat: SetDateFormat::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            CalendarViewStyle: CalendarViewStyle::<Impl, IMPL_OFFSET>,
            SetCalendarViewStyle: SetCalendarViewStyle::<Impl, IMPL_OFFSET>,
            MinDate: MinDate::<Impl, IMPL_OFFSET>,
            SetMinDate: SetMinDate::<Impl, IMPL_OFFSET>,
            MaxDate: MaxDate::<Impl, IMPL_OFFSET>,
            SetMaxDate: SetMaxDate::<Impl, IMPL_OFFSET>,
            IsTodayHighlighted: IsTodayHighlighted::<Impl, IMPL_OFFSET>,
            SetIsTodayHighlighted: SetIsTodayHighlighted::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            SetDisplayMode: SetDisplayMode::<Impl, IMPL_OFFSET>,
            FirstDayOfWeek: FirstDayOfWeek::<Impl, IMPL_OFFSET>,
            SetFirstDayOfWeek: SetFirstDayOfWeek::<Impl, IMPL_OFFSET>,
            DayOfWeekFormat: DayOfWeekFormat::<Impl, IMPL_OFFSET>,
            SetDayOfWeekFormat: SetDayOfWeekFormat::<Impl, IMPL_OFFSET>,
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabled: IsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            SetIsOutOfScopeEnabled: SetIsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisible: IsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            SetIsGroupLabelVisible: SetIsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemChanging: CalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            RemoveCalendarViewDayItemChanging: RemoveCalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            DateChanged: DateChanged::<Impl, IMPL_OFFSET>,
            RemoveDateChanged: RemoveDateChanged::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            SetDisplayDate: SetDisplayDate::<Impl, IMPL_OFFSET>,
            SetYearDecadeDisplayDimensions: SetYearDecadeDisplayDimensions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePicker2_Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePicker2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePicker2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePicker2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ICalendarDatePicker2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ICalendarDatePicker2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePicker2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePicker2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePicker3_Impl: Sized {
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker3";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePicker3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePicker3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePicker3_Vtbl {
        unsafe extern "system" fn Description<Impl: ICalendarDatePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: ICalendarDatePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePicker3, BASE_OFFSET>(),
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePicker3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICalendarDatePickerDateChangedEventArgs_Impl: Sized {
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarDatePickerDateChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerDateChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICalendarDatePickerDateChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerDateChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerDateChangedEventArgs_Vtbl {
        unsafe extern "system" fn NewDate<Impl: ICalendarDatePickerDateChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OldDate<Impl: ICalendarDatePickerDateChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerDateChangedEventArgs, BASE_OFFSET>(),
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerDateChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarDatePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarDatePickerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStatics_Impl: Sized {
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCalendarOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarViewStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTodayHighlightedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstDayOfWeekProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayOfWeekFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOutOfScopeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupLabelVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerStatics_Vtbl {
        unsafe extern "system" fn DateProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCalendarOpenProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCalendarOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateFormatProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarViewStyleProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinDateProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDateProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTodayHighlightedProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlightedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstDayOfWeekProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayOfWeekFormatProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOutOfScopeEnabledProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupLabelVisibleProperty<Impl: ICalendarDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerStatics, BASE_OFFSET>(),
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
            IsCalendarOpenProperty: IsCalendarOpenProperty::<Impl, IMPL_OFFSET>,
            DateFormatProperty: DateFormatProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            CalendarViewStyleProperty: CalendarViewStyleProperty::<Impl, IMPL_OFFSET>,
            MinDateProperty: MinDateProperty::<Impl, IMPL_OFFSET>,
            MaxDateProperty: MaxDateProperty::<Impl, IMPL_OFFSET>,
            IsTodayHighlightedProperty: IsTodayHighlightedProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            FirstDayOfWeekProperty: FirstDayOfWeekProperty::<Impl, IMPL_OFFSET>,
            DayOfWeekFormatProperty: DayOfWeekFormatProperty::<Impl, IMPL_OFFSET>,
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabledProperty: IsOutOfScopeEnabledProperty::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisibleProperty: IsGroupLabelVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStatics2_Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerStatics2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ICalendarDatePickerStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStatics3_Impl: Sized {
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarDatePickerStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarDatePickerStatics3_Vtbl {
        unsafe extern "system" fn DescriptionProperty<Impl: ICalendarDatePickerStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarDatePickerStatics3, BASE_OFFSET>(),
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarDatePickerStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Globalization", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ICalendarView_Impl: Sized {
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn DayOfWeekFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayOfWeekFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsGroupLabelVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsGroupLabelVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<CalendarViewDisplayMode>;
    fn SetDisplayMode(&mut self, value: CalendarViewDisplayMode) -> ::windows::core::Result<()>;
    fn FirstDayOfWeek(&mut self) -> ::windows::core::Result<super::super::super::Globalization::DayOfWeek>;
    fn SetFirstDayOfWeek(&mut self, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::Result<()>;
    fn IsOutOfScopeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOutOfScopeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsTodayHighlighted(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTodayHighlighted(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MinDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn NumberOfWeeksInView(&mut self) -> ::windows::core::Result<i32>;
    fn SetNumberOfWeeksInView(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedDates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::DateTime>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<CalendarViewSelectionMode>;
    fn SetSelectionMode(&mut self, value: CalendarViewSelectionMode) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::CalendarViewTemplateSettings>;
    fn FocusBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetFocusBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedHoverBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedHoverBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedPressedBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedPressedBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HoverBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHoverBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PressedBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPressedBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PressedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPressedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DayItemFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetDayItemFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn DayItemFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetDayItemFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn DayItemFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetDayItemFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn DayItemFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetDayItemFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn TodayFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetTodayFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFirstOfMonthLabelFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFirstOfMonthLabelFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFirstOfMonthLabelFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFirstOfMonthLabelFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn MonthYearItemFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetMonthYearItemFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn MonthYearItemFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetMonthYearItemFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MonthYearItemFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetMonthYearItemFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn MonthYearItemFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetMonthYearItemFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFirstOfYearDecadeLabelFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFirstOfYearDecadeLabelFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFirstOfYearDecadeLabelFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFirstOfYearDecadeLabelFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn HorizontalDayItemAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalDayItemAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalDayItemAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalDayItemAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn HorizontalFirstOfMonthLabelAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalFirstOfMonthLabelAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalFirstOfMonthLabelAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalFirstOfMonthLabelAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn CalendarItemBorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetCalendarItemBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCalendarViewDayItemStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCalendarViewDayItemChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectedDatesChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedDatesChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDisplayDate(&mut self, date: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn SetYearDecadeDisplayDimensions(&mut self, columns: i32, rows: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Globalization", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarView";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Globalization", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ICalendarView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarView_Vtbl {
        unsafe extern "system" fn CalendarIdentifier<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayOfWeekFormat<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayOfWeekFormat<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayOfWeekFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGroupLabelVisible<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroupLabelVisible<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsGroupLabelVisible(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn FirstDayOfWeek<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstDayOfWeek<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstDayOfWeek(value).into()
        }
        unsafe extern "system" fn IsOutOfScopeEnabled<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOutOfScopeEnabled<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOutOfScopeEnabled(value).into()
        }
        unsafe extern "system" fn IsTodayHighlighted<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTodayHighlighted<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTodayHighlighted(value).into()
        }
        unsafe extern "system" fn MaxDate<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDate<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinDate<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinDate<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NumberOfWeeksInView<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumberOfWeeksInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNumberOfWeeksInView<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNumberOfWeeksInView(value).into()
        }
        unsafe extern "system" fn SelectedDates<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CalendarViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocusBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedHoverBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedHoverBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedHoverBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedPressedBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedPressedBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedPressedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HoverBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HoverBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHoverBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHoverBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PressedBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPressedBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPressedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBorderBrush<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeBackground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeBackground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemBackground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBackground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PressedForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPressedForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlackoutForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemForeground<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontSize(value).into()
        }
        unsafe extern "system" fn DayItemFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontStyle(value).into()
        }
        unsafe extern "system" fn DayItemFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontSize(value).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontStyle(value).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontSize(value).into()
        }
        unsafe extern "system" fn MonthYearItemFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontStyle(value).into()
        }
        unsafe extern "system" fn MonthYearItemFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontFamily<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontSize<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontSize(value).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontStyle(value).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontWeight<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalDayItemAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalDayItemAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalDayItemAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalDayItemAlignment(value).into()
        }
        unsafe extern "system" fn VerticalDayItemAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalDayItemAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalDayItemAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalDayItemAlignment(value).into()
        }
        unsafe extern "system" fn HorizontalFirstOfMonthLabelAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalFirstOfMonthLabelAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalFirstOfMonthLabelAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalFirstOfMonthLabelAlignment(value).into()
        }
        unsafe extern "system" fn VerticalFirstOfMonthLabelAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalFirstOfMonthLabelAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalFirstOfMonthLabelAlignment<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalFirstOfMonthLabelAlignment(value).into()
        }
        unsafe extern "system" fn CalendarItemBorderThickness<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBorderThickness<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewDayItemStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarViewDayItemStyle<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarViewDayItemStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewDayItemChanging<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCalendarViewDayItemChanging<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCalendarViewDayItemChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDatesChanged<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDatesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedDatesChanged<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectedDatesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDisplayDate<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, date: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayDate(&*(&date as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetYearDecadeDisplayDimensions<Impl: ICalendarView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, columns: i32, rows: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearDecadeDisplayDimensions(columns, rows).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarView, BASE_OFFSET>(),
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            DayOfWeekFormat: DayOfWeekFormat::<Impl, IMPL_OFFSET>,
            SetDayOfWeekFormat: SetDayOfWeekFormat::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisible: IsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            SetIsGroupLabelVisible: SetIsGroupLabelVisible::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            SetDisplayMode: SetDisplayMode::<Impl, IMPL_OFFSET>,
            FirstDayOfWeek: FirstDayOfWeek::<Impl, IMPL_OFFSET>,
            SetFirstDayOfWeek: SetFirstDayOfWeek::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabled: IsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            SetIsOutOfScopeEnabled: SetIsOutOfScopeEnabled::<Impl, IMPL_OFFSET>,
            IsTodayHighlighted: IsTodayHighlighted::<Impl, IMPL_OFFSET>,
            SetIsTodayHighlighted: SetIsTodayHighlighted::<Impl, IMPL_OFFSET>,
            MaxDate: MaxDate::<Impl, IMPL_OFFSET>,
            SetMaxDate: SetMaxDate::<Impl, IMPL_OFFSET>,
            MinDate: MinDate::<Impl, IMPL_OFFSET>,
            SetMinDate: SetMinDate::<Impl, IMPL_OFFSET>,
            NumberOfWeeksInView: NumberOfWeeksInView::<Impl, IMPL_OFFSET>,
            SetNumberOfWeeksInView: SetNumberOfWeeksInView::<Impl, IMPL_OFFSET>,
            SelectedDates: SelectedDates::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            FocusBorderBrush: FocusBorderBrush::<Impl, IMPL_OFFSET>,
            SetFocusBorderBrush: SetFocusBorderBrush::<Impl, IMPL_OFFSET>,
            SelectedHoverBorderBrush: SelectedHoverBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedHoverBorderBrush: SetSelectedHoverBorderBrush::<Impl, IMPL_OFFSET>,
            SelectedPressedBorderBrush: SelectedPressedBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedPressedBorderBrush: SetSelectedPressedBorderBrush::<Impl, IMPL_OFFSET>,
            SelectedBorderBrush: SelectedBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedBorderBrush: SetSelectedBorderBrush::<Impl, IMPL_OFFSET>,
            HoverBorderBrush: HoverBorderBrush::<Impl, IMPL_OFFSET>,
            SetHoverBorderBrush: SetHoverBorderBrush::<Impl, IMPL_OFFSET>,
            PressedBorderBrush: PressedBorderBrush::<Impl, IMPL_OFFSET>,
            SetPressedBorderBrush: SetPressedBorderBrush::<Impl, IMPL_OFFSET>,
            CalendarItemBorderBrush: CalendarItemBorderBrush::<Impl, IMPL_OFFSET>,
            SetCalendarItemBorderBrush: SetCalendarItemBorderBrush::<Impl, IMPL_OFFSET>,
            OutOfScopeBackground: OutOfScopeBackground::<Impl, IMPL_OFFSET>,
            SetOutOfScopeBackground: SetOutOfScopeBackground::<Impl, IMPL_OFFSET>,
            CalendarItemBackground: CalendarItemBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemBackground: SetCalendarItemBackground::<Impl, IMPL_OFFSET>,
            PressedForeground: PressedForeground::<Impl, IMPL_OFFSET>,
            SetPressedForeground: SetPressedForeground::<Impl, IMPL_OFFSET>,
            TodayForeground: TodayForeground::<Impl, IMPL_OFFSET>,
            SetTodayForeground: SetTodayForeground::<Impl, IMPL_OFFSET>,
            BlackoutForeground: BlackoutForeground::<Impl, IMPL_OFFSET>,
            SetBlackoutForeground: SetBlackoutForeground::<Impl, IMPL_OFFSET>,
            SelectedForeground: SelectedForeground::<Impl, IMPL_OFFSET>,
            SetSelectedForeground: SetSelectedForeground::<Impl, IMPL_OFFSET>,
            OutOfScopeForeground: OutOfScopeForeground::<Impl, IMPL_OFFSET>,
            SetOutOfScopeForeground: SetOutOfScopeForeground::<Impl, IMPL_OFFSET>,
            CalendarItemForeground: CalendarItemForeground::<Impl, IMPL_OFFSET>,
            SetCalendarItemForeground: SetCalendarItemForeground::<Impl, IMPL_OFFSET>,
            DayItemFontFamily: DayItemFontFamily::<Impl, IMPL_OFFSET>,
            SetDayItemFontFamily: SetDayItemFontFamily::<Impl, IMPL_OFFSET>,
            DayItemFontSize: DayItemFontSize::<Impl, IMPL_OFFSET>,
            SetDayItemFontSize: SetDayItemFontSize::<Impl, IMPL_OFFSET>,
            DayItemFontStyle: DayItemFontStyle::<Impl, IMPL_OFFSET>,
            SetDayItemFontStyle: SetDayItemFontStyle::<Impl, IMPL_OFFSET>,
            DayItemFontWeight: DayItemFontWeight::<Impl, IMPL_OFFSET>,
            SetDayItemFontWeight: SetDayItemFontWeight::<Impl, IMPL_OFFSET>,
            TodayFontWeight: TodayFontWeight::<Impl, IMPL_OFFSET>,
            SetTodayFontWeight: SetTodayFontWeight::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontFamily: FirstOfMonthLabelFontFamily::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontFamily: SetFirstOfMonthLabelFontFamily::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontSize: FirstOfMonthLabelFontSize::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontSize: SetFirstOfMonthLabelFontSize::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontStyle: FirstOfMonthLabelFontStyle::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontStyle: SetFirstOfMonthLabelFontStyle::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontWeight: FirstOfMonthLabelFontWeight::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelFontWeight: SetFirstOfMonthLabelFontWeight::<Impl, IMPL_OFFSET>,
            MonthYearItemFontFamily: MonthYearItemFontFamily::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontFamily: SetMonthYearItemFontFamily::<Impl, IMPL_OFFSET>,
            MonthYearItemFontSize: MonthYearItemFontSize::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontSize: SetMonthYearItemFontSize::<Impl, IMPL_OFFSET>,
            MonthYearItemFontStyle: MonthYearItemFontStyle::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontStyle: SetMonthYearItemFontStyle::<Impl, IMPL_OFFSET>,
            MonthYearItemFontWeight: MonthYearItemFontWeight::<Impl, IMPL_OFFSET>,
            SetMonthYearItemFontWeight: SetMonthYearItemFontWeight::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontFamily: FirstOfYearDecadeLabelFontFamily::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontFamily: SetFirstOfYearDecadeLabelFontFamily::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontSize: FirstOfYearDecadeLabelFontSize::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontSize: SetFirstOfYearDecadeLabelFontSize::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontStyle: FirstOfYearDecadeLabelFontStyle::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontStyle: SetFirstOfYearDecadeLabelFontStyle::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontWeight: FirstOfYearDecadeLabelFontWeight::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelFontWeight: SetFirstOfYearDecadeLabelFontWeight::<Impl, IMPL_OFFSET>,
            HorizontalDayItemAlignment: HorizontalDayItemAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalDayItemAlignment: SetHorizontalDayItemAlignment::<Impl, IMPL_OFFSET>,
            VerticalDayItemAlignment: VerticalDayItemAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalDayItemAlignment: SetVerticalDayItemAlignment::<Impl, IMPL_OFFSET>,
            HorizontalFirstOfMonthLabelAlignment: HorizontalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalFirstOfMonthLabelAlignment: SetHorizontalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            VerticalFirstOfMonthLabelAlignment: VerticalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalFirstOfMonthLabelAlignment: SetVerticalFirstOfMonthLabelAlignment::<Impl, IMPL_OFFSET>,
            CalendarItemBorderThickness: CalendarItemBorderThickness::<Impl, IMPL_OFFSET>,
            SetCalendarItemBorderThickness: SetCalendarItemBorderThickness::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemStyle: CalendarViewDayItemStyle::<Impl, IMPL_OFFSET>,
            SetCalendarViewDayItemStyle: SetCalendarViewDayItemStyle::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemChanging: CalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            RemoveCalendarViewDayItemChanging: RemoveCalendarViewDayItemChanging::<Impl, IMPL_OFFSET>,
            SelectedDatesChanged: SelectedDatesChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectedDatesChanged: RemoveSelectedDatesChanged::<Impl, IMPL_OFFSET>,
            SetDisplayDate: SetDisplayDate::<Impl, IMPL_OFFSET>,
            SetYearDecadeDisplayDimensions: SetYearDecadeDisplayDimensions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ICalendarView2_Impl: Sized {
    fn SelectedDisabledBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedDisabledBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodaySelectedInnerBorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodaySelectedInnerBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutStrikethroughBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutStrikethroughBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemHoverBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemHoverBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemPressedBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemPressedBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemDisabledBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemDisabledBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBlackoutBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBlackoutBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayHoverBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayHoverBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayPressedBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayPressedBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayDisabledBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayDisabledBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBlackoutForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBlackoutForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedHoverForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedHoverForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedPressedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedPressedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedDisabledForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedDisabledForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeHoverForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeHoverForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopePressedForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopePressedForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DisabledForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetDisabledForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DayItemMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetDayItemMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn MonthYearItemMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetMonthYearItemMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetFirstOfMonthLabelMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelMargin(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetFirstOfYearDecadeLabelMargin(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CalendarItemCornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCalendarItemCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarView2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ICalendarView2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarView2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarView2_Vtbl {
        unsafe extern "system" fn SelectedDisabledBorderBrush<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDisabledBorderBrush<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedDisabledBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodaySelectedInnerBorderBrush<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodaySelectedInnerBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodaySelectedInnerBorderBrush<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodaySelectedInnerBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutStrikethroughBrush<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutStrikethroughBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutStrikethroughBrush<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlackoutStrikethroughBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlackoutBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemHoverBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemHoverBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemHoverBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemHoverBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemPressedBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemPressedBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemPressedBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemPressedBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemDisabledBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemDisabledBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemDisabledBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemDisabledBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBlackoutBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBlackoutBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayBlackoutBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayHoverBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayHoverBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayHoverBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayHoverBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayPressedBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayPressedBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayPressedBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayPressedBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayDisabledBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayDisabledBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayDisabledBackground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayDisabledBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBlackoutForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBlackoutForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTodayBlackoutForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedHoverForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedHoverForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedHoverForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedPressedForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedPressedForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedPressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDisabledForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDisabledForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedDisabledForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeHoverForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeHoverForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeHoverForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeHoverForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopePressedForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopePressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopePressedForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutOfScopePressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisabledForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledForeground<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayItemMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelMargin<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemCornerRadius<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemCornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemCornerRadius<Impl: ICalendarView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarItemCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarView2, BASE_OFFSET>(),
            SelectedDisabledBorderBrush: SelectedDisabledBorderBrush::<Impl, IMPL_OFFSET>,
            SetSelectedDisabledBorderBrush: SetSelectedDisabledBorderBrush::<Impl, IMPL_OFFSET>,
            TodaySelectedInnerBorderBrush: TodaySelectedInnerBorderBrush::<Impl, IMPL_OFFSET>,
            SetTodaySelectedInnerBorderBrush: SetTodaySelectedInnerBorderBrush::<Impl, IMPL_OFFSET>,
            BlackoutStrikethroughBrush: BlackoutStrikethroughBrush::<Impl, IMPL_OFFSET>,
            SetBlackoutStrikethroughBrush: SetBlackoutStrikethroughBrush::<Impl, IMPL_OFFSET>,
            BlackoutBackground: BlackoutBackground::<Impl, IMPL_OFFSET>,
            SetBlackoutBackground: SetBlackoutBackground::<Impl, IMPL_OFFSET>,
            CalendarItemHoverBackground: CalendarItemHoverBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemHoverBackground: SetCalendarItemHoverBackground::<Impl, IMPL_OFFSET>,
            CalendarItemPressedBackground: CalendarItemPressedBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemPressedBackground: SetCalendarItemPressedBackground::<Impl, IMPL_OFFSET>,
            CalendarItemDisabledBackground: CalendarItemDisabledBackground::<Impl, IMPL_OFFSET>,
            SetCalendarItemDisabledBackground: SetCalendarItemDisabledBackground::<Impl, IMPL_OFFSET>,
            TodayBackground: TodayBackground::<Impl, IMPL_OFFSET>,
            SetTodayBackground: SetTodayBackground::<Impl, IMPL_OFFSET>,
            TodayBlackoutBackground: TodayBlackoutBackground::<Impl, IMPL_OFFSET>,
            SetTodayBlackoutBackground: SetTodayBlackoutBackground::<Impl, IMPL_OFFSET>,
            TodayHoverBackground: TodayHoverBackground::<Impl, IMPL_OFFSET>,
            SetTodayHoverBackground: SetTodayHoverBackground::<Impl, IMPL_OFFSET>,
            TodayPressedBackground: TodayPressedBackground::<Impl, IMPL_OFFSET>,
            SetTodayPressedBackground: SetTodayPressedBackground::<Impl, IMPL_OFFSET>,
            TodayDisabledBackground: TodayDisabledBackground::<Impl, IMPL_OFFSET>,
            SetTodayDisabledBackground: SetTodayDisabledBackground::<Impl, IMPL_OFFSET>,
            TodayBlackoutForeground: TodayBlackoutForeground::<Impl, IMPL_OFFSET>,
            SetTodayBlackoutForeground: SetTodayBlackoutForeground::<Impl, IMPL_OFFSET>,
            SelectedHoverForeground: SelectedHoverForeground::<Impl, IMPL_OFFSET>,
            SetSelectedHoverForeground: SetSelectedHoverForeground::<Impl, IMPL_OFFSET>,
            SelectedPressedForeground: SelectedPressedForeground::<Impl, IMPL_OFFSET>,
            SetSelectedPressedForeground: SetSelectedPressedForeground::<Impl, IMPL_OFFSET>,
            SelectedDisabledForeground: SelectedDisabledForeground::<Impl, IMPL_OFFSET>,
            SetSelectedDisabledForeground: SetSelectedDisabledForeground::<Impl, IMPL_OFFSET>,
            OutOfScopeHoverForeground: OutOfScopeHoverForeground::<Impl, IMPL_OFFSET>,
            SetOutOfScopeHoverForeground: SetOutOfScopeHoverForeground::<Impl, IMPL_OFFSET>,
            OutOfScopePressedForeground: OutOfScopePressedForeground::<Impl, IMPL_OFFSET>,
            SetOutOfScopePressedForeground: SetOutOfScopePressedForeground::<Impl, IMPL_OFFSET>,
            DisabledForeground: DisabledForeground::<Impl, IMPL_OFFSET>,
            SetDisabledForeground: SetDisabledForeground::<Impl, IMPL_OFFSET>,
            DayItemMargin: DayItemMargin::<Impl, IMPL_OFFSET>,
            SetDayItemMargin: SetDayItemMargin::<Impl, IMPL_OFFSET>,
            MonthYearItemMargin: MonthYearItemMargin::<Impl, IMPL_OFFSET>,
            SetMonthYearItemMargin: SetMonthYearItemMargin::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelMargin: FirstOfMonthLabelMargin::<Impl, IMPL_OFFSET>,
            SetFirstOfMonthLabelMargin: SetFirstOfMonthLabelMargin::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelMargin: FirstOfYearDecadeLabelMargin::<Impl, IMPL_OFFSET>,
            SetFirstOfYearDecadeLabelMargin: SetFirstOfYearDecadeLabelMargin::<Impl, IMPL_OFFSET>,
            CalendarItemCornerRadius: CalendarItemCornerRadius::<Impl, IMPL_OFFSET>,
            SetCalendarItemCornerRadius: SetCalendarItemCornerRadius::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICalendarViewDayItem_Impl: Sized {
    fn IsBlackout(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsBlackout(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDensityColors(&mut self, colors: &::core::option::Option<super::super::super::Foundation::Collections::IIterable<super::super::Color>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarViewDayItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItem";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICalendarViewDayItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItem_Vtbl {
        unsafe extern "system" fn IsBlackout<Impl: ICalendarViewDayItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBlackout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBlackout<Impl: ICalendarViewDayItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsBlackout(value).into()
        }
        unsafe extern "system" fn Date<Impl: ICalendarViewDayItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDensityColors<Impl: ICalendarViewDayItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, colors: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDensityColors(&*(&colors as *const <super::super::super::Foundation::Collections::IIterable<super::super::Color> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IIterable<super::super::Color> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItem, BASE_OFFSET>(),
            IsBlackout: IsBlackout::<Impl, IMPL_OFFSET>,
            SetIsBlackout: SetIsBlackout::<Impl, IMPL_OFFSET>,
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDensityColors: SetDensityColors::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItem as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICalendarViewDayItemChangingEventArgs_Impl: Sized {
    fn InRecycleQueue(&mut self) -> ::windows::core::Result<bool>;
    fn Item(&mut self) -> ::windows::core::Result<CalendarViewDayItem>;
    fn Phase(&mut self) -> ::windows::core::Result<u32>;
    fn RegisterUpdateCallback(&mut self, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallbackWithPhase(&mut self, callbackphase: u32, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarViewDayItemChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemChangingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICalendarViewDayItemChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItemChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItemChangingEventArgs_Vtbl {
        unsafe extern "system" fn InRecycleQueue<Impl: ICalendarViewDayItemChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InRecycleQueue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: ICalendarViewDayItemChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Phase<Impl: ICalendarViewDayItemChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Phase() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterUpdateCallback<Impl: ICalendarViewDayItemChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallback(&*(&callback as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RegisterUpdateCallbackWithPhase<Impl: ICalendarViewDayItemChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callbackphase: u32, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallbackWithPhase(callbackphase, &*(&callback as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItemChangingEventArgs, BASE_OFFSET>(),
            InRecycleQueue: InRecycleQueue::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Phase: Phase::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallback: RegisterUpdateCallback::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallbackWithPhase: RegisterUpdateCallbackWithPhase::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItemChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarViewDayItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarViewDayItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemStatics_Impl: Sized {
    fn IsBlackoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewDayItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewDayItemStatics_Vtbl {
        unsafe extern "system" fn IsBlackoutProperty<Impl: ICalendarViewDayItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBlackoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: ICalendarViewDayItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewDayItemStatics, BASE_OFFSET>(),
            IsBlackoutProperty: IsBlackoutProperty::<Impl, IMPL_OFFSET>,
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewDayItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICalendarViewSelectedDatesChangedEventArgs_Impl: Sized {
    fn AddedDates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::super::super::Foundation::DateTime>>;
    fn RemovedDates(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::super::super::Foundation::DateTime>>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICalendarViewSelectedDatesChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewSelectedDatesChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICalendarViewSelectedDatesChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewSelectedDatesChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewSelectedDatesChangedEventArgs_Vtbl {
        unsafe extern "system" fn AddedDates<Impl: ICalendarViewSelectedDatesChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedDates<Impl: ICalendarViewSelectedDatesChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewSelectedDatesChangedEventArgs, BASE_OFFSET>(),
            AddedDates: AddedDates::<Impl, IMPL_OFFSET>,
            RemovedDates: RemovedDates::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewSelectedDatesChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewStatics_Impl: Sized {
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayOfWeekFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupLabelVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstDayOfWeekProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOutOfScopeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTodayHighlightedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NumberOfWeeksInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedDatesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedHoverBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedPressedBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HoverBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PressedBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PressedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalDayItemAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalDayItemAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalFirstOfMonthLabelAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalFirstOfMonthLabelAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarViewDayItemStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewStatics_Vtbl {
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayOfWeekFormatProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupLabelVisibleProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstDayOfWeekProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOutOfScopeEnabledProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTodayHighlightedProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlightedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDateProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinDateProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumberOfWeeksInViewProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumberOfWeeksInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedDatesProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDatesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionModeProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusBorderBrushProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedHoverBorderBrushProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedPressedBorderBrushProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBorderBrushProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HoverBorderBrushProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HoverBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PressedBorderBrushProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBorderBrushProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeBackgroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBackgroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PressedForegroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayForegroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutForegroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedForegroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeForegroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemForegroundProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontFamilyProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontSizeProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontStyleProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontWeightProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayFontWeightProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontFamilyProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontSizeProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontStyleProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontWeightProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontFamilyProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontSizeProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontStyleProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontWeightProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontFamilyProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontSizeProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontStyleProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontWeightProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalDayItemAlignmentProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalDayItemAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalDayItemAlignmentProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalDayItemAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalFirstOfMonthLabelAlignmentProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalFirstOfMonthLabelAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalFirstOfMonthLabelAlignmentProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalFirstOfMonthLabelAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBorderThicknessProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarViewDayItemStyleProperty<Impl: ICalendarViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewStatics, BASE_OFFSET>(),
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            DayOfWeekFormatProperty: DayOfWeekFormatProperty::<Impl, IMPL_OFFSET>,
            IsGroupLabelVisibleProperty: IsGroupLabelVisibleProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            FirstDayOfWeekProperty: FirstDayOfWeekProperty::<Impl, IMPL_OFFSET>,
            IsOutOfScopeEnabledProperty: IsOutOfScopeEnabledProperty::<Impl, IMPL_OFFSET>,
            IsTodayHighlightedProperty: IsTodayHighlightedProperty::<Impl, IMPL_OFFSET>,
            MaxDateProperty: MaxDateProperty::<Impl, IMPL_OFFSET>,
            MinDateProperty: MinDateProperty::<Impl, IMPL_OFFSET>,
            NumberOfWeeksInViewProperty: NumberOfWeeksInViewProperty::<Impl, IMPL_OFFSET>,
            SelectedDatesProperty: SelectedDatesProperty::<Impl, IMPL_OFFSET>,
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
            TemplateSettingsProperty: TemplateSettingsProperty::<Impl, IMPL_OFFSET>,
            FocusBorderBrushProperty: FocusBorderBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedHoverBorderBrushProperty: SelectedHoverBorderBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedPressedBorderBrushProperty: SelectedPressedBorderBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedBorderBrushProperty: SelectedBorderBrushProperty::<Impl, IMPL_OFFSET>,
            HoverBorderBrushProperty: HoverBorderBrushProperty::<Impl, IMPL_OFFSET>,
            PressedBorderBrushProperty: PressedBorderBrushProperty::<Impl, IMPL_OFFSET>,
            CalendarItemBorderBrushProperty: CalendarItemBorderBrushProperty::<Impl, IMPL_OFFSET>,
            OutOfScopeBackgroundProperty: OutOfScopeBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemBackgroundProperty: CalendarItemBackgroundProperty::<Impl, IMPL_OFFSET>,
            PressedForegroundProperty: PressedForegroundProperty::<Impl, IMPL_OFFSET>,
            TodayForegroundProperty: TodayForegroundProperty::<Impl, IMPL_OFFSET>,
            BlackoutForegroundProperty: BlackoutForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedForegroundProperty: SelectedForegroundProperty::<Impl, IMPL_OFFSET>,
            OutOfScopeForegroundProperty: OutOfScopeForegroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemForegroundProperty: CalendarItemForegroundProperty::<Impl, IMPL_OFFSET>,
            DayItemFontFamilyProperty: DayItemFontFamilyProperty::<Impl, IMPL_OFFSET>,
            DayItemFontSizeProperty: DayItemFontSizeProperty::<Impl, IMPL_OFFSET>,
            DayItemFontStyleProperty: DayItemFontStyleProperty::<Impl, IMPL_OFFSET>,
            DayItemFontWeightProperty: DayItemFontWeightProperty::<Impl, IMPL_OFFSET>,
            TodayFontWeightProperty: TodayFontWeightProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontFamilyProperty: FirstOfMonthLabelFontFamilyProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontSizeProperty: FirstOfMonthLabelFontSizeProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontStyleProperty: FirstOfMonthLabelFontStyleProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelFontWeightProperty: FirstOfMonthLabelFontWeightProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontFamilyProperty: MonthYearItemFontFamilyProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontSizeProperty: MonthYearItemFontSizeProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontStyleProperty: MonthYearItemFontStyleProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemFontWeightProperty: MonthYearItemFontWeightProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontFamilyProperty: FirstOfYearDecadeLabelFontFamilyProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontSizeProperty: FirstOfYearDecadeLabelFontSizeProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontStyleProperty: FirstOfYearDecadeLabelFontStyleProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelFontWeightProperty: FirstOfYearDecadeLabelFontWeightProperty::<Impl, IMPL_OFFSET>,
            HorizontalDayItemAlignmentProperty: HorizontalDayItemAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalDayItemAlignmentProperty: VerticalDayItemAlignmentProperty::<Impl, IMPL_OFFSET>,
            HorizontalFirstOfMonthLabelAlignmentProperty: HorizontalFirstOfMonthLabelAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalFirstOfMonthLabelAlignmentProperty: VerticalFirstOfMonthLabelAlignmentProperty::<Impl, IMPL_OFFSET>,
            CalendarItemBorderThicknessProperty: CalendarItemBorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CalendarViewDayItemStyleProperty: CalendarViewDayItemStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewStatics2_Impl: Sized {
    fn SelectedDisabledBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodaySelectedInnerBorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutStrikethroughBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemHoverBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemPressedBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemDisabledBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBlackoutBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayHoverBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayPressedBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayDisabledBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBlackoutForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedHoverForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedPressedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedDisabledForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeHoverForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopePressedForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisabledForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelMarginProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemCornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICalendarViewStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICalendarViewStatics2_Vtbl {
        unsafe extern "system" fn SelectedDisabledBorderBrushProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodaySelectedInnerBorderBrushProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodaySelectedInnerBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutStrikethroughBrushProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutStrikethroughBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlackoutBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemHoverBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemHoverBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemPressedBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemPressedBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemDisabledBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemDisabledBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBlackoutBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayHoverBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayHoverBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayPressedBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayPressedBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayDisabledBackgroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayDisabledBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBlackoutForegroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedHoverForegroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedHoverForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedPressedForegroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedPressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedDisabledForegroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeHoverForegroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopeHoverForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopePressedForegroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutOfScopePressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisabledForegroundProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemMarginProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayItemMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemMarginProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthYearItemMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelMarginProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelMarginProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemCornerRadiusProperty<Impl: ICalendarViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarItemCornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICalendarViewStatics2, BASE_OFFSET>(),
            SelectedDisabledBorderBrushProperty: SelectedDisabledBorderBrushProperty::<Impl, IMPL_OFFSET>,
            TodaySelectedInnerBorderBrushProperty: TodaySelectedInnerBorderBrushProperty::<Impl, IMPL_OFFSET>,
            BlackoutStrikethroughBrushProperty: BlackoutStrikethroughBrushProperty::<Impl, IMPL_OFFSET>,
            BlackoutBackgroundProperty: BlackoutBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemHoverBackgroundProperty: CalendarItemHoverBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemPressedBackgroundProperty: CalendarItemPressedBackgroundProperty::<Impl, IMPL_OFFSET>,
            CalendarItemDisabledBackgroundProperty: CalendarItemDisabledBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayBackgroundProperty: TodayBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayBlackoutBackgroundProperty: TodayBlackoutBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayHoverBackgroundProperty: TodayHoverBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayPressedBackgroundProperty: TodayPressedBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayDisabledBackgroundProperty: TodayDisabledBackgroundProperty::<Impl, IMPL_OFFSET>,
            TodayBlackoutForegroundProperty: TodayBlackoutForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedHoverForegroundProperty: SelectedHoverForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedPressedForegroundProperty: SelectedPressedForegroundProperty::<Impl, IMPL_OFFSET>,
            SelectedDisabledForegroundProperty: SelectedDisabledForegroundProperty::<Impl, IMPL_OFFSET>,
            OutOfScopeHoverForegroundProperty: OutOfScopeHoverForegroundProperty::<Impl, IMPL_OFFSET>,
            OutOfScopePressedForegroundProperty: OutOfScopePressedForegroundProperty::<Impl, IMPL_OFFSET>,
            DisabledForegroundProperty: DisabledForegroundProperty::<Impl, IMPL_OFFSET>,
            DayItemMarginProperty: DayItemMarginProperty::<Impl, IMPL_OFFSET>,
            MonthYearItemMarginProperty: MonthYearItemMarginProperty::<Impl, IMPL_OFFSET>,
            FirstOfMonthLabelMarginProperty: FirstOfMonthLabelMarginProperty::<Impl, IMPL_OFFSET>,
            FirstOfYearDecadeLabelMarginProperty: FirstOfYearDecadeLabelMarginProperty::<Impl, IMPL_OFFSET>,
            CalendarItemCornerRadiusProperty: CalendarItemCornerRadiusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICalendarViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICandidateWindowBoundsChangedEventArgs_Impl: Sized {
    fn Bounds(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICandidateWindowBoundsChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICandidateWindowBoundsChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICandidateWindowBoundsChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICandidateWindowBoundsChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICandidateWindowBoundsChangedEventArgs_Vtbl {
        unsafe extern "system" fn Bounds<Impl: ICandidateWindowBoundsChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Bounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICandidateWindowBoundsChangedEventArgs, BASE_OFFSET>(),
            Bounds: Bounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICandidateWindowBoundsChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvas_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvas {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvas";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvas_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICanvas_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICanvas_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICanvas, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICanvas as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Canvas>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvasFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvasFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICanvasFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICanvasFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICanvasFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICanvasFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICanvasFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasStatics_Impl: Sized {
    fn LeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetLeft(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<f64>;
    fn SetLeft(&mut self, element: &::core::option::Option<super::UIElement>, length: f64) -> ::windows::core::Result<()>;
    fn TopProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetTop(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<f64>;
    fn SetTop(&mut self, element: &::core::option::Option<super::UIElement>, length: f64) -> ::windows::core::Result<()>;
    fn ZIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetZIndex(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetZIndex(&mut self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvasStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvasStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICanvasStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICanvasStatics_Vtbl {
        unsafe extern "system" fn LeftProperty<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeft<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLeft(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeft<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, length: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeft(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), length).into()
        }
        unsafe extern "system" fn TopProperty<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTop<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTop(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTop<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, length: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTop(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), length).into()
        }
        unsafe extern "system" fn ZIndexProperty<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZIndex<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetZIndex(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZIndex<Impl: ICanvasStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZIndex(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICanvasStatics, BASE_OFFSET>(),
            LeftProperty: LeftProperty::<Impl, IMPL_OFFSET>,
            GetLeft: GetLeft::<Impl, IMPL_OFFSET>,
            SetLeft: SetLeft::<Impl, IMPL_OFFSET>,
            TopProperty: TopProperty::<Impl, IMPL_OFFSET>,
            GetTop: GetTop::<Impl, IMPL_OFFSET>,
            SetTop: SetTop::<Impl, IMPL_OFFSET>,
            ZIndexProperty: ZIndexProperty::<Impl, IMPL_OFFSET>,
            GetZIndex: GetZIndex::<Impl, IMPL_OFFSET>,
            SetZIndex: SetZIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICanvasStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Capture", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ICaptureElement_Impl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Media::Capture::MediaCapture>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Media::Capture::MediaCapture>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Media_Capture", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICaptureElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICaptureElement";
}
#[cfg(all(feature = "Media_Capture", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ICaptureElement_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICaptureElement_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICaptureElement_Vtbl {
        unsafe extern "system" fn Source<Impl: ICaptureElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: ICaptureElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Media::Capture::MediaCapture as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Capture::MediaCapture as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: ICaptureElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: ICaptureElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICaptureElement, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICaptureElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICaptureElementStatics_Impl: Sized {
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICaptureElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICaptureElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICaptureElementStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICaptureElementStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICaptureElementStatics_Vtbl {
        unsafe extern "system" fn SourceProperty<Impl: ICaptureElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: ICaptureElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICaptureElementStatics, BASE_OFFSET>(),
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICaptureElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICheckBox_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICheckBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICheckBox";
}
#[cfg(feature = "implement_exclusive")]
impl ICheckBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICheckBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICheckBox_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICheckBox, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICheckBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICheckBoxFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CheckBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICheckBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICheckBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICheckBoxFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICheckBoxFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICheckBoxFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICheckBoxFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICheckBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICheckBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IChoosingGroupHeaderContainerEventArgs_Impl: Sized {
    fn GroupHeaderContainer(&mut self) -> ::windows::core::Result<ListViewBaseHeaderItem>;
    fn SetGroupHeaderContainer(&mut self, value: &::core::option::Option<ListViewBaseHeaderItem>) -> ::windows::core::Result<()>;
    fn GroupIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Group(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IChoosingGroupHeaderContainerEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IChoosingGroupHeaderContainerEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IChoosingGroupHeaderContainerEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IChoosingGroupHeaderContainerEventArgs_Vtbl {
        unsafe extern "system" fn GroupHeaderContainer<Impl: IChoosingGroupHeaderContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderContainer<Impl: IChoosingGroupHeaderContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderContainer(&*(&value as *const <ListViewBaseHeaderItem as ::windows::core::Abi>::Abi as *const <ListViewBaseHeaderItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GroupIndex<Impl: IChoosingGroupHeaderContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Group<Impl: IChoosingGroupHeaderContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Group() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IChoosingGroupHeaderContainerEventArgs, BASE_OFFSET>(),
            GroupHeaderContainer: GroupHeaderContainer::<Impl, IMPL_OFFSET>,
            SetGroupHeaderContainer: SetGroupHeaderContainer::<Impl, IMPL_OFFSET>,
            GroupIndex: GroupIndex::<Impl, IMPL_OFFSET>,
            Group: Group::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IChoosingGroupHeaderContainerEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IChoosingItemContainerEventArgs_Impl: Sized {
    fn ItemIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ItemContainer(&mut self) -> ::windows::core::Result<Primitives::SelectorItem>;
    fn SetItemContainer(&mut self, value: &::core::option::Option<Primitives::SelectorItem>) -> ::windows::core::Result<()>;
    fn IsContainerPrepared(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsContainerPrepared(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IChoosingItemContainerEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IChoosingItemContainerEventArgs";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IChoosingItemContainerEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IChoosingItemContainerEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IChoosingItemContainerEventArgs_Vtbl {
        unsafe extern "system" fn ItemIndex<Impl: IChoosingItemContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IChoosingItemContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainer<Impl: IChoosingItemContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainer<Impl: IChoosingItemContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainer(&*(&value as *const <Primitives::SelectorItem as ::windows::core::Abi>::Abi as *const <Primitives::SelectorItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsContainerPrepared<Impl: IChoosingItemContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContainerPrepared() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsContainerPrepared<Impl: IChoosingItemContainerEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsContainerPrepared(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IChoosingItemContainerEventArgs, BASE_OFFSET>(),
            ItemIndex: ItemIndex::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            ItemContainer: ItemContainer::<Impl, IMPL_OFFSET>,
            SetItemContainer: SetItemContainer::<Impl, IMPL_OFFSET>,
            IsContainerPrepared: IsContainerPrepared::<Impl, IMPL_OFFSET>,
            SetIsContainerPrepared: SetIsContainerPrepared::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IChoosingItemContainerEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICleanUpVirtualizedItemEventArgs_Impl: Sized {
    fn Value(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn UIElement(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICleanUpVirtualizedItemEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICleanUpVirtualizedItemEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ICleanUpVirtualizedItemEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICleanUpVirtualizedItemEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICleanUpVirtualizedItemEventArgs_Vtbl {
        unsafe extern "system" fn Value<Impl: ICleanUpVirtualizedItemEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UIElement<Impl: ICleanUpVirtualizedItemEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UIElement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ICleanUpVirtualizedItemEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ICleanUpVirtualizedItemEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICleanUpVirtualizedItemEventArgs, BASE_OFFSET>(),
            Value: Value::<Impl, IMPL_OFFSET>,
            UIElement: UIElement::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICleanUpVirtualizedItemEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorChangedEventArgs_Impl: Sized {
    fn OldColor(&mut self) -> ::windows::core::Result<super::super::Color>;
    fn NewColor(&mut self) -> ::windows::core::Result<super::super::Color>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IColorChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorChangedEventArgs_Vtbl {
        unsafe extern "system" fn OldColor<Impl: IColorChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewColor<Impl: IColorChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorChangedEventArgs, BASE_OFFSET>(),
            OldColor: OldColor::<Impl, IMPL_OFFSET>,
            NewColor: NewColor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IColorPicker_Impl: Sized {
    fn Color(&mut self) -> ::windows::core::Result<super::super::Color>;
    fn SetColor(&mut self, value: &super::super::Color) -> ::windows::core::Result<()>;
    fn PreviousColor(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::Color>>;
    fn SetPreviousColor(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::Color>>) -> ::windows::core::Result<()>;
    fn IsAlphaEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorSpectrumVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorSpectrumVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorPreviewVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorPreviewVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorSliderVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorSliderVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsAlphaSliderVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaSliderVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsMoreButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsMoreButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorChannelTextInputVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorChannelTextInputVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsAlphaTextInputVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaTextInputVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsHexInputVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHexInputVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MinHue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinHue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxHue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxHue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MinSaturation(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinSaturation(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxSaturation(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxSaturation(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MinValue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinValue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxValue(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxValue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn ColorSpectrumShape(&mut self) -> ::windows::core::Result<ColorSpectrumShape>;
    fn SetColorSpectrumShape(&mut self, value: ColorSpectrumShape) -> ::windows::core::Result<()>;
    fn ColorSpectrumComponents(&mut self) -> ::windows::core::Result<ColorSpectrumComponents>;
    fn SetColorSpectrumComponents(&mut self, value: ColorSpectrumComponents) -> ::windows::core::Result<()>;
    fn ColorChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveColorChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IColorPicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPicker";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IColorPicker_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorPicker_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorPicker_Vtbl {
        unsafe extern "system" fn Color<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Color() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColor<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColor(&*(&value as *const <super::super::Color as ::windows::core::Abi>::Abi as *const <super::super::Color as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreviousColor<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreviousColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreviousColor<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreviousColor(&*(&value as *const <super::super::super::Foundation::IReference<super::super::Color> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::Color> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsAlphaEnabled<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaEnabled<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsAlphaEnabled(value).into()
        }
        unsafe extern "system" fn IsColorSpectrumVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSpectrumVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorSpectrumVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorSpectrumVisible(value).into()
        }
        unsafe extern "system" fn IsColorPreviewVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorPreviewVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorPreviewVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorPreviewVisible(value).into()
        }
        unsafe extern "system" fn IsColorSliderVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSliderVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorSliderVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorSliderVisible(value).into()
        }
        unsafe extern "system" fn IsAlphaSliderVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaSliderVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaSliderVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsAlphaSliderVisible(value).into()
        }
        unsafe extern "system" fn IsMoreButtonVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMoreButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMoreButtonVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsMoreButtonVisible(value).into()
        }
        unsafe extern "system" fn IsColorChannelTextInputVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorChannelTextInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorChannelTextInputVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorChannelTextInputVisible(value).into()
        }
        unsafe extern "system" fn IsAlphaTextInputVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaTextInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaTextInputVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsAlphaTextInputVisible(value).into()
        }
        unsafe extern "system" fn IsHexInputVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHexInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHexInputVisible<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHexInputVisible(value).into()
        }
        unsafe extern "system" fn MinHue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinHue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinHue(value).into()
        }
        unsafe extern "system" fn MaxHue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxHue(value).into()
        }
        unsafe extern "system" fn MinSaturation<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinSaturation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinSaturation<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinSaturation(value).into()
        }
        unsafe extern "system" fn MaxSaturation<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSaturation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSaturation<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxSaturation(value).into()
        }
        unsafe extern "system" fn MinValue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinValue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinValue(value).into()
        }
        unsafe extern "system" fn MaxValue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxValue<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxValue(value).into()
        }
        unsafe extern "system" fn ColorSpectrumShape<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ColorSpectrumShape) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumShape() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorSpectrumShape<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ColorSpectrumShape) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorSpectrumShape(value).into()
        }
        unsafe extern "system" fn ColorSpectrumComponents<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ColorSpectrumComponents) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumComponents() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorSpectrumComponents<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ColorSpectrumComponents) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorSpectrumComponents(value).into()
        }
        unsafe extern "system" fn ColorChanged<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveColorChanged<Impl: IColorPicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveColorChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorPicker, BASE_OFFSET>(),
            Color: Color::<Impl, IMPL_OFFSET>,
            SetColor: SetColor::<Impl, IMPL_OFFSET>,
            PreviousColor: PreviousColor::<Impl, IMPL_OFFSET>,
            SetPreviousColor: SetPreviousColor::<Impl, IMPL_OFFSET>,
            IsAlphaEnabled: IsAlphaEnabled::<Impl, IMPL_OFFSET>,
            SetIsAlphaEnabled: SetIsAlphaEnabled::<Impl, IMPL_OFFSET>,
            IsColorSpectrumVisible: IsColorSpectrumVisible::<Impl, IMPL_OFFSET>,
            SetIsColorSpectrumVisible: SetIsColorSpectrumVisible::<Impl, IMPL_OFFSET>,
            IsColorPreviewVisible: IsColorPreviewVisible::<Impl, IMPL_OFFSET>,
            SetIsColorPreviewVisible: SetIsColorPreviewVisible::<Impl, IMPL_OFFSET>,
            IsColorSliderVisible: IsColorSliderVisible::<Impl, IMPL_OFFSET>,
            SetIsColorSliderVisible: SetIsColorSliderVisible::<Impl, IMPL_OFFSET>,
            IsAlphaSliderVisible: IsAlphaSliderVisible::<Impl, IMPL_OFFSET>,
            SetIsAlphaSliderVisible: SetIsAlphaSliderVisible::<Impl, IMPL_OFFSET>,
            IsMoreButtonVisible: IsMoreButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsMoreButtonVisible: SetIsMoreButtonVisible::<Impl, IMPL_OFFSET>,
            IsColorChannelTextInputVisible: IsColorChannelTextInputVisible::<Impl, IMPL_OFFSET>,
            SetIsColorChannelTextInputVisible: SetIsColorChannelTextInputVisible::<Impl, IMPL_OFFSET>,
            IsAlphaTextInputVisible: IsAlphaTextInputVisible::<Impl, IMPL_OFFSET>,
            SetIsAlphaTextInputVisible: SetIsAlphaTextInputVisible::<Impl, IMPL_OFFSET>,
            IsHexInputVisible: IsHexInputVisible::<Impl, IMPL_OFFSET>,
            SetIsHexInputVisible: SetIsHexInputVisible::<Impl, IMPL_OFFSET>,
            MinHue: MinHue::<Impl, IMPL_OFFSET>,
            SetMinHue: SetMinHue::<Impl, IMPL_OFFSET>,
            MaxHue: MaxHue::<Impl, IMPL_OFFSET>,
            SetMaxHue: SetMaxHue::<Impl, IMPL_OFFSET>,
            MinSaturation: MinSaturation::<Impl, IMPL_OFFSET>,
            SetMinSaturation: SetMinSaturation::<Impl, IMPL_OFFSET>,
            MaxSaturation: MaxSaturation::<Impl, IMPL_OFFSET>,
            SetMaxSaturation: SetMaxSaturation::<Impl, IMPL_OFFSET>,
            MinValue: MinValue::<Impl, IMPL_OFFSET>,
            SetMinValue: SetMinValue::<Impl, IMPL_OFFSET>,
            MaxValue: MaxValue::<Impl, IMPL_OFFSET>,
            SetMaxValue: SetMaxValue::<Impl, IMPL_OFFSET>,
            ColorSpectrumShape: ColorSpectrumShape::<Impl, IMPL_OFFSET>,
            SetColorSpectrumShape: SetColorSpectrumShape::<Impl, IMPL_OFFSET>,
            ColorSpectrumComponents: ColorSpectrumComponents::<Impl, IMPL_OFFSET>,
            SetColorSpectrumComponents: SetColorSpectrumComponents::<Impl, IMPL_OFFSET>,
            ColorChanged: ColorChanged::<Impl, IMPL_OFFSET>,
            RemoveColorChanged: RemoveColorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorPicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorPickerFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ColorPicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorPickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IColorPickerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorPickerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorPickerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IColorPickerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorPickerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorPickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorPickerStatics_Impl: Sized {
    fn ColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreviousColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorSpectrumVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorPreviewVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorSliderVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaSliderVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsMoreButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorChannelTextInputVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaTextInputVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHexInputVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinHueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinSaturationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxSaturationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColorSpectrumShapeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColorSpectrumComponentsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorPickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IColorPickerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColorPickerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColorPickerStatics_Vtbl {
        unsafe extern "system" fn ColorProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreviousColorProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreviousColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaEnabledProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorSpectrumVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSpectrumVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorPreviewVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorPreviewVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorSliderVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorSliderVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaSliderVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaSliderVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMoreButtonVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMoreButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorChannelTextInputVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorChannelTextInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaTextInputVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAlphaTextInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHexInputVisibleProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHexInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinHueProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHueProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinSaturationProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinSaturationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxSaturationProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSaturationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinValueProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxValueProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorSpectrumShapeProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumShapeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorSpectrumComponentsProperty<Impl: IColorPickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumComponentsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColorPickerStatics, BASE_OFFSET>(),
            ColorProperty: ColorProperty::<Impl, IMPL_OFFSET>,
            PreviousColorProperty: PreviousColorProperty::<Impl, IMPL_OFFSET>,
            IsAlphaEnabledProperty: IsAlphaEnabledProperty::<Impl, IMPL_OFFSET>,
            IsColorSpectrumVisibleProperty: IsColorSpectrumVisibleProperty::<Impl, IMPL_OFFSET>,
            IsColorPreviewVisibleProperty: IsColorPreviewVisibleProperty::<Impl, IMPL_OFFSET>,
            IsColorSliderVisibleProperty: IsColorSliderVisibleProperty::<Impl, IMPL_OFFSET>,
            IsAlphaSliderVisibleProperty: IsAlphaSliderVisibleProperty::<Impl, IMPL_OFFSET>,
            IsMoreButtonVisibleProperty: IsMoreButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsColorChannelTextInputVisibleProperty: IsColorChannelTextInputVisibleProperty::<Impl, IMPL_OFFSET>,
            IsAlphaTextInputVisibleProperty: IsAlphaTextInputVisibleProperty::<Impl, IMPL_OFFSET>,
            IsHexInputVisibleProperty: IsHexInputVisibleProperty::<Impl, IMPL_OFFSET>,
            MinHueProperty: MinHueProperty::<Impl, IMPL_OFFSET>,
            MaxHueProperty: MaxHueProperty::<Impl, IMPL_OFFSET>,
            MinSaturationProperty: MinSaturationProperty::<Impl, IMPL_OFFSET>,
            MaxSaturationProperty: MaxSaturationProperty::<Impl, IMPL_OFFSET>,
            MinValueProperty: MinValueProperty::<Impl, IMPL_OFFSET>,
            MaxValueProperty: MaxValueProperty::<Impl, IMPL_OFFSET>,
            ColorSpectrumShapeProperty: ColorSpectrumShapeProperty::<Impl, IMPL_OFFSET>,
            ColorSpectrumComponentsProperty: ColorSpectrumComponentsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColorPickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColumnDefinition_Impl: Sized {
    fn Width(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetWidth(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn MaxWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MinWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ActualWidth(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColumnDefinition {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColumnDefinition";
}
#[cfg(feature = "implement_exclusive")]
impl IColumnDefinition_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColumnDefinition_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColumnDefinition_Vtbl {
        unsafe extern "system" fn Width<Impl: IColumnDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Width() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWidth<Impl: IColumnDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWidth(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxWidth<Impl: IColumnDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxWidth<Impl: IColumnDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxWidth(value).into()
        }
        unsafe extern "system" fn MinWidth<Impl: IColumnDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinWidth<Impl: IColumnDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinWidth(value).into()
        }
        unsafe extern "system" fn ActualWidth<Impl: IColumnDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColumnDefinition, BASE_OFFSET>(),
            Width: Width::<Impl, IMPL_OFFSET>,
            SetWidth: SetWidth::<Impl, IMPL_OFFSET>,
            MaxWidth: MaxWidth::<Impl, IMPL_OFFSET>,
            SetMaxWidth: SetMaxWidth::<Impl, IMPL_OFFSET>,
            MinWidth: MinWidth::<Impl, IMPL_OFFSET>,
            SetMinWidth: SetMinWidth::<Impl, IMPL_OFFSET>,
            ActualWidth: ActualWidth::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColumnDefinition as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColumnDefinitionStatics_Impl: Sized {
    fn WidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColumnDefinitionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColumnDefinitionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IColumnDefinitionStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IColumnDefinitionStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IColumnDefinitionStatics_Vtbl {
        unsafe extern "system" fn WidthProperty<Impl: IColumnDefinitionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxWidthProperty<Impl: IColumnDefinitionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinWidthProperty<Impl: IColumnDefinitionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IColumnDefinitionStatics, BASE_OFFSET>(),
            WidthProperty: WidthProperty::<Impl, IMPL_OFFSET>,
            MaxWidthProperty: MaxWidthProperty::<Impl, IMPL_OFFSET>,
            MinWidthProperty: MinWidthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IColumnDefinitionStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IComboBox_Impl: Sized {
    fn IsDropDownOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDropDownOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsEditable(&mut self) -> ::windows::core::Result<bool>;
    fn IsSelectionBoxHighlighted(&mut self) -> ::windows::core::Result<bool>;
    fn MaxDropDownHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxDropDownHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn SelectionBoxItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SelectionBoxItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ComboBoxTemplateSettings>;
    fn DropDownClosed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDropDownClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DropDownOpened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDropDownOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IComboBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IComboBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox_Vtbl {
        unsafe extern "system" fn IsDropDownOpen<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDropDownOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDropDownOpen<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDropDownOpen(value).into()
        }
        unsafe extern "system" fn IsEditable<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEditable() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSelectionBoxHighlighted<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSelectionBoxHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDropDownHeight<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDropDownHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDropDownHeight<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxDropDownHeight(value).into()
        }
        unsafe extern "system" fn SelectionBoxItem<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionBoxItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionBoxItemTemplate<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionBoxItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettings<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropDownClosed<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropDownClosed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDropDownClosed<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDropDownClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DropDownOpened<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropDownOpened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDropDownOpened<Impl: IComboBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDropDownOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox, BASE_OFFSET>(),
            IsDropDownOpen: IsDropDownOpen::<Impl, IMPL_OFFSET>,
            SetIsDropDownOpen: SetIsDropDownOpen::<Impl, IMPL_OFFSET>,
            IsEditable: IsEditable::<Impl, IMPL_OFFSET>,
            IsSelectionBoxHighlighted: IsSelectionBoxHighlighted::<Impl, IMPL_OFFSET>,
            MaxDropDownHeight: MaxDropDownHeight::<Impl, IMPL_OFFSET>,
            SetMaxDropDownHeight: SetMaxDropDownHeight::<Impl, IMPL_OFFSET>,
            SelectionBoxItem: SelectionBoxItem::<Impl, IMPL_OFFSET>,
            SelectionBoxItemTemplate: SelectionBoxItemTemplate::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            DropDownClosed: DropDownClosed::<Impl, IMPL_OFFSET>,
            RemoveDropDownClosed: RemoveDropDownClosed::<Impl, IMPL_OFFSET>,
            DropDownOpened: DropDownOpened::<Impl, IMPL_OFFSET>,
            RemoveDropDownOpened: RemoveDropDownOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox2_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox2_Vtbl {
        unsafe extern "system" fn Header<Impl: IComboBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IComboBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IComboBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IComboBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IComboBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IComboBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox3_Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
    fn IsTextSearchEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextSearchEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox3_Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IComboBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IComboBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        unsafe extern "system" fn IsTextSearchEnabled<Impl: IComboBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSearchEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSearchEnabled<Impl: IComboBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextSearchEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox3, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            IsTextSearchEnabled: IsTextSearchEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextSearchEnabled: SetIsTextSearchEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox4_Impl: Sized {
    fn SelectionChangedTrigger(&mut self) -> ::windows::core::Result<ComboBoxSelectionChangedTrigger>;
    fn SetSelectionChangedTrigger(&mut self, value: ComboBoxSelectionChangedTrigger) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox4_Vtbl {
        unsafe extern "system" fn SelectionChangedTrigger<Impl: IComboBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ComboBoxSelectionChangedTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChangedTrigger() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionChangedTrigger<Impl: IComboBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ComboBoxSelectionChangedTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionChangedTrigger(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox4, BASE_OFFSET>(),
            SelectionChangedTrigger: SelectionChangedTrigger::<Impl, IMPL_OFFSET>,
            SetSelectionChangedTrigger: SetSelectionChangedTrigger::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IComboBox5_Impl: Sized {
    fn PlaceholderForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPlaceholderForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IComboBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox5";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IComboBox5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox5_Vtbl {
        unsafe extern "system" fn PlaceholderForeground<Impl: IComboBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderForeground<Impl: IComboBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox5, BASE_OFFSET>(),
            PlaceholderForeground: PlaceholderForeground::<Impl, IMPL_OFFSET>,
            SetPlaceholderForeground: SetPlaceholderForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IComboBox6_Impl: Sized {
    fn SetIsEditable(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn TextBoxStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetTextBoxStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TextSubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextSubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IComboBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox6";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IComboBox6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBox6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBox6_Vtbl {
        unsafe extern "system" fn SetIsEditable<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsEditable(value).into()
        }
        unsafe extern "system" fn Text<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextBoxStyle<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextBoxStyle<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextBoxStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Description<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextSubmitted<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextSubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextSubmitted<Impl: IComboBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextSubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBox6, BASE_OFFSET>(),
            SetIsEditable: SetIsEditable::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            TextBoxStyle: TextBoxStyle::<Impl, IMPL_OFFSET>,
            SetTextBoxStyle: SetTextBoxStyle::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            TextSubmitted: TextSubmitted::<Impl, IMPL_OFFSET>,
            RemoveTextSubmitted: RemoveTextSubmitted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBox6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ComboBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IComboBoxFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxItem_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxItem";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxItem_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ComboBoxItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IComboBoxItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxOverrides_Impl: Sized {
    fn OnDropDownClosed(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnDropDownOpened(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxOverrides_Vtbl {
        unsafe extern "system" fn OnDropDownClosed<Impl: IComboBoxOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDropDownClosed(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDropDownOpened<Impl: IComboBoxOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDropDownOpened(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxOverrides, BASE_OFFSET>(),
            OnDropDownClosed: OnDropDownClosed::<Impl, IMPL_OFFSET>,
            OnDropDownOpened: OnDropDownOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics_Impl: Sized {
    fn IsDropDownOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDropDownHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics_Vtbl {
        unsafe extern "system" fn IsDropDownOpenProperty<Impl: IComboBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDropDownOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDropDownHeightProperty<Impl: IComboBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxDropDownHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics, BASE_OFFSET>(),
            IsDropDownOpenProperty: IsDropDownOpenProperty::<Impl, IMPL_OFFSET>,
            MaxDropDownHeightProperty: MaxDropDownHeightProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics2_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics2_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IComboBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IComboBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IComboBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics3_Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSearchEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics3_Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IComboBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSearchEnabledProperty<Impl: IComboBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSearchEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics3, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
            IsTextSearchEnabledProperty: IsTextSearchEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics4_Impl: Sized {
    fn SelectionChangedTriggerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics4_Vtbl {
        unsafe extern "system" fn SelectionChangedTriggerProperty<Impl: IComboBoxStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChangedTriggerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics4, BASE_OFFSET>(),
            SelectionChangedTriggerProperty: SelectionChangedTriggerProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics5_Impl: Sized {
    fn PlaceholderForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics5_Vtbl {
        unsafe extern "system" fn PlaceholderForegroundProperty<Impl: IComboBoxStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics5, BASE_OFFSET>(),
            PlaceholderForegroundProperty: PlaceholderForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics6_Impl: Sized {
    fn IsEditableProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextBoxStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxStatics6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxStatics6_Vtbl {
        unsafe extern "system" fn IsEditableProperty<Impl: IComboBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEditableProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: IComboBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextBoxStyleProperty<Impl: IComboBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextBoxStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IComboBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxStatics6, BASE_OFFSET>(),
            IsEditableProperty: IsEditableProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            TextBoxStyleProperty: TextBoxStyleProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxTextSubmittedEventArgs_Impl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxTextSubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxTextSubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxTextSubmittedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComboBoxTextSubmittedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComboBoxTextSubmittedEventArgs_Vtbl {
        unsafe extern "system" fn Text<Impl: IComboBoxTextSubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IComboBoxTextSubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IComboBoxTextSubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IComboBoxTextSubmittedEventArgs, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComboBoxTextSubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICommandBar_Impl: Sized {
    fn PrimaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
    fn SecondaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICommandBar_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBar_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBar_Vtbl {
        unsafe extern "system" fn PrimaryCommands<Impl: ICommandBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommands<Impl: ICommandBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBar, BASE_OFFSET>(),
            PrimaryCommands: PrimaryCommands::<Impl, IMPL_OFFSET>,
            SecondaryCommands: SecondaryCommands::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBar as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait ICommandBar2_Impl: Sized {
    fn CommandBarOverflowPresenterStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCommandBarOverflowPresenterStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CommandBarTemplateSettings(&mut self) -> ::windows::core::Result<Primitives::CommandBarTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar2";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ICommandBar2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBar2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBar2_Vtbl {
        unsafe extern "system" fn CommandBarOverflowPresenterStyle<Impl: ICommandBar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandBarOverflowPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandBarOverflowPresenterStyle<Impl: ICommandBar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandBarOverflowPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandBarTemplateSettings<Impl: ICommandBar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandBarTemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBar2, BASE_OFFSET>(),
            CommandBarOverflowPresenterStyle: CommandBarOverflowPresenterStyle::<Impl, IMPL_OFFSET>,
            SetCommandBarOverflowPresenterStyle: SetCommandBarOverflowPresenterStyle::<Impl, IMPL_OFFSET>,
            CommandBarTemplateSettings: CommandBarTemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBar2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ICommandBar3_Impl: Sized {
    fn DefaultLabelPosition(&mut self) -> ::windows::core::Result<CommandBarDefaultLabelPosition>;
    fn SetDefaultLabelPosition(&mut self, value: CommandBarDefaultLabelPosition) -> ::windows::core::Result<()>;
    fn OverflowButtonVisibility(&mut self) -> ::windows::core::Result<CommandBarOverflowButtonVisibility>;
    fn SetOverflowButtonVisibility(&mut self, value: CommandBarOverflowButtonVisibility) -> ::windows::core::Result<()>;
    fn IsDynamicOverflowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDynamicOverflowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DynamicOverflowItemsChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDynamicOverflowItemsChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ICommandBar3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBar3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBar3_Vtbl {
        unsafe extern "system" fn DefaultLabelPosition<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarDefaultLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultLabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultLabelPosition<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarDefaultLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultLabelPosition(value).into()
        }
        unsafe extern "system" fn OverflowButtonVisibility<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarOverflowButtonVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowButtonVisibility<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CommandBarOverflowButtonVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowButtonVisibility(value).into()
        }
        unsafe extern "system" fn IsDynamicOverflowEnabled<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDynamicOverflowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDynamicOverflowEnabled<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDynamicOverflowEnabled(value).into()
        }
        unsafe extern "system" fn DynamicOverflowItemsChanging<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowItemsChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDynamicOverflowItemsChanging<Impl: ICommandBar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDynamicOverflowItemsChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBar3, BASE_OFFSET>(),
            DefaultLabelPosition: DefaultLabelPosition::<Impl, IMPL_OFFSET>,
            SetDefaultLabelPosition: SetDefaultLabelPosition::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibility: OverflowButtonVisibility::<Impl, IMPL_OFFSET>,
            SetOverflowButtonVisibility: SetOverflowButtonVisibility::<Impl, IMPL_OFFSET>,
            IsDynamicOverflowEnabled: IsDynamicOverflowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDynamicOverflowEnabled: SetIsDynamicOverflowEnabled::<Impl, IMPL_OFFSET>,
            DynamicOverflowItemsChanging: DynamicOverflowItemsChanging::<Impl, IMPL_OFFSET>,
            RemoveDynamicOverflowItemsChanging: RemoveDynamicOverflowItemsChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBar3 as ::windows::core::Interface>::IID
    }
}
pub trait ICommandBarElement_Impl: Sized {
    fn IsCompact(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompact(&mut self, value: bool) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ICommandBarElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarElement";
}
impl ICommandBarElement_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarElement_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarElement_Vtbl {
        unsafe extern "system" fn IsCompact<Impl: ICommandBarElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompact<Impl: ICommandBarElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompact(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarElement, BASE_OFFSET>(),
            IsCompact: IsCompact::<Impl, IMPL_OFFSET>,
            SetIsCompact: SetIsCompact::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarElement as ::windows::core::Interface>::IID
    }
}
pub trait ICommandBarElement2_Impl: Sized {
    fn IsInOverflow(&mut self) -> ::windows::core::Result<bool>;
    fn DynamicOverflowOrder(&mut self) -> ::windows::core::Result<i32>;
    fn SetDynamicOverflowOrder(&mut self, value: i32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ICommandBarElement2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarElement2";
}
impl ICommandBarElement2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarElement2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarElement2_Vtbl {
        unsafe extern "system" fn IsInOverflow<Impl: ICommandBarElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInOverflow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrder<Impl: ICommandBarElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDynamicOverflowOrder<Impl: ICommandBarElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDynamicOverflowOrder(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarElement2, BASE_OFFSET>(),
            IsInOverflow: IsInOverflow::<Impl, IMPL_OFFSET>,
            DynamicOverflowOrder: DynamicOverflowOrder::<Impl, IMPL_OFFSET>,
            SetDynamicOverflowOrder: SetDynamicOverflowOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarElement2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ICommandBarFlyout_Impl: Sized {
    fn PrimaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
    fn SecondaryCommands(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ICommandBarFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFlyout";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ICommandBarFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarFlyout_Vtbl {
        unsafe extern "system" fn PrimaryCommands<Impl: ICommandBarFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommands<Impl: ICommandBarFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarFlyout, BASE_OFFSET>(),
            PrimaryCommands: PrimaryCommands::<Impl, IMPL_OFFSET>,
            SecondaryCommands: SecondaryCommands::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarFlyoutFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBarFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarFlyoutFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarFlyoutFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarFlyoutFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarFlyoutFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarOverflowPresenter_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarOverflowPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarOverflowPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarOverflowPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarOverflowPresenter_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarOverflowPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarOverflowPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarOverflowPresenterFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBarOverflowPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarOverflowPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarOverflowPresenterFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarOverflowPresenterFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarOverflowPresenterFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarOverflowPresenterFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarOverflowPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarOverflowPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStatics_Impl: Sized {
    fn PrimaryCommandsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryCommandsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarStatics_Vtbl {
        unsafe extern "system" fn PrimaryCommandsProperty<Impl: ICommandBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryCommandsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommandsProperty<Impl: ICommandBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryCommandsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarStatics, BASE_OFFSET>(),
            PrimaryCommandsProperty: PrimaryCommandsProperty::<Impl, IMPL_OFFSET>,
            SecondaryCommandsProperty: SecondaryCommandsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStatics2_Impl: Sized {
    fn CommandBarOverflowPresenterStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarStatics2_Vtbl {
        unsafe extern "system" fn CommandBarOverflowPresenterStyleProperty<Impl: ICommandBarStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandBarOverflowPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarStatics2, BASE_OFFSET>(),
            CommandBarOverflowPresenterStyleProperty: CommandBarOverflowPresenterStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStatics3_Impl: Sized {
    fn DefaultLabelPositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsDynamicOverflowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICommandBarStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICommandBarStatics3_Vtbl {
        unsafe extern "system" fn DefaultLabelPositionProperty<Impl: ICommandBarStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultLabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibilityProperty<Impl: ICommandBarStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDynamicOverflowEnabledProperty<Impl: ICommandBarStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDynamicOverflowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ICommandBarStatics3, BASE_OFFSET>(),
            DefaultLabelPositionProperty: DefaultLabelPositionProperty::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibilityProperty: OverflowButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            IsDynamicOverflowEnabledProperty: IsDynamicOverflowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICommandBarStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IContainerContentChangingEventArgs_Impl: Sized {
    fn ItemContainer(&mut self) -> ::windows::core::Result<Primitives::SelectorItem>;
    fn InRecycleQueue(&mut self) -> ::windows::core::Result<bool>;
    fn ItemIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn Phase(&mut self) -> ::windows::core::Result<u32>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallback(&mut self, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallbackWithPhase(&mut self, callbackphase: u32, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContainerContentChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContainerContentChangingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IContainerContentChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContainerContentChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContainerContentChangingEventArgs_Vtbl {
        unsafe extern "system" fn ItemContainer<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InRecycleQueue<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InRecycleQueue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemIndex<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Phase<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Phase() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn RegisterUpdateCallback<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallback(&*(&callback as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RegisterUpdateCallbackWithPhase<Impl: IContainerContentChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, callbackphase: u32, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallbackWithPhase(callbackphase, &*(&callback as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContainerContentChangingEventArgs, BASE_OFFSET>(),
            ItemContainer: ItemContainer::<Impl, IMPL_OFFSET>,
            InRecycleQueue: InRecycleQueue::<Impl, IMPL_OFFSET>,
            ItemIndex: ItemIndex::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Phase: Phase::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallback: RegisterUpdateCallback::<Impl, IMPL_OFFSET>,
            RegisterUpdateCallbackWithPhase: RegisterUpdateCallbackWithPhase::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContainerContentChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IContentControl_Impl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetContentTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ContentTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetContentTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControl";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IContentControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControl_Vtbl {
        unsafe extern "system" fn Content<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplateSelector<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplateSelector<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTransitions<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTransitions<Impl: IContentControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControl, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            ContentTemplate: ContentTemplate::<Impl, IMPL_OFFSET>,
            SetContentTemplate: SetContentTemplate::<Impl, IMPL_OFFSET>,
            ContentTemplateSelector: ContentTemplateSelector::<Impl, IMPL_OFFSET>,
            SetContentTemplateSelector: SetContentTemplateSelector::<Impl, IMPL_OFFSET>,
            ContentTransitions: ContentTransitions::<Impl, IMPL_OFFSET>,
            SetContentTransitions: SetContentTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControl2_Impl: Sized {
    fn ContentTemplateRoot(&mut self) -> ::windows::core::Result<super::UIElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControl2_Vtbl {
        unsafe extern "system" fn ContentTemplateRoot<Impl: IContentControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateRoot() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControl2, BASE_OFFSET>(),
            ContentTemplateRoot: ContentTemplateRoot::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControlFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControlFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentControlFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlOverrides_Impl: Sized {
    fn OnContentChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnContentTemplateChanged(&mut self, oldcontenttemplate: &::core::option::Option<super::DataTemplate>, newcontenttemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContentTemplateSelectorChanged(&mut self, oldcontenttemplateselector: &::core::option::Option<DataTemplateSelector>, newcontenttemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControlOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControlOverrides_Vtbl {
        unsafe extern "system" fn OnContentChanged<Impl: IContentControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateChanged<Impl: IContentControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplate: ::windows::core::RawPtr, newcontenttemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateChanged(&*(&oldcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateSelectorChanged<Impl: IContentControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplateselector: ::windows::core::RawPtr, newcontenttemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateSelectorChanged(&*(&oldcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControlOverrides, BASE_OFFSET>(),
            OnContentChanged: OnContentChanged::<Impl, IMPL_OFFSET>,
            OnContentTemplateChanged: OnContentTemplateChanged::<Impl, IMPL_OFFSET>,
            OnContentTemplateSelectorChanged: OnContentTemplateSelectorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControlOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlStatics_Impl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentControlStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentControlStatics_Vtbl {
        unsafe extern "system" fn ContentProperty<Impl: IContentControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IContentControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateSelectorProperty<Impl: IContentControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTransitionsProperty<Impl: IContentControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentControlStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateProperty: ContentTemplateProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateSelectorProperty: ContentTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ContentTransitionsProperty: ContentTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IContentDialog_Impl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetTitle(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TitleTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetTitleTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FullSizeDesired(&mut self) -> ::windows::core::Result<bool>;
    fn SetFullSizeDesired(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PrimaryButtonText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPrimaryButtonText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SecondaryButtonText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSecondaryButtonText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PrimaryButtonCommand(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetPrimaryButtonCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn SecondaryButtonCommand(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetSecondaryButtonCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn PrimaryButtonCommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetPrimaryButtonCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SecondaryButtonCommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSecondaryButtonCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn IsPrimaryButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPrimaryButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSecondaryButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSecondaryButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Closing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PrimaryButtonClick(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePrimaryButtonClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SecondaryButtonClick(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSecondaryButtonClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Hide(&mut self) -> ::windows::core::Result<()>;
    fn ShowAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<ContentDialogResult>>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentDialog {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IContentDialog_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialog_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialog_Vtbl {
        unsafe extern "system" fn Title<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TitleTemplate<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitleTemplate<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitleTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FullSizeDesired<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FullSizeDesired() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullSizeDesired<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFullSizeDesired(value).into()
        }
        unsafe extern "system" fn PrimaryButtonText<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonText<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonText<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonText<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonCommand<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonCommand<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonCommand<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonCommand<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonCommandParameter<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonCommandParameter<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonCommandParameter<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonCommandParameter<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPrimaryButtonEnabled<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPrimaryButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPrimaryButtonEnabled<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPrimaryButtonEnabled(value).into()
        }
        unsafe extern "system" fn IsSecondaryButtonEnabled<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSecondaryButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSecondaryButtonEnabled<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSecondaryButtonEnabled(value).into()
        }
        unsafe extern "system" fn Closing<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosing<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonClick<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePrimaryButtonClick<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePrimaryButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonClick<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSecondaryButtonClick<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSecondaryButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Hide<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        unsafe extern "system" fn ShowAsync<Impl: IContentDialog_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialog, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            TitleTemplate: TitleTemplate::<Impl, IMPL_OFFSET>,
            SetTitleTemplate: SetTitleTemplate::<Impl, IMPL_OFFSET>,
            FullSizeDesired: FullSizeDesired::<Impl, IMPL_OFFSET>,
            SetFullSizeDesired: SetFullSizeDesired::<Impl, IMPL_OFFSET>,
            PrimaryButtonText: PrimaryButtonText::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonText: SetPrimaryButtonText::<Impl, IMPL_OFFSET>,
            SecondaryButtonText: SecondaryButtonText::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonText: SetSecondaryButtonText::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommand: PrimaryButtonCommand::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonCommand: SetPrimaryButtonCommand::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommand: SecondaryButtonCommand::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonCommand: SetSecondaryButtonCommand::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommandParameter: PrimaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonCommandParameter: SetPrimaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommandParameter: SecondaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonCommandParameter: SetSecondaryButtonCommandParameter::<Impl, IMPL_OFFSET>,
            IsPrimaryButtonEnabled: IsPrimaryButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsPrimaryButtonEnabled: SetIsPrimaryButtonEnabled::<Impl, IMPL_OFFSET>,
            IsSecondaryButtonEnabled: IsSecondaryButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsSecondaryButtonEnabled: SetIsSecondaryButtonEnabled::<Impl, IMPL_OFFSET>,
            Closing: Closing::<Impl, IMPL_OFFSET>,
            RemoveClosing: RemoveClosing::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            PrimaryButtonClick: PrimaryButtonClick::<Impl, IMPL_OFFSET>,
            RemovePrimaryButtonClick: RemovePrimaryButtonClick::<Impl, IMPL_OFFSET>,
            SecondaryButtonClick: SecondaryButtonClick::<Impl, IMPL_OFFSET>,
            RemoveSecondaryButtonClick: RemoveSecondaryButtonClick::<Impl, IMPL_OFFSET>,
            Hide: Hide::<Impl, IMPL_OFFSET>,
            ShowAsync: ShowAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialog as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IContentDialog2_Impl: Sized {
    fn CloseButtonText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCloseButtonText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CloseButtonCommand(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCloseButtonCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CloseButtonCommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCloseButtonCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PrimaryButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetPrimaryButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SecondaryButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetSecondaryButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CloseButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetCloseButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn DefaultButton(&mut self) -> ::windows::core::Result<ContentDialogButton>;
    fn SetDefaultButton(&mut self, value: ContentDialogButton) -> ::windows::core::Result<()>;
    fn CloseButtonClick(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCloseButtonClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentDialog2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IContentDialog2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialog2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialog2_Vtbl {
        unsafe extern "system" fn CloseButtonText<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonText<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonCommand<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonCommand<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonCommandParameter<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonCommandParameter<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonStyle<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonStyle<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonStyle<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonStyle<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonStyle<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonStyle<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCloseButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DefaultButton<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogButton) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultButton<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ContentDialogButton) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultButton(value).into()
        }
        unsafe extern "system" fn CloseButtonClick<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCloseButtonClick<Impl: IContentDialog2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCloseButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialog2, BASE_OFFSET>(),
            CloseButtonText: CloseButtonText::<Impl, IMPL_OFFSET>,
            SetCloseButtonText: SetCloseButtonText::<Impl, IMPL_OFFSET>,
            CloseButtonCommand: CloseButtonCommand::<Impl, IMPL_OFFSET>,
            SetCloseButtonCommand: SetCloseButtonCommand::<Impl, IMPL_OFFSET>,
            CloseButtonCommandParameter: CloseButtonCommandParameter::<Impl, IMPL_OFFSET>,
            SetCloseButtonCommandParameter: SetCloseButtonCommandParameter::<Impl, IMPL_OFFSET>,
            PrimaryButtonStyle: PrimaryButtonStyle::<Impl, IMPL_OFFSET>,
            SetPrimaryButtonStyle: SetPrimaryButtonStyle::<Impl, IMPL_OFFSET>,
            SecondaryButtonStyle: SecondaryButtonStyle::<Impl, IMPL_OFFSET>,
            SetSecondaryButtonStyle: SetSecondaryButtonStyle::<Impl, IMPL_OFFSET>,
            CloseButtonStyle: CloseButtonStyle::<Impl, IMPL_OFFSET>,
            SetCloseButtonStyle: SetCloseButtonStyle::<Impl, IMPL_OFFSET>,
            DefaultButton: DefaultButton::<Impl, IMPL_OFFSET>,
            SetDefaultButton: SetDefaultButton::<Impl, IMPL_OFFSET>,
            CloseButtonClick: CloseButtonClick::<Impl, IMPL_OFFSET>,
            RemoveCloseButtonClick: RemoveCloseButtonClick::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialog2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IContentDialog3_Impl: Sized {
    fn ShowAsyncWithPlacement(&mut self, placement: ContentDialogPlacement) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<ContentDialogResult>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentDialog3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IContentDialog3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialog3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialog3_Vtbl {
        unsafe extern "system" fn ShowAsyncWithPlacement<Impl: IContentDialog3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, placement: ContentDialogPlacement, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAsyncWithPlacement(placement) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialog3, BASE_OFFSET>(),
            ShowAsyncWithPlacement: ShowAsyncWithPlacement::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialog3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogButtonClickDeferral_Impl: Sized {
    fn Complete(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogButtonClickDeferral {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogButtonClickDeferral";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogButtonClickDeferral_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogButtonClickDeferral_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogButtonClickDeferral_Vtbl {
        unsafe extern "system" fn Complete<Impl: IContentDialogButtonClickDeferral_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Complete().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogButtonClickDeferral, BASE_OFFSET>(),
            Complete: Complete::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogButtonClickDeferral as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogButtonClickEventArgs_Impl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn GetDeferral(&mut self) -> ::windows::core::Result<ContentDialogButtonClickDeferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogButtonClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogButtonClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogButtonClickEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogButtonClickEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogButtonClickEventArgs_Vtbl {
        unsafe extern "system" fn Cancel<Impl: IContentDialogButtonClickEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IContentDialogButtonClickEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IContentDialogButtonClickEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogButtonClickEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogButtonClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosedEventArgs_Impl: Sized {
    fn Result(&mut self) -> ::windows::core::Result<ContentDialogResult>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogClosedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogClosedEventArgs_Vtbl {
        unsafe extern "system" fn Result<Impl: IContentDialogClosedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogResult) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Result() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogClosedEventArgs, BASE_OFFSET>(), Result: Result::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogClosedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosingDeferral_Impl: Sized {
    fn Complete(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosingDeferral {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosingDeferral";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosingDeferral_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogClosingDeferral_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogClosingDeferral_Vtbl {
        unsafe extern "system" fn Complete<Impl: IContentDialogClosingDeferral_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Complete().into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogClosingDeferral, BASE_OFFSET>(), Complete: Complete::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogClosingDeferral as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosingEventArgs_Impl: Sized {
    fn Result(&mut self) -> ::windows::core::Result<ContentDialogResult>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn GetDeferral(&mut self) -> ::windows::core::Result<ContentDialogClosingDeferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogClosingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogClosingEventArgs_Vtbl {
        unsafe extern "system" fn Result<Impl: IContentDialogClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogResult) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Result() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IContentDialogClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IContentDialogClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IContentDialogClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogClosingEventArgs, BASE_OFFSET>(),
            Result: Result::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogClosingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentDialog>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentDialogFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogOpenedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogOpenedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogOpenedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogOpenedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogOpenedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogOpenedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogOpenedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogOpenedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogStatics_Impl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TitleTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FullSizeDesiredProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonCommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonCommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonCommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonCommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPrimaryButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSecondaryButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogStatics_Vtbl {
        unsafe extern "system" fn TitleProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitleTemplateProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FullSizeDesiredProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FullSizeDesiredProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonTextProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonTextProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonCommandProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonCommandProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonCommandParameterProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonCommandParameterProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPrimaryButtonEnabledProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPrimaryButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSecondaryButtonEnabledProperty<Impl: IContentDialogStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSecondaryButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            TitleTemplateProperty: TitleTemplateProperty::<Impl, IMPL_OFFSET>,
            FullSizeDesiredProperty: FullSizeDesiredProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonTextProperty: PrimaryButtonTextProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonTextProperty: SecondaryButtonTextProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommandProperty: PrimaryButtonCommandProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommandProperty: SecondaryButtonCommandProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonCommandParameterProperty: PrimaryButtonCommandParameterProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonCommandParameterProperty: SecondaryButtonCommandParameterProperty::<Impl, IMPL_OFFSET>,
            IsPrimaryButtonEnabledProperty: IsPrimaryButtonEnabledProperty::<Impl, IMPL_OFFSET>,
            IsSecondaryButtonEnabledProperty: IsSecondaryButtonEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogStatics2_Impl: Sized {
    fn CloseButtonTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonCommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonCommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultButtonProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentDialogStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentDialogStatics2_Vtbl {
        unsafe extern "system" fn CloseButtonTextProperty<Impl: IContentDialogStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonCommandProperty<Impl: IContentDialogStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonCommandParameterProperty<Impl: IContentDialogStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonStyleProperty<Impl: IContentDialogStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonStyleProperty<Impl: IContentDialogStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonStyleProperty<Impl: IContentDialogStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultButtonProperty<Impl: IContentDialogStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultButtonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentDialogStatics2, BASE_OFFSET>(),
            CloseButtonTextProperty: CloseButtonTextProperty::<Impl, IMPL_OFFSET>,
            CloseButtonCommandProperty: CloseButtonCommandProperty::<Impl, IMPL_OFFSET>,
            CloseButtonCommandParameterProperty: CloseButtonCommandParameterProperty::<Impl, IMPL_OFFSET>,
            PrimaryButtonStyleProperty: PrimaryButtonStyleProperty::<Impl, IMPL_OFFSET>,
            SecondaryButtonStyleProperty: SecondaryButtonStyleProperty::<Impl, IMPL_OFFSET>,
            CloseButtonStyleProperty: CloseButtonStyleProperty::<Impl, IMPL_OFFSET>,
            DefaultButtonProperty: DefaultButtonProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentDialogStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait IContentLinkChangedEventArgs_Impl: Sized {
    fn ChangeKind(&mut self) -> ::windows::core::Result<ContentLinkChangeKind>;
    fn ContentLinkInfo(&mut self) -> ::windows::core::Result<super::super::Text::ContentLinkInfo>;
    fn TextRange(&mut self) -> ::windows::core::Result<super::Documents::TextRange>;
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentLinkChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentLinkChangedEventArgs";
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl IContentLinkChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentLinkChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentLinkChangedEventArgs_Vtbl {
        unsafe extern "system" fn ChangeKind<Impl: IContentLinkChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ContentLinkChangeKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChangeKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkInfo<Impl: IContentLinkChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextRange<Impl: IContentLinkChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Documents::TextRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextRange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentLinkChangedEventArgs, BASE_OFFSET>(),
            ChangeKind: ChangeKind::<Impl, IMPL_OFFSET>,
            ContentLinkInfo: ContentLinkInfo::<Impl, IMPL_OFFSET>,
            TextRange: TextRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentLinkChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IContentPresenter_Impl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetContentTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ContentTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetContentTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IContentPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter_Vtbl {
        unsafe extern "system" fn Content<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplateSelector<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplateSelector<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTransitions<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTransitions<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            ContentTemplate: ContentTemplate::<Impl, IMPL_OFFSET>,
            SetContentTemplate: SetContentTemplate::<Impl, IMPL_OFFSET>,
            ContentTemplateSelector: ContentTemplateSelector::<Impl, IMPL_OFFSET>,
            SetContentTemplateSelector: SetContentTemplateSelector::<Impl, IMPL_OFFSET>,
            ContentTransitions: ContentTransitions::<Impl, IMPL_OFFSET>,
            SetContentTransitions: SetContentTransitions::<Impl, IMPL_OFFSET>,
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter2_Impl: Sized {
    fn OpticalMarginAlignment(&mut self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&mut self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn TextLineBounds(&mut self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&mut self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter2_Vtbl {
        unsafe extern "system" fn OpticalMarginAlignment<Impl: IContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: IContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: IContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: IContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter2, BASE_OFFSET>(),
            OpticalMarginAlignment: OpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            SetOpticalMarginAlignment: SetOpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            TextLineBounds: TextLineBounds::<Impl, IMPL_OFFSET>,
            SetTextLineBounds: SetTextLineBounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter3_Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter3";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter3_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IContentPresenter3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IContentPresenter3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter3, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IContentPresenter4_Impl: Sized {
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&mut self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&mut self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn LineHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HorizontalContentAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalContentAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalContentAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalContentAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IContentPresenter4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter4";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IContentPresenter4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter4_Vtbl {
        unsafe extern "system" fn TextWrapping<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn MaxLines<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn LineHeight<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn BorderBrush<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalContentAlignment<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalContentAlignment<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalContentAlignment(value).into()
        }
        unsafe extern "system" fn VerticalContentAlignment<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalContentAlignment<Impl: IContentPresenter4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalContentAlignment(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter4, BASE_OFFSET>(),
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
            LineStackingStrategy: LineStackingStrategy::<Impl, IMPL_OFFSET>,
            SetLineStackingStrategy: SetLineStackingStrategy::<Impl, IMPL_OFFSET>,
            LineHeight: LineHeight::<Impl, IMPL_OFFSET>,
            SetLineHeight: SetLineHeight::<Impl, IMPL_OFFSET>,
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignment: HorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalContentAlignment: SetHorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            VerticalContentAlignment: VerticalContentAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalContentAlignment: SetVerticalContentAlignment::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter5_Impl: Sized {
    fn BackgroundTransition(&mut self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&mut self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter5";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenter5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenter5_Vtbl {
        unsafe extern "system" fn BackgroundTransition<Impl: IContentPresenter5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IContentPresenter5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackgroundSizing<Impl: IContentPresenter5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IContentPresenter5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenter5, BASE_OFFSET>(),
            BackgroundTransition: BackgroundTransition::<Impl, IMPL_OFFSET>,
            SetBackgroundTransition: SetBackgroundTransition::<Impl, IMPL_OFFSET>,
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenter5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentPresenterFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterOverrides_Impl: Sized {
    fn OnContentTemplateChanged(&mut self, oldcontenttemplate: &::core::option::Option<super::DataTemplate>, newcontenttemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContentTemplateSelectorChanged(&mut self, oldcontenttemplateselector: &::core::option::Option<DataTemplateSelector>, newcontenttemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterOverrides_Vtbl {
        unsafe extern "system" fn OnContentTemplateChanged<Impl: IContentPresenterOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplate: ::windows::core::RawPtr, newcontenttemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateChanged(&*(&oldcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateSelectorChanged<Impl: IContentPresenterOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontenttemplateselector: ::windows::core::RawPtr, newcontenttemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnContentTemplateSelectorChanged(&*(&oldcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterOverrides, BASE_OFFSET>(),
            OnContentTemplateChanged: OnContentTemplateChanged::<Impl, IMPL_OFFSET>,
            OnContentTemplateSelectorChanged: OnContentTemplateSelectorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics_Impl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics_Vtbl {
        unsafe extern "system" fn ContentProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateSelectorProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTransitionsProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IContentPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateProperty: ContentTemplateProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateSelectorProperty: ContentTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ContentTransitionsProperty: ContentTransitionsProperty::<Impl, IMPL_OFFSET>,
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics2_Impl: Sized {
    fn OpticalMarginAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics2_Vtbl {
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: IContentPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: IContentPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics2, BASE_OFFSET>(),
            OpticalMarginAlignmentProperty: OpticalMarginAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextLineBoundsProperty: TextLineBoundsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics3_Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics3_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IContentPresenterStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics3, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics4_Impl: Sized {
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics4_Vtbl {
        unsafe extern "system" fn TextWrappingProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLinesProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalContentAlignmentProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalContentAlignmentProperty<Impl: IContentPresenterStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics4, BASE_OFFSET>(),
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
            LineStackingStrategyProperty: LineStackingStrategyProperty::<Impl, IMPL_OFFSET>,
            LineHeightProperty: LineHeightProperty::<Impl, IMPL_OFFSET>,
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignmentProperty: HorizontalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalContentAlignmentProperty: VerticalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics5_Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContentPresenterStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContentPresenterStatics5_Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IContentPresenterStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContentPresenterStatics5, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContentPresenterStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContextMenuEventArgs_Impl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CursorLeft(&mut self) -> ::windows::core::Result<f64>;
    fn CursorTop(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContextMenuEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContextMenuEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContextMenuEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IContextMenuEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IContextMenuEventArgs_Vtbl {
        unsafe extern "system" fn Handled<Impl: IContextMenuEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IContextMenuEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn CursorLeft<Impl: IContextMenuEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CursorLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CursorTop<Impl: IContextMenuEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CursorTop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IContextMenuEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
            CursorLeft: CursorLeft::<Impl, IMPL_OFFSET>,
            CursorTop: CursorTop::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IContextMenuEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IControl_Impl: Sized {
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IsTabStop(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTabStop(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TabIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetTabIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TabNavigation(&mut self) -> ::windows::core::Result<super::Input::KeyboardNavigationMode>;
    fn SetTabNavigation(&mut self, value: super::Input::KeyboardNavigationMode) -> ::windows::core::Result<()>;
    fn Template(&mut self) -> ::windows::core::Result<ControlTemplate>;
    fn SetTemplate(&mut self, value: &::core::option::Option<ControlTemplate>) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn HorizontalContentAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalContentAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalContentAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalContentAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn FocusState(&mut self) -> ::windows::core::Result<super::FocusState>;
    fn IsEnabledChanged(&mut self, handler: &::core::option::Option<super::DependencyPropertyChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsEnabledChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ApplyTemplate(&mut self) -> ::windows::core::Result<bool>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl";
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl_Vtbl {
        unsafe extern "system" fn FontSize<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTabStop<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTabStop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTabStop<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTabStop(value).into()
        }
        unsafe extern "system" fn IsEnabled<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsEnabled<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsEnabled(value).into()
        }
        unsafe extern "system" fn TabIndex<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabIndex<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTabIndex(value).into()
        }
        unsafe extern "system" fn TabNavigation<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Input::KeyboardNavigationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabNavigation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabNavigation<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Input::KeyboardNavigationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTabNavigation(value).into()
        }
        unsafe extern "system" fn Template<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Template() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTemplate<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTemplate(&*(&value as *const <ControlTemplate as ::windows::core::Abi>::Abi as *const <ControlTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalContentAlignment<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalContentAlignment<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalContentAlignment(value).into()
        }
        unsafe extern "system" fn VerticalContentAlignment<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalContentAlignment<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalContentAlignment(value).into()
        }
        unsafe extern "system" fn Background<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderBrush<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusState<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::FocusState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnabledChanged<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEnabledChanged(&*(&handler as *const <super::DependencyPropertyChangedEventHandler as ::windows::core::Abi>::Abi as *const <super::DependencyPropertyChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsEnabledChanged<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsEnabledChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ApplyTemplate<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ApplyTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl, BASE_OFFSET>(),
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            IsTabStop: IsTabStop::<Impl, IMPL_OFFSET>,
            SetIsTabStop: SetIsTabStop::<Impl, IMPL_OFFSET>,
            IsEnabled: IsEnabled::<Impl, IMPL_OFFSET>,
            SetIsEnabled: SetIsEnabled::<Impl, IMPL_OFFSET>,
            TabIndex: TabIndex::<Impl, IMPL_OFFSET>,
            SetTabIndex: SetTabIndex::<Impl, IMPL_OFFSET>,
            TabNavigation: TabNavigation::<Impl, IMPL_OFFSET>,
            SetTabNavigation: SetTabNavigation::<Impl, IMPL_OFFSET>,
            Template: Template::<Impl, IMPL_OFFSET>,
            SetTemplate: SetTemplate::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignment: HorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalContentAlignment: SetHorizontalContentAlignment::<Impl, IMPL_OFFSET>,
            VerticalContentAlignment: VerticalContentAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalContentAlignment: SetVerticalContentAlignment::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            FocusState: FocusState::<Impl, IMPL_OFFSET>,
            IsEnabledChanged: IsEnabledChanged::<Impl, IMPL_OFFSET>,
            RemoveIsEnabledChanged: RemoveIsEnabledChanged::<Impl, IMPL_OFFSET>,
            ApplyTemplate: ApplyTemplate::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl2_Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl2_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl2, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl3_Impl: Sized {
    fn UseSystemFocusVisuals(&mut self) -> ::windows::core::Result<bool>;
    fn SetUseSystemFocusVisuals(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl3";
}
#[cfg(feature = "implement_exclusive")]
impl IControl3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl3_Vtbl {
        unsafe extern "system" fn UseSystemFocusVisuals<Impl: IControl3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseSystemFocusVisuals() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseSystemFocusVisuals<Impl: IControl3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseSystemFocusVisuals(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl3, BASE_OFFSET>(),
            UseSystemFocusVisuals: UseSystemFocusVisuals::<Impl, IMPL_OFFSET>,
            SetUseSystemFocusVisuals: SetUseSystemFocusVisuals::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IControl4_Impl: Sized {
    fn IsFocusEngagementEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFocusEngagementEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFocusEngaged(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFocusEngaged(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn RequiresPointer(&mut self) -> ::windows::core::Result<RequiresPointer>;
    fn SetRequiresPointer(&mut self, value: RequiresPointer) -> ::windows::core::Result<()>;
    fn XYFocusLeft(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusLeft(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusRight(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusRight(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusUp(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusUp(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusDown(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusDown(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn ElementSoundMode(&mut self) -> ::windows::core::Result<super::ElementSoundMode>;
    fn SetElementSoundMode(&mut self, value: super::ElementSoundMode) -> ::windows::core::Result<()>;
    fn FocusEngaged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFocusEngaged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FocusDisengaged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFocusDisengaged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RemoveFocusEngagement(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControl4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IControl4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl4_Vtbl {
        unsafe extern "system" fn IsFocusEngagementEnabled<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagementEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFocusEngagementEnabled<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFocusEngagementEnabled(value).into()
        }
        unsafe extern "system" fn IsFocusEngaged<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngaged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFocusEngaged<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFocusEngaged(value).into()
        }
        unsafe extern "system" fn RequiresPointer<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RequiresPointer) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RequiresPointer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRequiresPointer<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RequiresPointer) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRequiresPointer(value).into()
        }
        unsafe extern "system" fn XYFocusLeft<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusLeft<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusLeft(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusRight<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusRight<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusRight(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusUp<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusUp<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusUp(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusDown<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusDown<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusDown(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ElementSoundMode<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::ElementSoundMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ElementSoundMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetElementSoundMode<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::ElementSoundMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetElementSoundMode(value).into()
        }
        unsafe extern "system" fn FocusEngaged<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusEngaged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFocusEngaged<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFocusEngaged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusDisengaged<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusDisengaged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFocusDisengaged<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFocusDisengaged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveFocusEngagement<Impl: IControl4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFocusEngagement().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl4, BASE_OFFSET>(),
            IsFocusEngagementEnabled: IsFocusEngagementEnabled::<Impl, IMPL_OFFSET>,
            SetIsFocusEngagementEnabled: SetIsFocusEngagementEnabled::<Impl, IMPL_OFFSET>,
            IsFocusEngaged: IsFocusEngaged::<Impl, IMPL_OFFSET>,
            SetIsFocusEngaged: SetIsFocusEngaged::<Impl, IMPL_OFFSET>,
            RequiresPointer: RequiresPointer::<Impl, IMPL_OFFSET>,
            SetRequiresPointer: SetRequiresPointer::<Impl, IMPL_OFFSET>,
            XYFocusLeft: XYFocusLeft::<Impl, IMPL_OFFSET>,
            SetXYFocusLeft: SetXYFocusLeft::<Impl, IMPL_OFFSET>,
            XYFocusRight: XYFocusRight::<Impl, IMPL_OFFSET>,
            SetXYFocusRight: SetXYFocusRight::<Impl, IMPL_OFFSET>,
            XYFocusUp: XYFocusUp::<Impl, IMPL_OFFSET>,
            SetXYFocusUp: SetXYFocusUp::<Impl, IMPL_OFFSET>,
            XYFocusDown: XYFocusDown::<Impl, IMPL_OFFSET>,
            SetXYFocusDown: SetXYFocusDown::<Impl, IMPL_OFFSET>,
            ElementSoundMode: ElementSoundMode::<Impl, IMPL_OFFSET>,
            SetElementSoundMode: SetElementSoundMode::<Impl, IMPL_OFFSET>,
            FocusEngaged: FocusEngaged::<Impl, IMPL_OFFSET>,
            RemoveFocusEngaged: RemoveFocusEngaged::<Impl, IMPL_OFFSET>,
            FocusDisengaged: FocusDisengaged::<Impl, IMPL_OFFSET>,
            RemoveFocusDisengaged: RemoveFocusDisengaged::<Impl, IMPL_OFFSET>,
            RemoveFocusEngagement: RemoveFocusEngagement::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IControl5_Impl: Sized {
    fn DefaultStyleResourceUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetDefaultStyleResourceUri(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControl5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl5";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IControl5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl5_Vtbl {
        unsafe extern "system" fn DefaultStyleResourceUri<Impl: IControl5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleResourceUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultStyleResourceUri<Impl: IControl5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultStyleResourceUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl5, BASE_OFFSET>(),
            DefaultStyleResourceUri: DefaultStyleResourceUri::<Impl, IMPL_OFFSET>,
            SetDefaultStyleResourceUri: SetDefaultStyleResourceUri::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl7_Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl7";
}
#[cfg(feature = "implement_exclusive")]
impl IControl7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControl7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControl7_Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IControl7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IControl7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IControl7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IControl7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControl7, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControl7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Control>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IControlFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IControlFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IControlFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IControlOverrides_Impl: Sized {
    fn OnPointerEntered(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerPressed(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerMoved(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerReleased(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerExited(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerCaptureLost(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerCanceled(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerWheelChanged(&mut self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnTapped(&mut self, e: &::core::option::Option<super::Input::TappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnDoubleTapped(&mut self, e: &::core::option::Option<super::Input::DoubleTappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnHolding(&mut self, e: &::core::option::Option<super::Input::HoldingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnRightTapped(&mut self, e: &::core::option::Option<super::Input::RightTappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationStarting(&mut self, e: &::core::option::Option<super::Input::ManipulationStartingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationInertiaStarting(&mut self, e: &::core::option::Option<super::Input::ManipulationInertiaStartingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationStarted(&mut self, e: &::core::option::Option<super::Input::ManipulationStartedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationDelta(&mut self, e: &::core::option::Option<super::Input::ManipulationDeltaRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationCompleted(&mut self, e: &::core::option::Option<super::Input::ManipulationCompletedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnKeyUp(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnKeyDown(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnGotFocus(&mut self, e: &::core::option::Option<super::RoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnLostFocus(&mut self, e: &::core::option::Option<super::RoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragEnter(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragLeave(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragOver(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDrop(&mut self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlOverrides";
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IControlOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlOverrides_Vtbl {
        unsafe extern "system" fn OnPointerEntered<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerEntered(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerPressed<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerPressed(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerMoved<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerMoved(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerReleased<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerReleased(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerExited<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerExited(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerCaptureLost<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerCaptureLost(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerCanceled<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerCanceled(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerWheelChanged<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPointerWheelChanged(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnTapped<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnTapped(&*(&e as *const <super::Input::TappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::TappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDoubleTapped<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDoubleTapped(&*(&e as *const <super::Input::DoubleTappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::DoubleTappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnHolding<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnHolding(&*(&e as *const <super::Input::HoldingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::HoldingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnRightTapped<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnRightTapped(&*(&e as *const <super::Input::RightTappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::RightTappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationStarting<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationStarting(&*(&e as *const <super::Input::ManipulationStartingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationStartingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationInertiaStarting<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationInertiaStarting(&*(&e as *const <super::Input::ManipulationInertiaStartingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationInertiaStartingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationStarted<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationStarted(&*(&e as *const <super::Input::ManipulationStartedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationStartedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationDelta<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationDelta(&*(&e as *const <super::Input::ManipulationDeltaRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationDeltaRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationCompleted<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnManipulationCompleted(&*(&e as *const <super::Input::ManipulationCompletedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationCompletedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnKeyUp<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnKeyUp(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnKeyDown<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnKeyDown(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnGotFocus<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnGotFocus(&*(&e as *const <super::RoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::RoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnLostFocus<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnLostFocus(&*(&e as *const <super::RoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::RoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragEnter<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDragEnter(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragLeave<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDragLeave(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragOver<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDragOver(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDrop<Impl: IControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDrop(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlOverrides, BASE_OFFSET>(),
            OnPointerEntered: OnPointerEntered::<Impl, IMPL_OFFSET>,
            OnPointerPressed: OnPointerPressed::<Impl, IMPL_OFFSET>,
            OnPointerMoved: OnPointerMoved::<Impl, IMPL_OFFSET>,
            OnPointerReleased: OnPointerReleased::<Impl, IMPL_OFFSET>,
            OnPointerExited: OnPointerExited::<Impl, IMPL_OFFSET>,
            OnPointerCaptureLost: OnPointerCaptureLost::<Impl, IMPL_OFFSET>,
            OnPointerCanceled: OnPointerCanceled::<Impl, IMPL_OFFSET>,
            OnPointerWheelChanged: OnPointerWheelChanged::<Impl, IMPL_OFFSET>,
            OnTapped: OnTapped::<Impl, IMPL_OFFSET>,
            OnDoubleTapped: OnDoubleTapped::<Impl, IMPL_OFFSET>,
            OnHolding: OnHolding::<Impl, IMPL_OFFSET>,
            OnRightTapped: OnRightTapped::<Impl, IMPL_OFFSET>,
            OnManipulationStarting: OnManipulationStarting::<Impl, IMPL_OFFSET>,
            OnManipulationInertiaStarting: OnManipulationInertiaStarting::<Impl, IMPL_OFFSET>,
            OnManipulationStarted: OnManipulationStarted::<Impl, IMPL_OFFSET>,
            OnManipulationDelta: OnManipulationDelta::<Impl, IMPL_OFFSET>,
            OnManipulationCompleted: OnManipulationCompleted::<Impl, IMPL_OFFSET>,
            OnKeyUp: OnKeyUp::<Impl, IMPL_OFFSET>,
            OnKeyDown: OnKeyDown::<Impl, IMPL_OFFSET>,
            OnGotFocus: OnGotFocus::<Impl, IMPL_OFFSET>,
            OnLostFocus: OnLostFocus::<Impl, IMPL_OFFSET>,
            OnDragEnter: OnDragEnter::<Impl, IMPL_OFFSET>,
            OnDragLeave: OnDragLeave::<Impl, IMPL_OFFSET>,
            OnDragOver: OnDragOver::<Impl, IMPL_OFFSET>,
            OnDrop: OnDrop::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IControlOverrides6_Impl: Sized {
    fn OnPreviewKeyDown(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPreviewKeyUp(&mut self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnCharacterReceived(&mut self, e: &::core::option::Option<super::Input::CharacterReceivedRoutedEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControlOverrides6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlOverrides6";
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IControlOverrides6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlOverrides6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlOverrides6_Vtbl {
        unsafe extern "system" fn OnPreviewKeyDown<Impl: IControlOverrides6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPreviewKeyDown(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPreviewKeyUp<Impl: IControlOverrides6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPreviewKeyUp(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnCharacterReceived<Impl: IControlOverrides6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnCharacterReceived(&*(&e as *const <super::Input::CharacterReceivedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::CharacterReceivedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlOverrides6, BASE_OFFSET>(),
            OnPreviewKeyDown: OnPreviewKeyDown::<Impl, IMPL_OFFSET>,
            OnPreviewKeyUp: OnPreviewKeyUp::<Impl, IMPL_OFFSET>,
            OnCharacterReceived: OnCharacterReceived::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlOverrides6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlProtected_Impl: Sized {
    fn DefaultStyleKey(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDefaultStyleKey(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn GetTemplateChild(&mut self, childname: &::windows::core::HSTRING) -> ::windows::core::Result<super::DependencyObject>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlProtected {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlProtected";
}
#[cfg(feature = "implement_exclusive")]
impl IControlProtected_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlProtected_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlProtected_Vtbl {
        unsafe extern "system" fn DefaultStyleKey<Impl: IControlProtected_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleKey() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultStyleKey<Impl: IControlProtected_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultStyleKey(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetTemplateChild<Impl: IControlProtected_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, childname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTemplateChild(&*(&childname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlProtected, BASE_OFFSET>(),
            DefaultStyleKey: DefaultStyleKey::<Impl, IMPL_OFFSET>,
            SetDefaultStyleKey: SetDefaultStyleKey::<Impl, IMPL_OFFSET>,
            GetTemplateChild: GetTemplateChild::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlProtected as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics_Impl: Sized {
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTabStopProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TabIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TabNavigationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalContentAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultStyleKeyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusStateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics_Vtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTabStopProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTabStopProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnabledProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TabIndexProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TabNavigationProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabNavigationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalContentAlignmentProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalContentAlignmentProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultStyleKeyProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleKeyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusStateProperty<Impl: IControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusStateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics, BASE_OFFSET>(),
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            IsTabStopProperty: IsTabStopProperty::<Impl, IMPL_OFFSET>,
            IsEnabledProperty: IsEnabledProperty::<Impl, IMPL_OFFSET>,
            TabIndexProperty: TabIndexProperty::<Impl, IMPL_OFFSET>,
            TabNavigationProperty: TabNavigationProperty::<Impl, IMPL_OFFSET>,
            TemplateProperty: TemplateProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            HorizontalContentAlignmentProperty: HorizontalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalContentAlignmentProperty: VerticalContentAlignmentProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            DefaultStyleKeyProperty: DefaultStyleKeyProperty::<Impl, IMPL_OFFSET>,
            FocusStateProperty: FocusStateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics2_Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics2_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IControlStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics2, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics3_Impl: Sized {
    fn UseSystemFocusVisualsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTemplateFocusTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsTemplateFocusTarget(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<bool>;
    fn SetIsTemplateFocusTarget(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics3_Vtbl {
        unsafe extern "system" fn UseSystemFocusVisualsProperty<Impl: IControlStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseSystemFocusVisualsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTemplateFocusTargetProperty<Impl: IControlStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTemplateFocusTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsTemplateFocusTarget<Impl: IControlStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsTemplateFocusTarget(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTemplateFocusTarget<Impl: IControlStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTemplateFocusTarget(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics3, BASE_OFFSET>(),
            UseSystemFocusVisualsProperty: UseSystemFocusVisualsProperty::<Impl, IMPL_OFFSET>,
            IsTemplateFocusTargetProperty: IsTemplateFocusTargetProperty::<Impl, IMPL_OFFSET>,
            GetIsTemplateFocusTarget: GetIsTemplateFocusTarget::<Impl, IMPL_OFFSET>,
            SetIsTemplateFocusTarget: SetIsTemplateFocusTarget::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics4_Impl: Sized {
    fn IsFocusEngagementEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFocusEngagedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RequiresPointerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusRightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusUpProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusDownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ElementSoundModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics4_Vtbl {
        unsafe extern "system" fn IsFocusEngagementEnabledProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagementEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFocusEngagedProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequiresPointerProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RequiresPointerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusLeftProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusRightProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusUpProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUpProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusDownProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ElementSoundModeProperty<Impl: IControlStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ElementSoundModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics4, BASE_OFFSET>(),
            IsFocusEngagementEnabledProperty: IsFocusEngagementEnabledProperty::<Impl, IMPL_OFFSET>,
            IsFocusEngagedProperty: IsFocusEngagedProperty::<Impl, IMPL_OFFSET>,
            RequiresPointerProperty: RequiresPointerProperty::<Impl, IMPL_OFFSET>,
            XYFocusLeftProperty: XYFocusLeftProperty::<Impl, IMPL_OFFSET>,
            XYFocusRightProperty: XYFocusRightProperty::<Impl, IMPL_OFFSET>,
            XYFocusUpProperty: XYFocusUpProperty::<Impl, IMPL_OFFSET>,
            XYFocusDownProperty: XYFocusDownProperty::<Impl, IMPL_OFFSET>,
            ElementSoundModeProperty: ElementSoundModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics5_Impl: Sized {
    fn DefaultStyleResourceUriProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTemplateKeyTipTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsTemplateKeyTipTarget(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsTemplateKeyTipTarget(&mut self, element: &::core::option::Option<super::DependencyObject>, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics5_Vtbl {
        unsafe extern "system" fn DefaultStyleResourceUriProperty<Impl: IControlStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultStyleResourceUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTemplateKeyTipTargetProperty<Impl: IControlStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTemplateKeyTipTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsTemplateKeyTipTarget<Impl: IControlStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsTemplateKeyTipTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTemplateKeyTipTarget<Impl: IControlStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTemplateKeyTipTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics5, BASE_OFFSET>(),
            DefaultStyleResourceUriProperty: DefaultStyleResourceUriProperty::<Impl, IMPL_OFFSET>,
            IsTemplateKeyTipTargetProperty: IsTemplateKeyTipTargetProperty::<Impl, IMPL_OFFSET>,
            GetIsTemplateKeyTipTarget: GetIsTemplateKeyTipTarget::<Impl, IMPL_OFFSET>,
            SetIsTemplateKeyTipTarget: SetIsTemplateKeyTipTarget::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics7_Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlStatics7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlStatics7_Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IControlStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IControlStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlStatics7, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "implement_exclusive"))]
pub trait IControlTemplate_Impl: Sized {
    fn TargetType(&mut self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SetTargetType(&mut self, value: &super::Interop::TypeName) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IControlTemplate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlTemplate";
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "implement_exclusive"))]
impl IControlTemplate_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IControlTemplate_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IControlTemplate_Vtbl {
        unsafe extern "system" fn TargetType<Impl: IControlTemplate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetType<Impl: IControlTemplate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTargetType(&*(&value as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IControlTemplate, BASE_OFFSET>(),
            TargetType: TargetType::<Impl, IMPL_OFFSET>,
            SetTargetType: SetTargetType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IControlTemplate as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelector_Impl: Sized {
    fn SelectTemplate(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelector_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelector_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelector_Vtbl {
        unsafe extern "system" fn SelectTemplate<Impl: IDataTemplateSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplate(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelector, BASE_OFFSET>(),
            SelectTemplate: SelectTemplate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelector as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelector2_Impl: Sized {
    fn SelectTemplateForItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelector2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelector2";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelector2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelector2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelector2_Vtbl {
        unsafe extern "system" fn SelectTemplateForItem<Impl: IDataTemplateSelector2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplateForItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelector2, BASE_OFFSET>(),
            SelectTemplateForItem: SelectTemplateForItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelector2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DataTemplateSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelectorFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelectorFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDataTemplateSelectorFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelectorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelectorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorOverrides_Impl: Sized {
    fn SelectTemplateCore(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelectorOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelectorOverrides_Vtbl {
        unsafe extern "system" fn SelectTemplateCore<Impl: IDataTemplateSelectorOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplateCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelectorOverrides, BASE_OFFSET>(),
            SelectTemplateCore: SelectTemplateCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelectorOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorOverrides2_Impl: Sized {
    fn SelectTemplateForItemCore(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorOverrides2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides2";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorOverrides2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDataTemplateSelectorOverrides2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDataTemplateSelectorOverrides2_Vtbl {
        unsafe extern "system" fn SelectTemplateForItemCore<Impl: IDataTemplateSelectorOverrides2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectTemplateForItemCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDataTemplateSelectorOverrides2, BASE_OFFSET>(),
            SelectTemplateForItemCore: SelectTemplateForItemCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDataTemplateSelectorOverrides2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickedEventArgs_Impl: Sized {
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickedEventArgs_Vtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickedEventArgs, BASE_OFFSET>(),
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePicker_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DayVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetDayVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MonthVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetMonthVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn YearVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetYearVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DayFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MonthFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetMonthFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn YearFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetYearFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MinYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn DateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePicker_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePicker_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePicker_Vtbl {
        unsafe extern "system" fn Header<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarIdentifier<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Date<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayVisible<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayVisible<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayVisible(value).into()
        }
        unsafe extern "system" fn MonthVisible<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthVisible<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthVisible(value).into()
        }
        unsafe extern "system" fn YearVisible<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearVisible<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearVisible(value).into()
        }
        unsafe extern "system" fn DayFormat<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayFormat<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthFormat<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthFormat<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn YearFormat<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearFormat<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinYear<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinYear<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxYear<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxYear<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn DateChanged<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDateChanged<Impl: IDatePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePicker, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDate: SetDate::<Impl, IMPL_OFFSET>,
            DayVisible: DayVisible::<Impl, IMPL_OFFSET>,
            SetDayVisible: SetDayVisible::<Impl, IMPL_OFFSET>,
            MonthVisible: MonthVisible::<Impl, IMPL_OFFSET>,
            SetMonthVisible: SetMonthVisible::<Impl, IMPL_OFFSET>,
            YearVisible: YearVisible::<Impl, IMPL_OFFSET>,
            SetYearVisible: SetYearVisible::<Impl, IMPL_OFFSET>,
            DayFormat: DayFormat::<Impl, IMPL_OFFSET>,
            SetDayFormat: SetDayFormat::<Impl, IMPL_OFFSET>,
            MonthFormat: MonthFormat::<Impl, IMPL_OFFSET>,
            SetMonthFormat: SetMonthFormat::<Impl, IMPL_OFFSET>,
            YearFormat: YearFormat::<Impl, IMPL_OFFSET>,
            SetYearFormat: SetYearFormat::<Impl, IMPL_OFFSET>,
            MinYear: MinYear::<Impl, IMPL_OFFSET>,
            SetMinYear: SetMinYear::<Impl, IMPL_OFFSET>,
            MaxYear: MaxYear::<Impl, IMPL_OFFSET>,
            SetMaxYear: SetMaxYear::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            DateChanged: DateChanged::<Impl, IMPL_OFFSET>,
            RemoveDateChanged: RemoveDateChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePicker2_Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePicker2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePicker2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePicker2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IDatePicker2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IDatePicker2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePicker2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePicker2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePicker3_Impl: Sized {
    fn SelectedDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn SetSelectedDate(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>) -> ::windows::core::Result<()>;
    fn SelectedDateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedDateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePicker3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePicker3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePicker3_Vtbl {
        unsafe extern "system" fn SelectedDate<Impl: IDatePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDate<Impl: IDatePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedDate(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDateChanged<Impl: IDatePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedDateChanged<Impl: IDatePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectedDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePicker3, BASE_OFFSET>(),
            SelectedDate: SelectedDate::<Impl, IMPL_OFFSET>,
            SetSelectedDate: SetSelectedDate::<Impl, IMPL_OFFSET>,
            SelectedDateChanged: SelectedDateChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectedDateChanged: RemoveSelectedDateChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePicker3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DatePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDatePickerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickerFlyout_Impl: Sized {
    fn CalendarIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Date(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDate(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DayVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetDayVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MonthVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetMonthVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn YearVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetYearVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MinYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxYear(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxYear(&mut self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DatePicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDatePicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickerFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyout_Vtbl {
        unsafe extern "system" fn CalendarIdentifier<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Date<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayVisible<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayVisible<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayVisible(value).into()
        }
        unsafe extern "system" fn MonthVisible<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthVisible<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthVisible(value).into()
        }
        unsafe extern "system" fn YearVisible<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearVisible<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearVisible(value).into()
        }
        unsafe extern "system" fn MinYear<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinYear<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxYear<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxYear<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DatePicked<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DatePicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDatePicked<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDatePicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IDatePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyout, BASE_OFFSET>(),
            CalendarIdentifier: CalendarIdentifier::<Impl, IMPL_OFFSET>,
            SetCalendarIdentifier: SetCalendarIdentifier::<Impl, IMPL_OFFSET>,
            Date: Date::<Impl, IMPL_OFFSET>,
            SetDate: SetDate::<Impl, IMPL_OFFSET>,
            DayVisible: DayVisible::<Impl, IMPL_OFFSET>,
            SetDayVisible: SetDayVisible::<Impl, IMPL_OFFSET>,
            MonthVisible: MonthVisible::<Impl, IMPL_OFFSET>,
            SetMonthVisible: SetMonthVisible::<Impl, IMPL_OFFSET>,
            YearVisible: YearVisible::<Impl, IMPL_OFFSET>,
            SetYearVisible: SetYearVisible::<Impl, IMPL_OFFSET>,
            MinYear: MinYear::<Impl, IMPL_OFFSET>,
            SetMinYear: SetMinYear::<Impl, IMPL_OFFSET>,
            MaxYear: MaxYear::<Impl, IMPL_OFFSET>,
            SetMaxYear: SetMaxYear::<Impl, IMPL_OFFSET>,
            DatePicked: DatePicked::<Impl, IMPL_OFFSET>,
            RemoveDatePicked: RemoveDatePicked::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyout2_Impl: Sized {
    fn DayFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MonthFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetMonthFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn YearFormat(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetYearFormat(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyout2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyout2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyout2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyout2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyout2_Vtbl {
        unsafe extern "system" fn DayFormat<Impl: IDatePickerFlyout2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayFormat<Impl: IDatePickerFlyout2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDayFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthFormat<Impl: IDatePickerFlyout2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthFormat<Impl: IDatePickerFlyout2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonthFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn YearFormat<Impl: IDatePickerFlyout2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearFormat<Impl: IDatePickerFlyout2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetYearFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyout2, BASE_OFFSET>(),
            DayFormat: DayFormat::<Impl, IMPL_OFFSET>,
            SetDayFormat: SetDayFormat::<Impl, IMPL_OFFSET>,
            MonthFormat: MonthFormat::<Impl, IMPL_OFFSET>,
            SetMonthFormat: SetMonthFormat::<Impl, IMPL_OFFSET>,
            YearFormat: YearFormat::<Impl, IMPL_OFFSET>,
            SetYearFormat: SetYearFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyout2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutItem_Impl: Sized {
    fn PrimaryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPrimaryText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SecondaryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSecondaryText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutItem_Vtbl {
        unsafe extern "system" fn PrimaryText<Impl: IDatePickerFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryText<Impl: IDatePickerFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrimaryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryText<Impl: IDatePickerFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryText<Impl: IDatePickerFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSecondaryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutItem, BASE_OFFSET>(),
            PrimaryText: PrimaryText::<Impl, IMPL_OFFSET>,
            SetPrimaryText: SetPrimaryText::<Impl, IMPL_OFFSET>,
            SecondaryText: SecondaryText::<Impl, IMPL_OFFSET>,
            SetSecondaryText: SetSecondaryText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutItemStatics_Impl: Sized {
    fn PrimaryTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutItemStatics_Vtbl {
        unsafe extern "system" fn PrimaryTextProperty<Impl: IDatePickerFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrimaryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryTextProperty<Impl: IDatePickerFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SecondaryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutItemStatics, BASE_OFFSET>(),
            PrimaryTextProperty: PrimaryTextProperty::<Impl, IMPL_OFFSET>,
            SecondaryTextProperty: SecondaryTextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenter_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutPresenter_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenter2_Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutPresenter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutPresenter2_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IDatePickerFlyoutPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IDatePickerFlyoutPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutPresenter2, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenterStatics2_Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenterStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutPresenterStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutPresenterStatics2_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IDatePickerFlyoutPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutPresenterStatics2, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutStatics_Impl: Sized {
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutStatics_Vtbl {
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: IDatePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: IDatePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayVisibleProperty<Impl: IDatePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthVisibleProperty<Impl: IDatePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearVisibleProperty<Impl: IDatePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinYearProperty<Impl: IDatePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxYearProperty<Impl: IDatePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutStatics, BASE_OFFSET>(),
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
            DayVisibleProperty: DayVisibleProperty::<Impl, IMPL_OFFSET>,
            MonthVisibleProperty: MonthVisibleProperty::<Impl, IMPL_OFFSET>,
            YearVisibleProperty: YearVisibleProperty::<Impl, IMPL_OFFSET>,
            MinYearProperty: MinYearProperty::<Impl, IMPL_OFFSET>,
            MaxYearProperty: MaxYearProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutStatics2_Impl: Sized {
    fn DayFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerFlyoutStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerFlyoutStatics2_Vtbl {
        unsafe extern "system" fn DayFormatProperty<Impl: IDatePickerFlyoutStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthFormatProperty<Impl: IDatePickerFlyoutStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearFormatProperty<Impl: IDatePickerFlyoutStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerFlyoutStatics2, BASE_OFFSET>(),
            DayFormatProperty: DayFormatProperty::<Impl, IMPL_OFFSET>,
            MonthFormatProperty: MonthFormatProperty::<Impl, IMPL_OFFSET>,
            YearFormatProperty: YearFormatProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerFlyoutStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickerSelectedValueChangedEventArgs_Impl: Sized {
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickerSelectedValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerSelectedValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickerSelectedValueChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerSelectedValueChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerSelectedValueChangedEventArgs_Vtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickerSelectedValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickerSelectedValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerSelectedValueChangedEventArgs, BASE_OFFSET>(),
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerSelectedValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStatics_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxYearProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerStatics_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayVisibleProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthVisibleProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearVisibleProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayFormatProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DayFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthFormatProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MonthFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearFormatProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).YearFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinYearProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxYearProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IDatePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            CalendarIdentifierProperty: CalendarIdentifierProperty::<Impl, IMPL_OFFSET>,
            DateProperty: DateProperty::<Impl, IMPL_OFFSET>,
            DayVisibleProperty: DayVisibleProperty::<Impl, IMPL_OFFSET>,
            MonthVisibleProperty: MonthVisibleProperty::<Impl, IMPL_OFFSET>,
            YearVisibleProperty: YearVisibleProperty::<Impl, IMPL_OFFSET>,
            DayFormatProperty: DayFormatProperty::<Impl, IMPL_OFFSET>,
            MonthFormatProperty: MonthFormatProperty::<Impl, IMPL_OFFSET>,
            YearFormatProperty: YearFormatProperty::<Impl, IMPL_OFFSET>,
            MinYearProperty: MinYearProperty::<Impl, IMPL_OFFSET>,
            MaxYearProperty: MaxYearProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStatics2_Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerStatics2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IDatePickerStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStatics3_Impl: Sized {
    fn SelectedDateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerStatics3_Vtbl {
        unsafe extern "system" fn SelectedDateProperty<Impl: IDatePickerStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerStatics3, BASE_OFFSET>(),
            SelectedDateProperty: SelectedDateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IDatePickerValueChangedEventArgs_Impl: Sized {
    fn OldDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn NewDate(&mut self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDatePickerValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IDatePickerValueChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDatePickerValueChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDatePickerValueChangedEventArgs_Vtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickerValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickerValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDatePickerValueChangedEventArgs, BASE_OFFSET>(),
            OldDate: OldDate::<Impl, IMPL_OFFSET>,
            NewDate: NewDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDatePickerValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IDragItemsCompletedEventArgs_Impl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>;
    fn DropResult(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackageOperation>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDragItemsCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDragItemsCompletedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IDragItemsCompletedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDragItemsCompletedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDragItemsCompletedEventArgs_Vtbl {
        unsafe extern "system" fn Items<Impl: IDragItemsCompletedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropResult<Impl: IDragItemsCompletedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::ApplicationModel::DataTransfer::DataPackageOperation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropResult() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDragItemsCompletedEventArgs, BASE_OFFSET>(),
            Items: Items::<Impl, IMPL_OFFSET>,
            DropResult: DropResult::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDragItemsCompletedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IDragItemsStartingEventArgs_Impl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn Data(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IDragItemsStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IDragItemsStartingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDragItemsStartingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDragItemsStartingEventArgs_Vtbl {
        unsafe extern "system" fn Cancel<Impl: IDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn Items<Impl: IDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Data<Impl: IDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDragItemsStartingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
            Data: Data::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDragItemsStartingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButton_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButton";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButton_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonAutomationPeer_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonAutomationPeer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButtonAutomationPeer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButtonAutomationPeer_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButtonAutomationPeer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButtonAutomationPeer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonAutomationPeerFactory_Impl: Sized {
    fn CreateInstance(&mut self, owner: &::core::option::Option<DropDownButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DropDownButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonAutomationPeerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButtonAutomationPeerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButtonAutomationPeerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDropDownButtonAutomationPeerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <DropDownButton as ::windows::core::Abi>::Abi as *const <DropDownButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButtonAutomationPeerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButtonAutomationPeerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DropDownButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDropDownButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDropDownButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDropDownButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDropDownButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDropDownButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDynamicOverflowItemsChangingEventArgs_Impl: Sized {
    fn Action(&mut self) -> ::windows::core::Result<CommandBarDynamicOverflowAction>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDynamicOverflowItemsChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDynamicOverflowItemsChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDynamicOverflowItemsChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDynamicOverflowItemsChangingEventArgs_Vtbl {
        unsafe extern "system" fn Action<Impl: IDynamicOverflowItemsChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarDynamicOverflowAction) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Action() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IDynamicOverflowItemsChangingEventArgs, BASE_OFFSET>(),
            Action: Action::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDynamicOverflowItemsChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipView_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipView";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipView_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipView, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipView2_Impl: Sized {
    fn UseTouchAnimationsForAllNavigation(&mut self) -> ::windows::core::Result<bool>;
    fn SetUseTouchAnimationsForAllNavigation(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipView2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipView2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipView2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipView2_Vtbl {
        unsafe extern "system" fn UseTouchAnimationsForAllNavigation<Impl: IFlipView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseTouchAnimationsForAllNavigation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseTouchAnimationsForAllNavigation<Impl: IFlipView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseTouchAnimationsForAllNavigation(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipView2, BASE_OFFSET>(),
            UseTouchAnimationsForAllNavigation: UseTouchAnimationsForAllNavigation::<Impl, IMPL_OFFSET>,
            SetUseTouchAnimationsForAllNavigation: SetUseTouchAnimationsForAllNavigation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlipView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlipViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewItem_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewItem_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlipViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlipViewItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewStatics2_Impl: Sized {
    fn UseTouchAnimationsForAllNavigationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlipViewStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlipViewStatics2_Vtbl {
        unsafe extern "system" fn UseTouchAnimationsForAllNavigationProperty<Impl: IFlipViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseTouchAnimationsForAllNavigationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlipViewStatics2, BASE_OFFSET>(),
            UseTouchAnimationsForAllNavigationProperty: UseTouchAnimationsForAllNavigationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlipViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyout_Impl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn FlyoutPresenterStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetFlyoutPresenterStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyout_Vtbl {
        unsafe extern "system" fn Content<Impl: IFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FlyoutPresenterStyle<Impl: IFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyoutPresenterStyle<Impl: IFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlyoutPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyout, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            FlyoutPresenterStyle: FlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
            SetFlyoutPresenterStyle: SetFlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Flyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlyoutFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenter_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenter_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenter2_Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenter2_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IFlyoutPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IFlyoutPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenter2, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlyoutPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenterFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenterFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlyoutPresenterFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterStatics2_Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutPresenterStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutPresenterStatics2_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IFlyoutPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutPresenterStatics2, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutStatics_Impl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FlyoutPresenterStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFlyoutStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFlyoutStatics_Vtbl {
        unsafe extern "system" fn ContentProperty<Impl: IFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FlyoutPresenterStyleProperty<Impl: IFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFlyoutStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            FlyoutPresenterStyleProperty: FlyoutPresenterStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusDisengagedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusDisengagedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusDisengagedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusDisengagedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFocusDisengagedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFocusDisengagedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFocusDisengagedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFocusDisengagedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusEngagedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusEngagedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusEngagedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFocusEngagedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFocusEngagedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFocusEngagedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFocusEngagedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusEngagedEventArgs2_Impl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusEngagedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusEngagedEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFocusEngagedEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFocusEngagedEventArgs2_Vtbl {
        unsafe extern "system" fn Handled<Impl: IFocusEngagedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IFocusEngagedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFocusEngagedEventArgs2, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFocusEngagedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IFontIcon_Impl: Sized {
    fn Glyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFontIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon";
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IFontIcon_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIcon_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIcon_Vtbl {
        unsafe extern "system" fn Glyph<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IFontIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIcon, BASE_OFFSET>(),
            Glyph: Glyph::<Impl, IMPL_OFFSET>,
            SetGlyph: SetGlyph::<Impl, IMPL_OFFSET>,
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIcon2_Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIcon2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon2";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIcon2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIcon2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIcon2_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IFontIcon2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IFontIcon2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIcon2, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIcon2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIcon3_Impl: Sized {
    fn MirroredWhenRightToLeft(&mut self) -> ::windows::core::Result<bool>;
    fn SetMirroredWhenRightToLeft(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIcon3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon3";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIcon3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIcon3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIcon3_Vtbl {
        unsafe extern "system" fn MirroredWhenRightToLeft<Impl: IFontIcon3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirroredWhenRightToLeft<Impl: IFontIcon3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMirroredWhenRightToLeft(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIcon3, BASE_OFFSET>(),
            MirroredWhenRightToLeft: MirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
            SetMirroredWhenRightToLeft: SetMirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIcon3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FontIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFontIconFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IFontIconSource_Impl: Sized {
    fn Glyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MirroredWhenRightToLeft(&mut self) -> ::windows::core::Result<bool>;
    fn SetMirroredWhenRightToLeft(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFontIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSource";
}
#[cfg(all(feature = "UI_Text", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IFontIconSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconSource_Vtbl {
        unsafe extern "system" fn Glyph<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        unsafe extern "system" fn MirroredWhenRightToLeft<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirroredWhenRightToLeft<Impl: IFontIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMirroredWhenRightToLeft(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconSource, BASE_OFFSET>(),
            Glyph: Glyph::<Impl, IMPL_OFFSET>,
            SetGlyph: SetGlyph::<Impl, IMPL_OFFSET>,
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            MirroredWhenRightToLeft: MirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
            SetMirroredWhenRightToLeft: SetMirroredWhenRightToLeft::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconSourceFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FontIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconSourceFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconSourceFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconSourceFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFontIconSourceFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconSourceStatics_Impl: Sized {
    fn GlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MirroredWhenRightToLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconSourceStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconSourceStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconSourceStatics_Vtbl {
        unsafe extern "system" fn GlyphProperty<Impl: IFontIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IFontIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IFontIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IFontIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IFontIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IFontIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MirroredWhenRightToLeftProperty<Impl: IFontIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconSourceStatics, BASE_OFFSET>(),
            GlyphProperty: GlyphProperty::<Impl, IMPL_OFFSET>,
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
            MirroredWhenRightToLeftProperty: MirroredWhenRightToLeftProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStatics_Impl: Sized {
    fn GlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconStatics_Vtbl {
        unsafe extern "system" fn GlyphProperty<Impl: IFontIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IFontIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IFontIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IFontIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IFontIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconStatics, BASE_OFFSET>(),
            GlyphProperty: GlyphProperty::<Impl, IMPL_OFFSET>,
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStatics2_Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconStatics2_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IFontIconStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconStatics2, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStatics3_Impl: Sized {
    fn MirroredWhenRightToLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFontIconStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFontIconStatics3_Vtbl {
        unsafe extern "system" fn MirroredWhenRightToLeftProperty<Impl: IFontIconStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFontIconStatics3, BASE_OFFSET>(),
            MirroredWhenRightToLeftProperty: MirroredWhenRightToLeftProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFontIconStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IFrame_Impl: Sized {
    fn CacheSize(&mut self) -> ::windows::core::Result<i32>;
    fn SetCacheSize(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn CanGoBack(&mut self) -> ::windows::core::Result<bool>;
    fn CanGoForward(&mut self) -> ::windows::core::Result<bool>;
    fn CurrentSourcePageType(&mut self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SourcePageType(&mut self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SetSourcePageType(&mut self, value: &super::Interop::TypeName) -> ::windows::core::Result<()>;
    fn BackStackDepth(&mut self) -> ::windows::core::Result<i32>;
    fn Navigated(&mut self, handler: &::core::option::Option<super::Navigation::NavigatedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigated(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Navigating(&mut self, handler: &::core::option::Option<super::Navigation::NavigatingCancelEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigating(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationFailed(&mut self, handler: &::core::option::Option<super::Navigation::NavigationFailedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationStopped(&mut self, handler: &::core::option::Option<super::Navigation::NavigationStoppedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationStopped(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GoBack(&mut self) -> ::windows::core::Result<()>;
    fn GoForward(&mut self) -> ::windows::core::Result<()>;
    fn Navigate(&mut self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<bool>;
    fn GetNavigationState(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetNavigationState(&mut self, navigationstate: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IFrame_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame_Vtbl {
        unsafe extern "system" fn CacheSize<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheSize<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCacheSize(value).into()
        }
        unsafe extern "system" fn CanGoBack<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForward<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForward() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSourcePageType<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentSourcePageType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourcePageType<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourcePageType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourcePageType<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourcePageType(&*(&value as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackStackDepth<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStackDepth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigated<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigated(&*(&handler as *const <super::Navigation::NavigatedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigated<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigated(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Navigating<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigating(&*(&handler as *const <super::Navigation::NavigatingCancelEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatingCancelEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigating<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigating(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationFailed<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationFailed(&*(&handler as *const <super::Navigation::NavigationFailedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationFailedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationFailed<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationStopped<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationStopped(&*(&handler as *const <super::Navigation::NavigationStoppedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationStoppedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationStopped<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationStopped(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GoBack<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoBack().into()
        }
        unsafe extern "system" fn GoForward<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoForward().into()
        }
        unsafe extern "system" fn Navigate<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigate(&*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType), &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNavigationState<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNavigationState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigationState<Impl: IFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, navigationstate: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigationState(&*(&navigationstate as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame, BASE_OFFSET>(),
            CacheSize: CacheSize::<Impl, IMPL_OFFSET>,
            SetCacheSize: SetCacheSize::<Impl, IMPL_OFFSET>,
            CanGoBack: CanGoBack::<Impl, IMPL_OFFSET>,
            CanGoForward: CanGoForward::<Impl, IMPL_OFFSET>,
            CurrentSourcePageType: CurrentSourcePageType::<Impl, IMPL_OFFSET>,
            SourcePageType: SourcePageType::<Impl, IMPL_OFFSET>,
            SetSourcePageType: SetSourcePageType::<Impl, IMPL_OFFSET>,
            BackStackDepth: BackStackDepth::<Impl, IMPL_OFFSET>,
            Navigated: Navigated::<Impl, IMPL_OFFSET>,
            RemoveNavigated: RemoveNavigated::<Impl, IMPL_OFFSET>,
            Navigating: Navigating::<Impl, IMPL_OFFSET>,
            RemoveNavigating: RemoveNavigating::<Impl, IMPL_OFFSET>,
            NavigationFailed: NavigationFailed::<Impl, IMPL_OFFSET>,
            RemoveNavigationFailed: RemoveNavigationFailed::<Impl, IMPL_OFFSET>,
            NavigationStopped: NavigationStopped::<Impl, IMPL_OFFSET>,
            RemoveNavigationStopped: RemoveNavigationStopped::<Impl, IMPL_OFFSET>,
            GoBack: GoBack::<Impl, IMPL_OFFSET>,
            GoForward: GoForward::<Impl, IMPL_OFFSET>,
            Navigate: Navigate::<Impl, IMPL_OFFSET>,
            GetNavigationState: GetNavigationState::<Impl, IMPL_OFFSET>,
            SetNavigationState: SetNavigationState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Media_Animation", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IFrame2_Impl: Sized {
    fn BackStack(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Navigation::PageStackEntry>>;
    fn ForwardStack(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Navigation::PageStackEntry>>;
    fn Navigate(&mut self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>, infooverride: &::core::option::Option<super::Media::Animation::NavigationTransitionInfo>) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Media_Animation", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame2";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Interop", feature = "UI_Xaml_Media_Animation", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IFrame2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame2_Vtbl {
        unsafe extern "system" fn BackStack<Impl: IFrame2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForwardStack<Impl: IFrame2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForwardStack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigate<Impl: IFrame2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, infooverride: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigate(
                &*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType),
                &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&infooverride as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::Abi>::Abi as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame2, BASE_OFFSET>(),
            BackStack: BackStack::<Impl, IMPL_OFFSET>,
            ForwardStack: ForwardStack::<Impl, IMPL_OFFSET>,
            Navigate: Navigate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IFrame3_Impl: Sized {
    fn GoBack(&mut self, transitioninfooverride: &::core::option::Option<super::Media::Animation::NavigationTransitionInfo>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame3";
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IFrame3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame3_Vtbl {
        unsafe extern "system" fn GoBack<Impl: IFrame3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, transitioninfooverride: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoBack(&*(&transitioninfooverride as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::Abi>::Abi as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame3, BASE_OFFSET>(), GoBack: GoBack::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrame4_Impl: Sized {
    fn SetNavigationStateWithNavigationControl(&mut self, navigationstate: &::windows::core::HSTRING, suppressnavigate: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrame4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame4";
}
#[cfg(feature = "implement_exclusive")]
impl IFrame4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame4_Vtbl {
        unsafe extern "system" fn SetNavigationStateWithNavigationControl<Impl: IFrame4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, navigationstate: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, suppressnavigate: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigationStateWithNavigationControl(&*(&navigationstate as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), suppressnavigate).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame4, BASE_OFFSET>(),
            SetNavigationStateWithNavigationControl: SetNavigationStateWithNavigationControl::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IFrame5_Impl: Sized {
    fn IsNavigationStackEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsNavigationStackEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn NavigateToType(&mut self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>, navigationoptions: &::core::option::Option<super::Navigation::FrameNavigationOptions>) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IFrame5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame5";
}
#[cfg(all(feature = "UI_Xaml_Interop", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IFrame5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrame5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrame5_Vtbl {
        unsafe extern "system" fn IsNavigationStackEnabled<Impl: IFrame5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNavigationStackEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsNavigationStackEnabled<Impl: IFrame5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsNavigationStackEnabled(value).into()
        }
        unsafe extern "system" fn NavigateToType<Impl: IFrame5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, navigationoptions: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigateToType(
                &*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType),
                &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&navigationoptions as *const <super::Navigation::FrameNavigationOptions as ::windows::core::Abi>::Abi as *const <super::Navigation::FrameNavigationOptions as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrame5, BASE_OFFSET>(),
            IsNavigationStackEnabled: IsNavigationStackEnabled::<Impl, IMPL_OFFSET>,
            SetIsNavigationStackEnabled: SetIsNavigationStackEnabled::<Impl, IMPL_OFFSET>,
            NavigateToType: NavigateToType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrame5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Frame>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFrameFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStatics_Impl: Sized {
    fn CacheSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoBackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoForwardProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CurrentSourcePageTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourcePageTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackStackDepthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameStatics_Vtbl {
        unsafe extern "system" fn CacheSizeProperty<Impl: IFrameStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoBackProperty<Impl: IFrameStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForwardProperty<Impl: IFrameStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForwardProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSourcePageTypeProperty<Impl: IFrameStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentSourcePageTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourcePageTypeProperty<Impl: IFrameStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourcePageTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackStackDepthProperty<Impl: IFrameStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStackDepthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameStatics, BASE_OFFSET>(),
            CacheSizeProperty: CacheSizeProperty::<Impl, IMPL_OFFSET>,
            CanGoBackProperty: CanGoBackProperty::<Impl, IMPL_OFFSET>,
            CanGoForwardProperty: CanGoForwardProperty::<Impl, IMPL_OFFSET>,
            CurrentSourcePageTypeProperty: CurrentSourcePageTypeProperty::<Impl, IMPL_OFFSET>,
            SourcePageTypeProperty: SourcePageTypeProperty::<Impl, IMPL_OFFSET>,
            BackStackDepthProperty: BackStackDepthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStatics2_Impl: Sized {
    fn BackStackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForwardStackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameStatics2_Vtbl {
        unsafe extern "system" fn BackStackProperty<Impl: IFrameStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackStackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForwardStackProperty<Impl: IFrameStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForwardStackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameStatics2, BASE_OFFSET>(),
            BackStackProperty: BackStackProperty::<Impl, IMPL_OFFSET>,
            ForwardStackProperty: ForwardStackProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStatics5_Impl: Sized {
    fn IsNavigationStackEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrameStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrameStatics5_Vtbl {
        unsafe extern "system" fn IsNavigationStackEnabledProperty<Impl: IFrameStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNavigationStackEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IFrameStatics5, BASE_OFFSET>(),
            IsNavigationStackEnabledProperty: IsNavigationStackEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrameStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IGrid_Impl: Sized {
    fn RowDefinitions(&mut self) -> ::windows::core::Result<RowDefinitionCollection>;
    fn ColumnDefinitions(&mut self) -> ::windows::core::Result<ColumnDefinitionCollection>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IGrid_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGrid_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGrid_Vtbl {
        unsafe extern "system" fn RowDefinitions<Impl: IGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowDefinitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColumnDefinitions<Impl: IGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnDefinitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid, BASE_OFFSET>(),
            RowDefinitions: RowDefinitions::<Impl, IMPL_OFFSET>,
            ColumnDefinitions: ColumnDefinitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IGrid2_Impl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IGrid2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IGrid2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGrid2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGrid2_Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid2, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGrid3_Impl: Sized {
    fn RowSpacing(&mut self) -> ::windows::core::Result<f64>;
    fn SetRowSpacing(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ColumnSpacing(&mut self) -> ::windows::core::Result<f64>;
    fn SetColumnSpacing(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid3";
}
#[cfg(feature = "implement_exclusive")]
impl IGrid3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGrid3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGrid3_Vtbl {
        unsafe extern "system" fn RowSpacing<Impl: IGrid3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpacing<Impl: IGrid3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRowSpacing(value).into()
        }
        unsafe extern "system" fn ColumnSpacing<Impl: IGrid3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpacing<Impl: IGrid3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumnSpacing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid3, BASE_OFFSET>(),
            RowSpacing: RowSpacing::<Impl, IMPL_OFFSET>,
            SetRowSpacing: SetRowSpacing::<Impl, IMPL_OFFSET>,
            ColumnSpacing: ColumnSpacing::<Impl, IMPL_OFFSET>,
            SetColumnSpacing: SetColumnSpacing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGrid4_Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid4";
}
#[cfg(feature = "implement_exclusive")]
impl IGrid4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGrid4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGrid4_Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IGrid4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IGrid4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGrid4, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGrid4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Grid>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics_Impl: Sized {
    fn RowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRow(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetRow(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumn(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetColumn(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn RowSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRowSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetRowSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumnSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetColumnSpan(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStatics_Vtbl {
        unsafe extern "system" fn RowProperty<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRow<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRow(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRow<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRow(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnProperty<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumn<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColumn(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumn<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumn(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn RowSpanProperty<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRowSpan<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRowSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpan<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRowSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnSpanProperty<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumnSpan<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColumnSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpan<Impl: IGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumnSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics, BASE_OFFSET>(),
            RowProperty: RowProperty::<Impl, IMPL_OFFSET>,
            GetRow: GetRow::<Impl, IMPL_OFFSET>,
            SetRow: SetRow::<Impl, IMPL_OFFSET>,
            ColumnProperty: ColumnProperty::<Impl, IMPL_OFFSET>,
            GetColumn: GetColumn::<Impl, IMPL_OFFSET>,
            SetColumn: SetColumn::<Impl, IMPL_OFFSET>,
            RowSpanProperty: RowSpanProperty::<Impl, IMPL_OFFSET>,
            GetRowSpan: GetRowSpan::<Impl, IMPL_OFFSET>,
            SetRowSpan: SetRowSpan::<Impl, IMPL_OFFSET>,
            ColumnSpanProperty: ColumnSpanProperty::<Impl, IMPL_OFFSET>,
            GetColumnSpan: GetColumnSpan::<Impl, IMPL_OFFSET>,
            SetColumnSpan: SetColumnSpan::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics2_Impl: Sized {
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStatics2_Vtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IGridStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IGridStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IGridStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IGridStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics2, BASE_OFFSET>(),
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics3_Impl: Sized {
    fn RowSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColumnSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStatics3_Vtbl {
        unsafe extern "system" fn RowSpacingProperty<Impl: IGridStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColumnSpacingProperty<Impl: IGridStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics3, BASE_OFFSET>(),
            RowSpacingProperty: RowSpacingProperty::<Impl, IMPL_OFFSET>,
            ColumnSpacingProperty: ColumnSpacingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics4_Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridStatics4_Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IGridStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridStatics4, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridView_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridView";
}
#[cfg(feature = "implement_exclusive")]
impl IGridView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridView_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridView, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewHeaderItem_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewHeaderItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewHeaderItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewHeaderItem_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewHeaderItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewHeaderItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewHeaderItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridViewHeaderItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewHeaderItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewHeaderItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewHeaderItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewHeaderItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewHeaderItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewHeaderItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IGridViewItem_Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::GridViewItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IGridViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewItem";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IGridViewItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewItem_Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IGridViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewItem, BASE_OFFSET>(), TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGridViewItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGridViewItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGridViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGridViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupItem_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupItem";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupItem_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupItemFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyle_Impl: Sized {
    fn Panel(&mut self) -> ::windows::core::Result<ItemsPanelTemplate>;
    fn SetPanel(&mut self, value: &::core::option::Option<ItemsPanelTemplate>) -> ::windows::core::Result<()>;
    fn ContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetHeaderTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn HidesIfEmpty(&mut self) -> ::windows::core::Result<bool>;
    fn SetHidesIfEmpty(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyle {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyle";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyle_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyle_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyle_Vtbl {
        unsafe extern "system" fn Panel<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Panel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanel<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanel(&*(&value as *const <ItemsPanelTemplate as ::windows::core::Abi>::Abi as *const <ItemsPanelTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContainerStyle<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerStyle<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContainerStyleSelector<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerStyleSelector<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplateSelector<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplateSelector<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HidesIfEmpty<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HidesIfEmpty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHidesIfEmpty<Impl: IGroupStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHidesIfEmpty(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyle, BASE_OFFSET>(),
            Panel: Panel::<Impl, IMPL_OFFSET>,
            SetPanel: SetPanel::<Impl, IMPL_OFFSET>,
            ContainerStyle: ContainerStyle::<Impl, IMPL_OFFSET>,
            SetContainerStyle: SetContainerStyle::<Impl, IMPL_OFFSET>,
            ContainerStyleSelector: ContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetContainerStyleSelector: SetContainerStyleSelector::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            HeaderTemplateSelector: HeaderTemplateSelector::<Impl, IMPL_OFFSET>,
            SetHeaderTemplateSelector: SetHeaderTemplateSelector::<Impl, IMPL_OFFSET>,
            HidesIfEmpty: HidesIfEmpty::<Impl, IMPL_OFFSET>,
            SetHidesIfEmpty: SetHidesIfEmpty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyle as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyle2_Impl: Sized {
    fn HeaderContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetHeaderContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyle2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyle2";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyle2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyle2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyle2_Vtbl {
        unsafe extern "system" fn HeaderContainerStyle<Impl: IGroupStyle2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderContainerStyle<Impl: IGroupStyle2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyle2, BASE_OFFSET>(),
            HeaderContainerStyle: HeaderContainerStyle::<Impl, IMPL_OFFSET>,
            SetHeaderContainerStyle: SetHeaderContainerStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyle2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupStyleFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelector_Impl: Sized {
    fn SelectGroupStyle(&mut self, group: &::core::option::Option<::windows::core::IInspectable>, level: u32) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelector_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleSelector_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleSelector_Vtbl {
        unsafe extern "system" fn SelectGroupStyle<Impl: IGroupStyleSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, group: *mut ::core::ffi::c_void, level: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectGroupStyle(&*(&group as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), level) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleSelector, BASE_OFFSET>(),
            SelectGroupStyle: SelectGroupStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleSelector as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupStyleSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleSelectorFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleSelectorFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupStyleSelectorFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleSelectorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleSelectorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorOverrides_Impl: Sized {
    fn SelectGroupStyleCore(&mut self, group: &::core::option::Option<::windows::core::IInspectable>, level: u32) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGroupStyleSelectorOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGroupStyleSelectorOverrides_Vtbl {
        unsafe extern "system" fn SelectGroupStyleCore<Impl: IGroupStyleSelectorOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, group: *mut ::core::ffi::c_void, level: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectGroupStyleCore(&*(&group as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), level) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IGroupStyleSelectorOverrides, BASE_OFFSET>(),
            SelectGroupStyleCore: SelectGroupStyleCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGroupStyleSelectorOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingPanelClosedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingPanelClosedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingPanelClosedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingPanelClosedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingPanelClosedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingPanelClosedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingPanelClosedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingPanelClosedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingPanelOpenedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingPanelOpenedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingPanelOpenedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingPanelOpenedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingPanelOpenedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingPanelOpenedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingPanelOpenedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingPanelOpenedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IHandwritingView_Impl: Sized {
    fn PlacementTarget(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn PlacementAlignment(&mut self) -> ::windows::core::Result<HandwritingPanelPlacementAlignment>;
    fn SetPlacementAlignment(&mut self, value: HandwritingPanelPlacementAlignment) -> ::windows::core::Result<()>;
    fn IsOpen(&mut self) -> ::windows::core::Result<bool>;
    fn AreCandidatesEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreCandidatesEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TryClose(&mut self) -> ::windows::core::Result<bool>;
    fn TryOpen(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHandwritingView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingView";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IHandwritingView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingView_Vtbl {
        unsafe extern "system" fn PlacementTarget<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlacementAlignment<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut HandwritingPanelPlacementAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementAlignment<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: HandwritingPanelPlacementAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementAlignment(value).into()
        }
        unsafe extern "system" fn IsOpen<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreCandidatesEnabled<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreCandidatesEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreCandidatesEnabled<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreCandidatesEnabled(value).into()
        }
        unsafe extern "system" fn Opened<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TryClose<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TryClose() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TryOpen<Impl: IHandwritingView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TryOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingView, BASE_OFFSET>(),
            PlacementTarget: PlacementTarget::<Impl, IMPL_OFFSET>,
            SetPlacementTarget: SetPlacementTarget::<Impl, IMPL_OFFSET>,
            PlacementAlignment: PlacementAlignment::<Impl, IMPL_OFFSET>,
            SetPlacementAlignment: SetPlacementAlignment::<Impl, IMPL_OFFSET>,
            IsOpen: IsOpen::<Impl, IMPL_OFFSET>,
            AreCandidatesEnabled: AreCandidatesEnabled::<Impl, IMPL_OFFSET>,
            SetAreCandidatesEnabled: SetAreCandidatesEnabled::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            TryClose: TryClose::<Impl, IMPL_OFFSET>,
            TryOpen: TryOpen::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Core", feature = "implement_exclusive"))]
pub trait IHandwritingView2_Impl: Sized {
    fn IsSwitchToKeyboardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSwitchToKeyboardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCommandBarOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCommandBarOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn InputDeviceTypes(&mut self) -> ::windows::core::Result<super::super::Core::CoreInputDeviceTypes>;
    fn SetInputDeviceTypes(&mut self, value: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<()>;
    fn CandidatesChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidatesChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextSubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextSubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetCandidates(&mut self, candidatessessionid: u32) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>;
    fn SelectCandidate(&mut self, candidatessessionid: u32, selectedcandidateindex: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Core", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHandwritingView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingView2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Core", feature = "implement_exclusive"))]
impl IHandwritingView2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingView2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingView2_Vtbl {
        unsafe extern "system" fn IsSwitchToKeyboardEnabled<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwitchToKeyboardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSwitchToKeyboardEnabled<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSwitchToKeyboardEnabled(value).into()
        }
        unsafe extern "system" fn IsCommandBarOpen<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCommandBarOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCommandBarOpen<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCommandBarOpen(value).into()
        }
        unsafe extern "system" fn InputDeviceTypes<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Core::CoreInputDeviceTypes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputDeviceTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputDeviceTypes<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputDeviceTypes(value).into()
        }
        unsafe extern "system" fn CandidatesChanged<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidatesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidatesChanged<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCandidatesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextSubmitted<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextSubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextSubmitted<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextSubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetCandidates<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, candidatessessionid: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCandidates(candidatessessionid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectCandidate<Impl: IHandwritingView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, candidatessessionid: u32, selectedcandidateindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectCandidate(candidatessessionid, selectedcandidateindex).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingView2, BASE_OFFSET>(),
            IsSwitchToKeyboardEnabled: IsSwitchToKeyboardEnabled::<Impl, IMPL_OFFSET>,
            SetIsSwitchToKeyboardEnabled: SetIsSwitchToKeyboardEnabled::<Impl, IMPL_OFFSET>,
            IsCommandBarOpen: IsCommandBarOpen::<Impl, IMPL_OFFSET>,
            SetIsCommandBarOpen: SetIsCommandBarOpen::<Impl, IMPL_OFFSET>,
            InputDeviceTypes: InputDeviceTypes::<Impl, IMPL_OFFSET>,
            SetInputDeviceTypes: SetInputDeviceTypes::<Impl, IMPL_OFFSET>,
            CandidatesChanged: CandidatesChanged::<Impl, IMPL_OFFSET>,
            RemoveCandidatesChanged: RemoveCandidatesChanged::<Impl, IMPL_OFFSET>,
            TextSubmitted: TextSubmitted::<Impl, IMPL_OFFSET>,
            RemoveTextSubmitted: RemoveTextSubmitted::<Impl, IMPL_OFFSET>,
            GetCandidates: GetCandidates::<Impl, IMPL_OFFSET>,
            SelectCandidate: SelectCandidate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewCandidatesChangedEventArgs_Impl: Sized {
    fn CandidatesSessionId(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewCandidatesChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewCandidatesChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewCandidatesChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewCandidatesChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewCandidatesChangedEventArgs_Vtbl {
        unsafe extern "system" fn CandidatesSessionId<Impl: IHandwritingViewCandidatesChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidatesSessionId() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewCandidatesChangedEventArgs, BASE_OFFSET>(),
            CandidatesSessionId: CandidatesSessionId::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewCandidatesChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HandwritingView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHandwritingViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewStatics_Impl: Sized {
    fn PlacementTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AreCandidatesEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewStatics_Vtbl {
        unsafe extern "system" fn PlacementTargetProperty<Impl: IHandwritingViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementAlignmentProperty<Impl: IHandwritingViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOpenProperty<Impl: IHandwritingViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreCandidatesEnabledProperty<Impl: IHandwritingViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreCandidatesEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewStatics, BASE_OFFSET>(),
            PlacementTargetProperty: PlacementTargetProperty::<Impl, IMPL_OFFSET>,
            PlacementAlignmentProperty: PlacementAlignmentProperty::<Impl, IMPL_OFFSET>,
            IsOpenProperty: IsOpenProperty::<Impl, IMPL_OFFSET>,
            AreCandidatesEnabledProperty: AreCandidatesEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewStatics2_Impl: Sized {
    fn IsSwitchToKeyboardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCommandBarOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewStatics2_Vtbl {
        unsafe extern "system" fn IsSwitchToKeyboardEnabledProperty<Impl: IHandwritingViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwitchToKeyboardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCommandBarOpenProperty<Impl: IHandwritingViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCommandBarOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewStatics2, BASE_OFFSET>(),
            IsSwitchToKeyboardEnabledProperty: IsSwitchToKeyboardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsCommandBarOpenProperty: IsCommandBarOpenProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewTextSubmittedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewTextSubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewTextSubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewTextSubmittedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHandwritingViewTextSubmittedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHandwritingViewTextSubmittedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHandwritingViewTextSubmittedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHandwritingViewTextSubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IHub_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn DefaultSectionIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetDefaultSectionIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Sections(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn SectionsInView(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn SectionHeaders(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<::windows::core::IInspectable>>;
    fn SectionHeaderClick(&mut self, handler: &::core::option::Option<HubSectionHeaderClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSectionHeaderClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SectionsInViewChanged(&mut self, handler: &::core::option::Option<SectionsInViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSectionsInViewChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollToSection(&mut self, section: &::core::option::Option<HubSection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHub {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHub";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IHub_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHub_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHub_Vtbl {
        unsafe extern "system" fn Header<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn DefaultSectionIndex<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultSectionIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSectionIndex<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultSectionIndex(value).into()
        }
        unsafe extern "system" fn Sections<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Sections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionsInView<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionsInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionHeaders<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionHeaders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionHeaderClick<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionHeaderClick(&*(&handler as *const <HubSectionHeaderClickEventHandler as ::windows::core::Abi>::Abi as *const <HubSectionHeaderClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSectionHeaderClick<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSectionHeaderClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SectionsInViewChanged<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SectionsInViewChanged(&*(&handler as *const <SectionsInViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SectionsInViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSectionsInViewChanged<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSectionsInViewChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollToSection<Impl: IHub_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, section: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollToSection(&*(&section as *const <HubSection as ::windows::core::Abi>::Abi as *const <HubSection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHub, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            DefaultSectionIndex: DefaultSectionIndex::<Impl, IMPL_OFFSET>,
            SetDefaultSectionIndex: SetDefaultSectionIndex::<Impl, IMPL_OFFSET>,
            Sections: Sections::<Impl, IMPL_OFFSET>,
            SectionsInView: SectionsInView::<Impl, IMPL_OFFSET>,
            SectionHeaders: SectionHeaders::<Impl, IMPL_OFFSET>,
            SectionHeaderClick: SectionHeaderClick::<Impl, IMPL_OFFSET>,
            RemoveSectionHeaderClick: RemoveSectionHeaderClick::<Impl, IMPL_OFFSET>,
            SectionsInViewChanged: SectionsInViewChanged::<Impl, IMPL_OFFSET>,
            RemoveSectionsInViewChanged: RemoveSectionsInViewChanged::<Impl, IMPL_OFFSET>,
            ScrollToSection: ScrollToSection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHub as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Hub>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHubFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHubFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHubFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSection_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn IsHeaderInteractive(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHeaderInteractive(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSection {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSection";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSection_Vtbl {
        unsafe extern "system" fn Header<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHeaderInteractive<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderInteractive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHeaderInteractive<Impl: IHubSection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHeaderInteractive(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSection, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            ContentTemplate: ContentTemplate::<Impl, IMPL_OFFSET>,
            SetContentTemplate: SetContentTemplate::<Impl, IMPL_OFFSET>,
            IsHeaderInteractive: IsHeaderInteractive::<Impl, IMPL_OFFSET>,
            SetIsHeaderInteractive: SetIsHeaderInteractive::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSection as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HubSection>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSectionFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSectionFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHubSectionFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSectionFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSectionFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionHeaderClickEventArgs_Impl: Sized {
    fn Section(&mut self) -> ::windows::core::Result<HubSection>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionHeaderClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionHeaderClickEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSectionHeaderClickEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSectionHeaderClickEventArgs_Vtbl {
        unsafe extern "system" fn Section<Impl: IHubSectionHeaderClickEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Section() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSectionHeaderClickEventArgs, BASE_OFFSET>(), Section: Section::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSectionHeaderClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionStatics_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHeaderInteractiveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubSectionStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubSectionStatics_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IHubSectionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IHubSectionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IHubSectionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHeaderInteractiveProperty<Impl: IHubSectionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderInteractiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHubSectionStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            ContentTemplateProperty: ContentTemplateProperty::<Impl, IMPL_OFFSET>,
            IsHeaderInteractiveProperty: IsHeaderInteractiveProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubSectionStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubStatics_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultSectionIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SemanticZoomOwnerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsActiveViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHubStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHubStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHubStatics_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IHubStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IHubStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IHubStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultSectionIndexProperty<Impl: IHubStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultSectionIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SemanticZoomOwnerProperty<Impl: IHubStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwnerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActiveViewProperty<Impl: IHubStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewProperty<Impl: IHubStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHubStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            DefaultSectionIndexProperty: DefaultSectionIndexProperty::<Impl, IMPL_OFFSET>,
            SemanticZoomOwnerProperty: SemanticZoomOwnerProperty::<Impl, IMPL_OFFSET>,
            IsActiveViewProperty: IsActiveViewProperty::<Impl, IMPL_OFFSET>,
            IsZoomedInViewProperty: IsZoomedInViewProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHubStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IHyperlinkButton_Impl: Sized {
    fn NavigateUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetNavigateUri(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IHyperlinkButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButton";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IHyperlinkButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHyperlinkButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHyperlinkButton_Vtbl {
        unsafe extern "system" fn NavigateUri<Impl: IHyperlinkButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigateUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigateUri<Impl: IHyperlinkButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigateUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHyperlinkButton, BASE_OFFSET>(),
            NavigateUri: NavigateUri::<Impl, IMPL_OFFSET>,
            SetNavigateUri: SetNavigateUri::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHyperlinkButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHyperlinkButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HyperlinkButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHyperlinkButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHyperlinkButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHyperlinkButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHyperlinkButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHyperlinkButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHyperlinkButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHyperlinkButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHyperlinkButtonStatics_Impl: Sized {
    fn NavigateUriProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHyperlinkButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHyperlinkButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IHyperlinkButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IHyperlinkButtonStatics_Vtbl {
        unsafe extern "system" fn NavigateUriProperty<Impl: IHyperlinkButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigateUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IHyperlinkButtonStatics, BASE_OFFSET>(),
            NavigateUriProperty: NavigateUriProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IHyperlinkButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IIconElement_Impl: Sized {
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IIconElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElement";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IIconElement_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconElement_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconElement_Vtbl {
        unsafe extern "system" fn Foreground<Impl: IIconElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IIconElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconElement, BASE_OFFSET>(),
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconElementFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconElementFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconElementFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconElementFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IIconElementFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconElementFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconElementStatics_Impl: Sized {
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconElementStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconElementStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconElementStatics_Vtbl {
        unsafe extern "system" fn ForegroundProperty<Impl: IIconElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconElementStatics, BASE_OFFSET>(),
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IIconSource_Impl: Sized {
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSource";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IIconSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSource_Vtbl {
        unsafe extern "system" fn Foreground<Impl: IIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSource, BASE_OFFSET>(),
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElement_Impl: Sized {
    fn IconSource(&mut self) -> ::windows::core::Result<IconSource>;
    fn SetIconSource(&mut self, value: &::core::option::Option<IconSource>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElement";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElement_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceElement_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceElement_Vtbl {
        unsafe extern "system" fn IconSource<Impl: IIconSourceElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: IIconSourceElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <IconSource as ::windows::core::Abi>::Abi as *const <IconSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceElement, BASE_OFFSET>(),
            IconSource: IconSource::<Impl, IMPL_OFFSET>,
            SetIconSource: SetIconSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<IconSourceElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceElementFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceElementFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IIconSourceElementFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceElementFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceElementFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementStatics_Impl: Sized {
    fn IconSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceElementStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceElementStatics_Vtbl {
        unsafe extern "system" fn IconSourceProperty<Impl: IIconSourceElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceElementStatics, BASE_OFFSET>(),
            IconSourceProperty: IconSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceStatics_Impl: Sized {
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIconSourceStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIconSourceStatics_Vtbl {
        unsafe extern "system" fn ForegroundProperty<Impl: IIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IIconSourceStatics, BASE_OFFSET>(),
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Media_PlayTo", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IImage_Impl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn NineGrid(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetNineGrid(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn PlayToSource(&mut self) -> ::windows::core::Result<super::super::super::Media::PlayTo::PlayToSource>;
    fn ImageFailed(&mut self, handler: &::core::option::Option<super::ExceptionRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveImageFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ImageOpened(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveImageOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Media_PlayTo", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IImage {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage";
}
#[cfg(all(feature = "Foundation", feature = "Media_PlayTo", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IImage_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImage_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImage_Vtbl {
        unsafe extern "system" fn Source<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn NineGrid<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NineGrid() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNineGrid<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNineGrid(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlayToSource<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ImageFailed<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ImageFailed(&*(&handler as *const <super::ExceptionRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::ExceptionRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveImageFailed<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveImageFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ImageOpened<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ImageOpened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveImageOpened<Impl: IImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveImageOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IImage, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            NineGrid: NineGrid::<Impl, IMPL_OFFSET>,
            SetNineGrid: SetNineGrid::<Impl, IMPL_OFFSET>,
            PlayToSource: PlayToSource::<Impl, IMPL_OFFSET>,
            ImageFailed: ImageFailed::<Impl, IMPL_OFFSET>,
            RemoveImageFailed: RemoveImageFailed::<Impl, IMPL_OFFSET>,
            ImageOpened: ImageOpened::<Impl, IMPL_OFFSET>,
            RemoveImageOpened: RemoveImageOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImage as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Casting", feature = "implement_exclusive"))]
pub trait IImage2_Impl: Sized {
    fn GetAsCastingSource(&mut self) -> ::windows::core::Result<super::super::super::Media::Casting::CastingSource>;
}
#[cfg(all(feature = "Media_Casting", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IImage2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage2";
}
#[cfg(all(feature = "Media_Casting", feature = "implement_exclusive"))]
impl IImage2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImage2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImage2_Vtbl {
        unsafe extern "system" fn GetAsCastingSource<Impl: IImage2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAsCastingSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IImage2, BASE_OFFSET>(), GetAsCastingSource: GetAsCastingSource::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImage2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
pub trait IImage3_Impl: Sized {
    fn GetAlphaMask(&mut self) -> ::windows::core::Result<super::super::Composition::CompositionBrush>;
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IImage3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage3";
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl IImage3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImage3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImage3_Vtbl {
        unsafe extern "system" fn GetAlphaMask<Impl: IImage3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlphaMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IImage3, BASE_OFFSET>(), GetAlphaMask: GetAlphaMask::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImage3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IImageStatics_Impl: Sized {
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NineGridProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IImageStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImageStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IImageStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IImageStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IImageStatics_Vtbl {
        unsafe extern "system" fn SourceProperty<Impl: IImageStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IImageStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NineGridProperty<Impl: IImageStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NineGridProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToSourceProperty<Impl: IImageStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IImageStatics, BASE_OFFSET>(),
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            NineGridProperty: NineGridProperty::<Impl, IMPL_OFFSET>,
            PlayToSourceProperty: PlayToSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IImageStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkCanvas_Impl: Sized {
    fn InkPresenter(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenter>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkCanvas {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkCanvas";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkCanvas_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkCanvas_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkCanvas_Vtbl {
        unsafe extern "system" fn InkPresenter<Impl: IInkCanvas_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkPresenter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkCanvas, BASE_OFFSET>(), InkPresenter: InkPresenter::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkCanvas as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkCanvasFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkCanvas>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkCanvasFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkCanvasFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkCanvasFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkCanvasFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkCanvasFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkCanvasFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkCanvasFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkCanvasFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkToolbar_Impl: Sized {
    fn InitialControls(&mut self) -> ::windows::core::Result<InkToolbarInitialControls>;
    fn SetInitialControls(&mut self, value: InkToolbarInitialControls) -> ::windows::core::Result<()>;
    fn Children(&mut self) -> ::windows::core::Result<super::DependencyObjectCollection>;
    fn ActiveTool(&mut self) -> ::windows::core::Result<InkToolbarToolButton>;
    fn SetActiveTool(&mut self, value: &::core::option::Option<InkToolbarToolButton>) -> ::windows::core::Result<()>;
    fn InkDrawingAttributes(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
    fn IsRulerButtonChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRulerButtonChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TargetInkCanvas(&mut self) -> ::windows::core::Result<InkCanvas>;
    fn SetTargetInkCanvas(&mut self, value: &::core::option::Option<InkCanvas>) -> ::windows::core::Result<()>;
    fn ActiveToolChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveActiveToolChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn InkDrawingAttributesChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveInkDrawingAttributesChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn EraseAllClicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveEraseAllClicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn IsRulerButtonCheckedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsRulerButtonCheckedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetToolButton(&mut self, tool: InkToolbarTool) -> ::windows::core::Result<InkToolbarToolButton>;
    fn GetToggleButton(&mut self, tool: InkToolbarToggle) -> ::windows::core::Result<InkToolbarToggleButton>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkToolbar_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbar_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbar_Vtbl {
        unsafe extern "system" fn InitialControls<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarInitialControls) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitialControls<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarInitialControls) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInitialControls(value).into()
        }
        unsafe extern "system" fn Children<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActiveTool<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActiveTool() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetActiveTool<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetActiveTool(&*(&value as *const <InkToolbarToolButton as ::windows::core::Abi>::Abi as *const <InkToolbarToolButton as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InkDrawingAttributes<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerButtonChecked<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRulerButtonChecked<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRulerButtonChecked(value).into()
        }
        unsafe extern "system" fn TargetInkCanvas<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkCanvas() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetInkCanvas<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTargetInkCanvas(&*(&value as *const <InkCanvas as ::windows::core::Abi>::Abi as *const <InkCanvas as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ActiveToolChanged<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActiveToolChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveActiveToolChanged<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveActiveToolChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InkDrawingAttributesChanged<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveInkDrawingAttributesChanged<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveInkDrawingAttributesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn EraseAllClicked<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EraseAllClicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEraseAllClicked<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveEraseAllClicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsRulerButtonCheckedChanged<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsRulerButtonCheckedChanged<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsRulerButtonCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetToolButton<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tool: InkToolbarTool, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetToolButton(tool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToggleButton<Impl: IInkToolbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tool: InkToolbarToggle, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetToggleButton(tool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbar, BASE_OFFSET>(),
            InitialControls: InitialControls::<Impl, IMPL_OFFSET>,
            SetInitialControls: SetInitialControls::<Impl, IMPL_OFFSET>,
            Children: Children::<Impl, IMPL_OFFSET>,
            ActiveTool: ActiveTool::<Impl, IMPL_OFFSET>,
            SetActiveTool: SetActiveTool::<Impl, IMPL_OFFSET>,
            InkDrawingAttributes: InkDrawingAttributes::<Impl, IMPL_OFFSET>,
            IsRulerButtonChecked: IsRulerButtonChecked::<Impl, IMPL_OFFSET>,
            SetIsRulerButtonChecked: SetIsRulerButtonChecked::<Impl, IMPL_OFFSET>,
            TargetInkCanvas: TargetInkCanvas::<Impl, IMPL_OFFSET>,
            SetTargetInkCanvas: SetTargetInkCanvas::<Impl, IMPL_OFFSET>,
            ActiveToolChanged: ActiveToolChanged::<Impl, IMPL_OFFSET>,
            RemoveActiveToolChanged: RemoveActiveToolChanged::<Impl, IMPL_OFFSET>,
            InkDrawingAttributesChanged: InkDrawingAttributesChanged::<Impl, IMPL_OFFSET>,
            RemoveInkDrawingAttributesChanged: RemoveInkDrawingAttributesChanged::<Impl, IMPL_OFFSET>,
            EraseAllClicked: EraseAllClicked::<Impl, IMPL_OFFSET>,
            RemoveEraseAllClicked: RemoveEraseAllClicked::<Impl, IMPL_OFFSET>,
            IsRulerButtonCheckedChanged: IsRulerButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsRulerButtonCheckedChanged: RemoveIsRulerButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            GetToolButton: GetToolButton::<Impl, IMPL_OFFSET>,
            GetToggleButton: GetToggleButton::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbar as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IInkToolbar2_Impl: Sized {
    fn IsStencilButtonChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsStencilButtonChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ButtonFlyoutPlacement(&mut self) -> ::windows::core::Result<InkToolbarButtonFlyoutPlacement>;
    fn SetButtonFlyoutPlacement(&mut self, value: InkToolbarButtonFlyoutPlacement) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn IsStencilButtonCheckedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsStencilButtonCheckedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetMenuButton(&mut self, menu: InkToolbarMenuKind) -> ::windows::core::Result<InkToolbarMenuButton>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IInkToolbar2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbar2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbar2_Vtbl {
        unsafe extern "system" fn IsStencilButtonChecked<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStencilButtonChecked<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsStencilButtonChecked(value).into()
        }
        unsafe extern "system" fn ButtonFlyoutPlacement<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarButtonFlyoutPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ButtonFlyoutPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetButtonFlyoutPlacement<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarButtonFlyoutPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetButtonFlyoutPlacement(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn IsStencilButtonCheckedChanged<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsStencilButtonCheckedChanged<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsStencilButtonCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetMenuButton<Impl: IInkToolbar2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, menu: InkToolbarMenuKind, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMenuButton(menu) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbar2, BASE_OFFSET>(),
            IsStencilButtonChecked: IsStencilButtonChecked::<Impl, IMPL_OFFSET>,
            SetIsStencilButtonChecked: SetIsStencilButtonChecked::<Impl, IMPL_OFFSET>,
            ButtonFlyoutPlacement: ButtonFlyoutPlacement::<Impl, IMPL_OFFSET>,
            SetButtonFlyoutPlacement: SetButtonFlyoutPlacement::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            IsStencilButtonCheckedChanged: IsStencilButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsStencilButtonCheckedChanged: RemoveIsStencilButtonCheckedChanged::<Impl, IMPL_OFFSET>,
            GetMenuButton: GetMenuButton::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbar2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkToolbar3_Impl: Sized {
    fn TargetInkPresenter(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenter>;
    fn SetTargetInkPresenter(&mut self, value: &::core::option::Option<super::super::Input::Inking::InkPresenter>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar3";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkToolbar3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbar3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbar3_Vtbl {
        unsafe extern "system" fn TargetInkPresenter<Impl: IInkToolbar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkPresenter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetInkPresenter<Impl: IInkToolbar3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTargetInkPresenter(&*(&value as *const <super::super::Input::Inking::InkPresenter as ::windows::core::Abi>::Abi as *const <super::super::Input::Inking::InkPresenter as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbar3, BASE_OFFSET>(),
            TargetInkPresenter: TargetInkPresenter::<Impl, IMPL_OFFSET>,
            SetTargetInkPresenter: SetTargetInkPresenter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbar3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarBallpointPenButton_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarBallpointPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarBallpointPenButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarBallpointPenButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarBallpointPenButton_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarBallpointPenButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarBallpointPenButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarBallpointPenButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarBallpointPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarBallpointPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarBallpointPenButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarBallpointPenButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarBallpointPenButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarBallpointPenButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarBallpointPenButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarBallpointPenButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IInkToolbarCustomPen_Impl: Sized {
    fn CreateInkDrawingAttributes(&mut self, brush: &::core::option::Option<super::Media::Brush>, strokewidth: f64) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarCustomPen {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPen";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IInkToolbarCustomPen_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPen_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPen_Vtbl {
        unsafe extern "system" fn CreateInkDrawingAttributes<Impl: IInkToolbarCustomPen_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brush: ::windows::core::RawPtr, strokewidth: f64, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInkDrawingAttributes(&*(&brush as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType), strokewidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPen, BASE_OFFSET>(),
            CreateInkDrawingAttributes: CreateInkDrawingAttributes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPen as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButton_Impl: Sized {
    fn CustomPen(&mut self) -> ::windows::core::Result<InkToolbarCustomPen>;
    fn SetCustomPen(&mut self, value: &::core::option::Option<InkToolbarCustomPen>) -> ::windows::core::Result<()>;
    fn ConfigurationContent(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetConfigurationContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenButton_Vtbl {
        unsafe extern "system" fn CustomPen<Impl: IInkToolbarCustomPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CustomPen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCustomPen<Impl: IInkToolbarCustomPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCustomPen(&*(&value as *const <InkToolbarCustomPen as ::windows::core::Abi>::Abi as *const <InkToolbarCustomPen as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ConfigurationContent<Impl: IInkToolbarCustomPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfigurationContent<Impl: IInkToolbarCustomPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConfigurationContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenButton, BASE_OFFSET>(),
            CustomPen: CustomPen::<Impl, IMPL_OFFSET>,
            SetCustomPen: SetCustomPen::<Impl, IMPL_OFFSET>,
            ConfigurationContent: ConfigurationContent::<Impl, IMPL_OFFSET>,
            SetConfigurationContent: SetConfigurationContent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomPenButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonStatics_Impl: Sized {
    fn CustomPenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ConfigurationContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenButtonStatics_Vtbl {
        unsafe extern "system" fn CustomPenProperty<Impl: IInkToolbarCustomPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CustomPenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfigurationContentProperty<Impl: IInkToolbarCustomPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenButtonStatics, BASE_OFFSET>(),
            CustomPenProperty: CustomPenProperty::<Impl, IMPL_OFFSET>,
            ConfigurationContentProperty: ConfigurationContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomPen>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomPenFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IInkToolbarCustomPenOverrides_Impl: Sized {
    fn CreateInkDrawingAttributesCore(&mut self, brush: &::core::option::Option<super::Media::Brush>, strokewidth: f64) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenOverrides";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IInkToolbarCustomPenOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomPenOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomPenOverrides_Vtbl {
        unsafe extern "system" fn CreateInkDrawingAttributesCore<Impl: IInkToolbarCustomPenOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brush: ::windows::core::RawPtr, strokewidth: f64, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInkDrawingAttributesCore(&*(&brush as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType), strokewidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomPenOverrides, BASE_OFFSET>(),
            CreateInkDrawingAttributesCore: CreateInkDrawingAttributesCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomPenOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToggleButton_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToggleButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToggleButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToggleButton_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToggleButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToggleButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToggleButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomToggleButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToggleButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToggleButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToggleButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomToggleButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToggleButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToggleButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButton_Impl: Sized {
    fn ConfigurationContent(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetConfigurationContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToolButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToolButton_Vtbl {
        unsafe extern "system" fn ConfigurationContent<Impl: IInkToolbarCustomToolButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfigurationContent<Impl: IInkToolbarCustomToolButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConfigurationContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToolButton, BASE_OFFSET>(),
            ConfigurationContent: ConfigurationContent::<Impl, IMPL_OFFSET>,
            SetConfigurationContent: SetConfigurationContent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToolButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomToolButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToolButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToolButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomToolButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToolButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToolButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonStatics_Impl: Sized {
    fn ConfigurationContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarCustomToolButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarCustomToolButtonStatics_Vtbl {
        unsafe extern "system" fn ConfigurationContentProperty<Impl: IInkToolbarCustomToolButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfigurationContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarCustomToolButtonStatics, BASE_OFFSET>(),
            ConfigurationContentProperty: ConfigurationContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarCustomToolButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButton_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButton_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButton2_Impl: Sized {
    fn IsClearAllVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsClearAllVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButton2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButton2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButton2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButton2_Vtbl {
        unsafe extern "system" fn IsClearAllVisible<Impl: IInkToolbarEraserButton2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearAllVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsClearAllVisible<Impl: IInkToolbarEraserButton2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsClearAllVisible(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButton2, BASE_OFFSET>(),
            IsClearAllVisible: IsClearAllVisible::<Impl, IMPL_OFFSET>,
            SetIsClearAllVisible: SetIsClearAllVisible::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButton2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarEraserButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarEraserButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonStatics2_Impl: Sized {
    fn IsClearAllVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButtonStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarEraserButtonStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarEraserButtonStatics2_Vtbl {
        unsafe extern "system" fn IsClearAllVisibleProperty<Impl: IInkToolbarEraserButtonStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearAllVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarEraserButtonStatics2, BASE_OFFSET>(),
            IsClearAllVisibleProperty: IsClearAllVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarEraserButtonStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IInkToolbarFlyoutItem_Impl: Sized {
    fn Kind(&mut self) -> ::windows::core::Result<InkToolbarFlyoutItemKind>;
    fn SetKind(&mut self, value: InkToolbarFlyoutItemKind) -> ::windows::core::Result<()>;
    fn IsChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Checked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChecked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Unchecked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnchecked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItem";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IInkToolbarFlyoutItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFlyoutItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFlyoutItem_Vtbl {
        unsafe extern "system" fn Kind<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarFlyoutItemKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Kind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKind<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarFlyoutItemKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKind(value).into()
        }
        unsafe extern "system" fn IsChecked<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        unsafe extern "system" fn Checked<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Checked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChecked<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveChecked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Unchecked<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Unchecked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnchecked<Impl: IInkToolbarFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnchecked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFlyoutItem, BASE_OFFSET>(),
            Kind: Kind::<Impl, IMPL_OFFSET>,
            SetKind: SetKind::<Impl, IMPL_OFFSET>,
            IsChecked: IsChecked::<Impl, IMPL_OFFSET>,
            SetIsChecked: SetIsChecked::<Impl, IMPL_OFFSET>,
            Checked: Checked::<Impl, IMPL_OFFSET>,
            RemoveChecked: RemoveChecked::<Impl, IMPL_OFFSET>,
            Unchecked: Unchecked::<Impl, IMPL_OFFSET>,
            RemoveUnchecked: RemoveUnchecked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFlyoutItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFlyoutItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFlyoutItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFlyoutItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarFlyoutItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFlyoutItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFlyoutItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFlyoutItemStatics_Impl: Sized {
    fn KindProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFlyoutItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarFlyoutItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarFlyoutItemStatics_Vtbl {
        unsafe extern "system" fn KindProperty<Impl: IInkToolbarFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCheckedProperty<Impl: IInkToolbarFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarFlyoutItemStatics, BASE_OFFSET>(),
            KindProperty: KindProperty::<Impl, IMPL_OFFSET>,
            IsCheckedProperty: IsCheckedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarHighlighterButton_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarHighlighterButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarHighlighterButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarHighlighterButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarHighlighterButton_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarHighlighterButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarHighlighterButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarHighlighterButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarHighlighterButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarHighlighterButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarHighlighterButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarHighlighterButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarHighlighterButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarHighlighterButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarHighlighterButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarHighlighterButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarIsStencilButtonCheckedChangedEventArgs_Impl: Sized {
    fn StencilButton(&mut self) -> ::windows::core::Result<InkToolbarStencilButton>;
    fn StencilKind(&mut self) -> ::windows::core::Result<InkToolbarStencilKind>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarIsStencilButtonCheckedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarIsStencilButtonCheckedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarIsStencilButtonCheckedChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarIsStencilButtonCheckedChangedEventArgs_Vtbl {
        unsafe extern "system" fn StencilButton<Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StencilButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StencilKind<Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StencilKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarIsStencilButtonCheckedChangedEventArgs, BASE_OFFSET>(),
            StencilButton: StencilButton::<Impl, IMPL_OFFSET>,
            StencilKind: StencilKind::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarIsStencilButtonCheckedChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButton_Impl: Sized {
    fn MenuKind(&mut self) -> ::windows::core::Result<InkToolbarMenuKind>;
    fn IsExtensionGlyphShown(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExtensionGlyphShown(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarMenuButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarMenuButton_Vtbl {
        unsafe extern "system" fn MenuKind<Impl: IInkToolbarMenuButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarMenuKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExtensionGlyphShown<Impl: IInkToolbarMenuButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExtensionGlyphShown<Impl: IInkToolbarMenuButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExtensionGlyphShown(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarMenuButton, BASE_OFFSET>(),
            MenuKind: MenuKind::<Impl, IMPL_OFFSET>,
            IsExtensionGlyphShown: IsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
            SetIsExtensionGlyphShown: SetIsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarMenuButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarMenuButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarMenuButtonFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarMenuButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarMenuButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonStatics_Impl: Sized {
    fn IsExtensionGlyphShownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarMenuButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarMenuButtonStatics_Vtbl {
        unsafe extern "system" fn IsExtensionGlyphShownProperty<Impl: IInkToolbarMenuButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarMenuButtonStatics, BASE_OFFSET>(),
            IsExtensionGlyphShownProperty: IsExtensionGlyphShownProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarMenuButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IInkToolbarPenButton_Impl: Sized {
    fn Palette(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Media::Brush>>;
    fn SetPalette(&mut self, value: &::core::option::Option<super::super::super::Foundation::Collections::IVector<super::Media::Brush>>) -> ::windows::core::Result<()>;
    fn MinStrokeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinStrokeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MaxStrokeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxStrokeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn SelectedBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SelectedBrushIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectedBrushIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedStrokeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetSelectedStrokeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButton";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IInkToolbarPenButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenButton_Vtbl {
        unsafe extern "system" fn Palette<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Palette() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPalette<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPalette(&*(&value as *const <super::super::super::Foundation::Collections::IVector<super::Media::Brush> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<super::Media::Brush> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinStrokeWidth<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinStrokeWidth<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinStrokeWidth(value).into()
        }
        unsafe extern "system" fn MaxStrokeWidth<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxStrokeWidth<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxStrokeWidth(value).into()
        }
        unsafe extern "system" fn SelectedBrush<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushIndex<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrushIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedBrushIndex<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedBrushIndex(value).into()
        }
        unsafe extern "system" fn SelectedStrokeWidth<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStrokeWidth<Impl: IInkToolbarPenButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedStrokeWidth(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenButton, BASE_OFFSET>(),
            Palette: Palette::<Impl, IMPL_OFFSET>,
            SetPalette: SetPalette::<Impl, IMPL_OFFSET>,
            MinStrokeWidth: MinStrokeWidth::<Impl, IMPL_OFFSET>,
            SetMinStrokeWidth: SetMinStrokeWidth::<Impl, IMPL_OFFSET>,
            MaxStrokeWidth: MaxStrokeWidth::<Impl, IMPL_OFFSET>,
            SetMaxStrokeWidth: SetMaxStrokeWidth::<Impl, IMPL_OFFSET>,
            SelectedBrush: SelectedBrush::<Impl, IMPL_OFFSET>,
            SelectedBrushIndex: SelectedBrushIndex::<Impl, IMPL_OFFSET>,
            SetSelectedBrushIndex: SetSelectedBrushIndex::<Impl, IMPL_OFFSET>,
            SelectedStrokeWidth: SelectedStrokeWidth::<Impl, IMPL_OFFSET>,
            SetSelectedStrokeWidth: SetSelectedStrokeWidth::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenButtonFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenButtonFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenButtonStatics_Impl: Sized {
    fn PaletteProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinStrokeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxStrokeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBrushIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedStrokeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenButtonStatics_Vtbl {
        unsafe extern "system" fn PaletteProperty<Impl: IInkToolbarPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaletteProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinStrokeWidthProperty<Impl: IInkToolbarPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxStrokeWidthProperty<Impl: IInkToolbarPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushProperty<Impl: IInkToolbarPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushIndexProperty<Impl: IInkToolbarPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedBrushIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStrokeWidthProperty<Impl: IInkToolbarPenButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenButtonStatics, BASE_OFFSET>(),
            PaletteProperty: PaletteProperty::<Impl, IMPL_OFFSET>,
            MinStrokeWidthProperty: MinStrokeWidthProperty::<Impl, IMPL_OFFSET>,
            MaxStrokeWidthProperty: MaxStrokeWidthProperty::<Impl, IMPL_OFFSET>,
            SelectedBrushProperty: SelectedBrushProperty::<Impl, IMPL_OFFSET>,
            SelectedBrushIndexProperty: SelectedBrushIndexProperty::<Impl, IMPL_OFFSET>,
            SelectedStrokeWidthProperty: SelectedStrokeWidthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControl_Impl: Sized {
    fn PenButton(&mut self) -> ::windows::core::Result<InkToolbarPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControl";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenConfigurationControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenConfigurationControl_Vtbl {
        unsafe extern "system" fn PenButton<Impl: IInkToolbarPenConfigurationControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PenButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenConfigurationControl, BASE_OFFSET>(),
            PenButton: PenButton::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenConfigurationControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarPenConfigurationControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenConfigurationControlFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenConfigurationControlFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarPenConfigurationControlFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenConfigurationControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenConfigurationControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlStatics_Impl: Sized {
    fn PenButtonProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPenConfigurationControlStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPenConfigurationControlStatics_Vtbl {
        unsafe extern "system" fn PenButtonProperty<Impl: IInkToolbarPenConfigurationControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PenButtonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPenConfigurationControlStatics, BASE_OFFSET>(),
            PenButtonProperty: PenButtonProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPenConfigurationControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPencilButton_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPencilButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPencilButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPencilButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPencilButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPencilButton_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPencilButton, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPencilButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPencilButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarPencilButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPencilButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPencilButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPencilButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarPencilButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarPencilButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarPencilButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarPencilButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarPencilButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButton_Impl: Sized {
    fn Ruler(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterRuler>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButton";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarRulerButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarRulerButton_Vtbl {
        unsafe extern "system" fn Ruler<Impl: IInkToolbarRulerButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Ruler() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarRulerButton, BASE_OFFSET>(), Ruler: Ruler::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarRulerButton as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarRulerButton>;
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonFactory";
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarRulerButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarRulerButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarRulerButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarRulerButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarRulerButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonStatics_Impl: Sized {
    fn RulerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonStatics";
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarRulerButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarRulerButtonStatics_Vtbl {
        unsafe extern "system" fn RulerProperty<Impl: IInkToolbarRulerButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RulerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarRulerButtonStatics, BASE_OFFSET>(),
            RulerProperty: RulerProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarRulerButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStatics_Impl: Sized {
    fn InitialControlsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildrenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ActiveToolProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InkDrawingAttributesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRulerButtonCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TargetInkCanvasProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStatics_Vtbl {
        unsafe extern "system" fn InitialControlsProperty<Impl: IInkToolbarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialControlsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenProperty<Impl: IInkToolbarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActiveToolProperty<Impl: IInkToolbarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActiveToolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InkDrawingAttributesProperty<Impl: IInkToolbarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerButtonCheckedProperty<Impl: IInkToolbarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TargetInkCanvasProperty<Impl: IInkToolbarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkCanvasProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStatics, BASE_OFFSET>(),
            InitialControlsProperty: InitialControlsProperty::<Impl, IMPL_OFFSET>,
            ChildrenProperty: ChildrenProperty::<Impl, IMPL_OFFSET>,
            ActiveToolProperty: ActiveToolProperty::<Impl, IMPL_OFFSET>,
            InkDrawingAttributesProperty: InkDrawingAttributesProperty::<Impl, IMPL_OFFSET>,
            IsRulerButtonCheckedProperty: IsRulerButtonCheckedProperty::<Impl, IMPL_OFFSET>,
            TargetInkCanvasProperty: TargetInkCanvasProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStatics2_Impl: Sized {
    fn IsStencilButtonCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ButtonFlyoutPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStatics2_Vtbl {
        unsafe extern "system" fn IsStencilButtonCheckedProperty<Impl: IInkToolbarStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonFlyoutPlacementProperty<Impl: IInkToolbarStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ButtonFlyoutPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IInkToolbarStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStatics2, BASE_OFFSET>(),
            IsStencilButtonCheckedProperty: IsStencilButtonCheckedProperty::<Impl, IMPL_OFFSET>,
            ButtonFlyoutPlacementProperty: ButtonFlyoutPlacementProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStatics3_Impl: Sized {
    fn TargetInkPresenterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStatics3_Vtbl {
        unsafe extern "system" fn TargetInkPresenterProperty<Impl: IInkToolbarStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TargetInkPresenterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStatics3, BASE_OFFSET>(),
            TargetInkPresenterProperty: TargetInkPresenterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
pub trait IInkToolbarStencilButton_Impl: Sized {
    fn Ruler(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterRuler>;
    fn Protractor(&mut self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterProtractor>;
    fn SelectedStencil(&mut self) -> ::windows::core::Result<InkToolbarStencilKind>;
    fn SetSelectedStencil(&mut self, value: InkToolbarStencilKind) -> ::windows::core::Result<()>;
    fn IsRulerItemVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRulerItemVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsProtractorItemVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsProtractorItemVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarStencilButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButton";
}
#[cfg(all(feature = "UI_Input_Inking", feature = "implement_exclusive"))]
impl IInkToolbarStencilButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStencilButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStencilButton_Vtbl {
        unsafe extern "system" fn Ruler<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Ruler() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Protractor<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Protractor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStencil<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStencil() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStencil<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedStencil(value).into()
        }
        unsafe extern "system" fn IsRulerItemVisible<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerItemVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRulerItemVisible<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRulerItemVisible(value).into()
        }
        unsafe extern "system" fn IsProtractorItemVisible<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsProtractorItemVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsProtractorItemVisible<Impl: IInkToolbarStencilButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsProtractorItemVisible(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStencilButton, BASE_OFFSET>(),
            Ruler: Ruler::<Impl, IMPL_OFFSET>,
            Protractor: Protractor::<Impl, IMPL_OFFSET>,
            SelectedStencil: SelectedStencil::<Impl, IMPL_OFFSET>,
            SetSelectedStencil: SetSelectedStencil::<Impl, IMPL_OFFSET>,
            IsRulerItemVisible: IsRulerItemVisible::<Impl, IMPL_OFFSET>,
            SetIsRulerItemVisible: SetIsRulerItemVisible::<Impl, IMPL_OFFSET>,
            IsProtractorItemVisible: IsProtractorItemVisible::<Impl, IMPL_OFFSET>,
            SetIsProtractorItemVisible: SetIsProtractorItemVisible::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStencilButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStencilButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarStencilButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStencilButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStencilButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStencilButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStencilButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarStencilButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStencilButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStencilButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStencilButtonStatics_Impl: Sized {
    fn RulerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProtractorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedStencilProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRulerItemVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsProtractorItemVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStencilButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStencilButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarStencilButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarStencilButtonStatics_Vtbl {
        unsafe extern "system" fn RulerProperty<Impl: IInkToolbarStencilButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RulerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtractorProperty<Impl: IInkToolbarStencilButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProtractorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStencilProperty<Impl: IInkToolbarStencilButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedStencilProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerItemVisibleProperty<Impl: IInkToolbarStencilButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRulerItemVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsProtractorItemVisibleProperty<Impl: IInkToolbarStencilButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsProtractorItemVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarStencilButtonStatics, BASE_OFFSET>(),
            RulerProperty: RulerProperty::<Impl, IMPL_OFFSET>,
            ProtractorProperty: ProtractorProperty::<Impl, IMPL_OFFSET>,
            SelectedStencilProperty: SelectedStencilProperty::<Impl, IMPL_OFFSET>,
            IsRulerItemVisibleProperty: IsRulerItemVisibleProperty::<Impl, IMPL_OFFSET>,
            IsProtractorItemVisibleProperty: IsProtractorItemVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarStencilButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToggleButton_Impl: Sized {
    fn ToggleKind(&mut self) -> ::windows::core::Result<InkToolbarToggle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToggleButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToggleButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToggleButton_Vtbl {
        unsafe extern "system" fn ToggleKind<Impl: IInkToolbarToggleButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarToggle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ToggleKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToggleButton, BASE_OFFSET>(), ToggleKind: ToggleKind::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToggleButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToggleButtonFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToggleButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToggleButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToggleButtonFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToggleButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToggleButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButton_Impl: Sized {
    fn ToolKind(&mut self) -> ::windows::core::Result<InkToolbarTool>;
    fn IsExtensionGlyphShown(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExtensionGlyphShown(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToolButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToolButton_Vtbl {
        unsafe extern "system" fn ToolKind<Impl: IInkToolbarToolButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarTool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ToolKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExtensionGlyphShown<Impl: IInkToolbarToolButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExtensionGlyphShown<Impl: IInkToolbarToolButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExtensionGlyphShown(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToolButton, BASE_OFFSET>(),
            ToolKind: ToolKind::<Impl, IMPL_OFFSET>,
            IsExtensionGlyphShown: IsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
            SetIsExtensionGlyphShown: SetIsExtensionGlyphShown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToolButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToolButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToolButtonFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToolButtonFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToolButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonStatics_Impl: Sized {
    fn IsExtensionGlyphShownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInkToolbarToolButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInkToolbarToolButtonStatics_Vtbl {
        unsafe extern "system" fn IsExtensionGlyphShownProperty<Impl: IInkToolbarToolButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInkToolbarToolButtonStatics, BASE_OFFSET>(),
            IsExtensionGlyphShownProperty: IsExtensionGlyphShownProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInkToolbarToolButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Foundation")]
pub trait IInsertionPanel_Impl: Sized {
    fn GetInsertionIndexes(&mut self, position: &super::super::super::Foundation::Point, first: &mut i32, second: &mut i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Foundation")]
impl ::windows::core::RuntimeName for IInsertionPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInsertionPanel";
}
#[cfg(feature = "Foundation")]
impl IInsertionPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IInsertionPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IInsertionPanel_Vtbl {
        unsafe extern "system" fn GetInsertionIndexes<Impl: IInsertionPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: super::super::super::Foundation::Point, first: *mut i32, second: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInsertionIndexes(&*(&position as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&first), ::core::mem::transmute_copy(&second)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IInsertionPanel, BASE_OFFSET>(),
            GetInsertionIndexes: GetInsertionIndexes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IInsertionPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIsTextTrimmedChangedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIsTextTrimmedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIsTextTrimmedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IIsTextTrimmedChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsTextTrimmedChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsTextTrimmedChangedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IIsTextTrimmedChangedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsTextTrimmedChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemClickEventArgs_Impl: Sized {
    fn ClickedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IItemClickEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemClickEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemClickEventArgs_Vtbl {
        unsafe extern "system" fn ClickedItem<Impl: IItemClickEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClickedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IItemClickEventArgs, BASE_OFFSET>(), ClickedItem: ClickedItem::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IItemContainerGenerator_Impl: Sized {
    fn ItemsChanged(&mut self, handler: &::core::option::Option<Primitives::ItemsChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemsChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn IndexFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<i32>;
    fn ContainerFromIndex(&mut self, index: i32) -> ::windows::core::Result<super::DependencyObject>;
    fn GetItemContainerGeneratorForPanel(&mut self, panel: &::core::option::Option<Panel>) -> ::windows::core::Result<ItemContainerGenerator>;
    fn StartAt(&mut self, position: &Primitives::GeneratorPosition, direction: Primitives::GeneratorDirection, allowstartatrealizeditem: bool) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn GenerateNext(&mut self, isnewlyrealized: &mut bool) -> ::windows::core::Result<super::DependencyObject>;
    fn PrepareItemContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn RemoveAll(&mut self) -> ::windows::core::Result<()>;
    fn Remove(&mut self, position: &Primitives::GeneratorPosition, count: i32) -> ::windows::core::Result<()>;
    fn GeneratorPositionFromIndex(&mut self, itemindex: i32) -> ::windows::core::Result<Primitives::GeneratorPosition>;
    fn IndexFromGeneratorPosition(&mut self, position: &Primitives::GeneratorPosition) -> ::windows::core::Result<i32>;
    fn Recycle(&mut self, position: &Primitives::GeneratorPosition, count: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemContainerGenerator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemContainerGenerator";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IItemContainerGenerator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemContainerGenerator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemContainerGenerator_Vtbl {
        unsafe extern "system" fn ItemsChanged<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsChanged(&*(&handler as *const <Primitives::ItemsChangedEventHandler as ::windows::core::Abi>::Abi as *const <Primitives::ItemsChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemsChanged<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemFromContainer<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromContainer<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndexFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromIndex<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromIndex(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemContainerGeneratorForPanel<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, panel: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetItemContainerGeneratorForPanel(&*(&panel as *const <Panel as ::windows::core::Abi>::Abi as *const <Panel as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StartAt<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, direction: Primitives::GeneratorDirection, allowstartatrealizeditem: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartAt(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), direction, allowstartatrealizeditem).into()
        }
        unsafe extern "system" fn Stop<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn GenerateNext<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isnewlyrealized: *mut bool, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GenerateNext(::core::mem::transmute_copy(&isnewlyrealized)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrepareItemContainer<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PrepareItemContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveAll<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAll().into()
        }
        unsafe extern "system" fn Remove<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, count: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), count).into()
        }
        unsafe extern "system" fn GeneratorPositionFromIndex<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemindex: i32, result__: *mut Primitives::GeneratorPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GeneratorPositionFromIndex(itemindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromGeneratorPosition<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndexFromGeneratorPosition(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Recycle<Impl: IItemContainerGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, count: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Recycle(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), count).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemContainerGenerator, BASE_OFFSET>(),
            ItemsChanged: ItemsChanged::<Impl, IMPL_OFFSET>,
            RemoveItemsChanged: RemoveItemsChanged::<Impl, IMPL_OFFSET>,
            ItemFromContainer: ItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromItem: ContainerFromItem::<Impl, IMPL_OFFSET>,
            IndexFromContainer: IndexFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromIndex: ContainerFromIndex::<Impl, IMPL_OFFSET>,
            GetItemContainerGeneratorForPanel: GetItemContainerGeneratorForPanel::<Impl, IMPL_OFFSET>,
            StartAt: StartAt::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            GenerateNext: GenerateNext::<Impl, IMPL_OFFSET>,
            PrepareItemContainer: PrepareItemContainer::<Impl, IMPL_OFFSET>,
            RemoveAll: RemoveAll::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            GeneratorPositionFromIndex: GeneratorPositionFromIndex::<Impl, IMPL_OFFSET>,
            IndexFromGeneratorPosition: IndexFromGeneratorPosition::<Impl, IMPL_OFFSET>,
            Recycle: Recycle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemContainerGenerator as ::windows::core::Interface>::IID
    }
}
pub trait IItemContainerMapping_Impl: Sized {
    fn ItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn IndexFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<i32>;
    fn ContainerFromIndex(&mut self, index: i32) -> ::windows::core::Result<super::DependencyObject>;
}
impl ::windows::core::RuntimeName for IItemContainerMapping {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemContainerMapping";
}
impl IItemContainerMapping_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemContainerMapping_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemContainerMapping_Vtbl {
        unsafe extern "system" fn ItemFromContainer<Impl: IItemContainerMapping_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: IItemContainerMapping_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromContainer<Impl: IItemContainerMapping_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndexFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromIndex<Impl: IItemContainerMapping_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromIndex(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemContainerMapping, BASE_OFFSET>(),
            ItemFromContainer: ItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromItem: ContainerFromItem::<Impl, IMPL_OFFSET>,
            IndexFromContainer: IndexFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromIndex: ContainerFromIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemContainerMapping as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IItemsControl_Impl: Sized {
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Items(&mut self) -> ::windows::core::Result<ItemCollection>;
    fn ItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ItemTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetItemTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ItemsPanel(&mut self) -> ::windows::core::Result<ItemsPanelTemplate>;
    fn SetItemsPanel(&mut self, value: &::core::option::Option<ItemsPanelTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMemberPath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayMemberPath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn ItemContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetItemContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ItemContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetItemContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerGenerator(&mut self) -> ::windows::core::Result<ItemContainerGenerator>;
    fn ItemContainerTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetItemContainerTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn GroupStyle(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<GroupStyle>>;
    fn GroupStyleSelector(&mut self) -> ::windows::core::Result<GroupStyleSelector>;
    fn SetGroupStyleSelector(&mut self, value: &::core::option::Option<GroupStyleSelector>) -> ::windows::core::Result<()>;
    fn IsGrouping(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IItemsControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControl_Vtbl {
        unsafe extern "system" fn ItemsSource<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Items<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplate<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplateSelector<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplateSelector<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemsPanel<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPanel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsPanel<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsPanel(&*(&value as *const <ItemsPanelTemplate as ::windows::core::Abi>::Abi as *const <ItemsPanelTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMemberPath<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMemberPath<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyle<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyle<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyleSelector<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyleSelector<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerGenerator<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerGenerator() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitions<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerTransitions<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GroupStyle<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupStyleSelector<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupStyleSelector<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupStyleSelector(&*(&value as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGrouping<Impl: IItemsControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGrouping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControl, BASE_OFFSET>(),
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
            ItemTemplate: ItemTemplate::<Impl, IMPL_OFFSET>,
            SetItemTemplate: SetItemTemplate::<Impl, IMPL_OFFSET>,
            ItemTemplateSelector: ItemTemplateSelector::<Impl, IMPL_OFFSET>,
            SetItemTemplateSelector: SetItemTemplateSelector::<Impl, IMPL_OFFSET>,
            ItemsPanel: ItemsPanel::<Impl, IMPL_OFFSET>,
            SetItemsPanel: SetItemsPanel::<Impl, IMPL_OFFSET>,
            DisplayMemberPath: DisplayMemberPath::<Impl, IMPL_OFFSET>,
            SetDisplayMemberPath: SetDisplayMemberPath::<Impl, IMPL_OFFSET>,
            ItemContainerStyle: ItemContainerStyle::<Impl, IMPL_OFFSET>,
            SetItemContainerStyle: SetItemContainerStyle::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelector: ItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetItemContainerStyleSelector: SetItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            ItemContainerGenerator: ItemContainerGenerator::<Impl, IMPL_OFFSET>,
            ItemContainerTransitions: ItemContainerTransitions::<Impl, IMPL_OFFSET>,
            SetItemContainerTransitions: SetItemContainerTransitions::<Impl, IMPL_OFFSET>,
            GroupStyle: GroupStyle::<Impl, IMPL_OFFSET>,
            GroupStyleSelector: GroupStyleSelector::<Impl, IMPL_OFFSET>,
            SetGroupStyleSelector: SetGroupStyleSelector::<Impl, IMPL_OFFSET>,
            IsGrouping: IsGrouping::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControl2_Impl: Sized {
    fn ItemsPanelRoot(&mut self) -> ::windows::core::Result<Panel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControl2_Vtbl {
        unsafe extern "system" fn ItemsPanelRoot<Impl: IItemsControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPanelRoot() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControl2, BASE_OFFSET>(), ItemsPanelRoot: ItemsPanelRoot::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControl3_Impl: Sized {
    fn GroupHeaderContainerFromItemContainer(&mut self, itemcontainer: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DependencyObject>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControl3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl3";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControl3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControl3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControl3_Vtbl {
        unsafe extern "system" fn GroupHeaderContainerFromItemContainer<Impl: IItemsControl3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemcontainer: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderContainerFromItemContainer(&*(&itemcontainer as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControl3, BASE_OFFSET>(),
            GroupHeaderContainerFromItemContainer: GroupHeaderContainerFromItemContainer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControl3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ItemsControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControlFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControlFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IItemsControlFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlOverrides_Impl: Sized {
    fn IsItemItsOwnContainerOverride(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<bool>;
    fn GetContainerForItemOverride(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn ClearContainerForItemOverride(&mut self, element: &::core::option::Option<super::DependencyObject>, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PrepareContainerForItemOverride(&mut self, element: &::core::option::Option<super::DependencyObject>, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnItemsChanged(&mut self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnItemContainerStyleChanged(&mut self, olditemcontainerstyle: &::core::option::Option<super::Style>, newitemcontainerstyle: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn OnItemContainerStyleSelectorChanged(&mut self, olditemcontainerstyleselector: &::core::option::Option<StyleSelector>, newitemcontainerstyleselector: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn OnItemTemplateChanged(&mut self, olditemtemplate: &::core::option::Option<super::DataTemplate>, newitemtemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnItemTemplateSelectorChanged(&mut self, olditemtemplateselector: &::core::option::Option<DataTemplateSelector>, newitemtemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn OnGroupStyleSelectorChanged(&mut self, oldgroupstyleselector: &::core::option::Option<GroupStyleSelector>, newgroupstyleselector: &::core::option::Option<GroupStyleSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControlOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControlOverrides_Vtbl {
        unsafe extern "system" fn IsItemItsOwnContainerOverride<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemItsOwnContainerOverride(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContainerForItemOverride<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetContainerForItemOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearContainerForItemOverride<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearContainerForItemOverride(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrepareContainerForItemOverride<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PrepareContainerForItemOverride(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemsChanged<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemsChanged(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemContainerStyleChanged<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemcontainerstyle: ::windows::core::RawPtr, newitemcontainerstyle: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemContainerStyleChanged(&*(&olditemcontainerstyle as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType), &*(&newitemcontainerstyle as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemContainerStyleSelectorChanged<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemcontainerstyleselector: ::windows::core::RawPtr, newitemcontainerstyleselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemContainerStyleSelectorChanged(&*(&olditemcontainerstyleselector as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType), &*(&newitemcontainerstyleselector as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemTemplateChanged<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemtemplate: ::windows::core::RawPtr, newitemtemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemTemplateChanged(&*(&olditemtemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newitemtemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemTemplateSelectorChanged<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, olditemtemplateselector: ::windows::core::RawPtr, newitemtemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemTemplateSelectorChanged(&*(&olditemtemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newitemtemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnGroupStyleSelectorChanged<Impl: IItemsControlOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldgroupstyleselector: ::windows::core::RawPtr, newgroupstyleselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnGroupStyleSelectorChanged(&*(&oldgroupstyleselector as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType), &*(&newgroupstyleselector as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControlOverrides, BASE_OFFSET>(),
            IsItemItsOwnContainerOverride: IsItemItsOwnContainerOverride::<Impl, IMPL_OFFSET>,
            GetContainerForItemOverride: GetContainerForItemOverride::<Impl, IMPL_OFFSET>,
            ClearContainerForItemOverride: ClearContainerForItemOverride::<Impl, IMPL_OFFSET>,
            PrepareContainerForItemOverride: PrepareContainerForItemOverride::<Impl, IMPL_OFFSET>,
            OnItemsChanged: OnItemsChanged::<Impl, IMPL_OFFSET>,
            OnItemContainerStyleChanged: OnItemContainerStyleChanged::<Impl, IMPL_OFFSET>,
            OnItemContainerStyleSelectorChanged: OnItemContainerStyleSelectorChanged::<Impl, IMPL_OFFSET>,
            OnItemTemplateChanged: OnItemTemplateChanged::<Impl, IMPL_OFFSET>,
            OnItemTemplateSelectorChanged: OnItemTemplateSelectorChanged::<Impl, IMPL_OFFSET>,
            OnGroupStyleSelectorChanged: OnGroupStyleSelectorChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControlOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlStatics_Impl: Sized {
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayMemberPathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetItemsOwner(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ItemsControl>;
    fn ItemsControlFromItemContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ItemsControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsControlStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsControlStatics_Vtbl {
        unsafe extern "system" fn ItemsSourceProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateSelectorProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsPanelProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayMemberPathProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleSelectorProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitionsProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupStyleSelectorProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupingProperty<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemsOwner<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetItemsOwner(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsControlFromItemContainer<Impl: IItemsControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsControlFromItemContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsControlStatics, BASE_OFFSET>(),
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateProperty: ItemTemplateProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateSelectorProperty: ItemTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemsPanelProperty: ItemsPanelProperty::<Impl, IMPL_OFFSET>,
            DisplayMemberPathProperty: DisplayMemberPathProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleProperty: ItemContainerStyleProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelectorProperty: ItemContainerStyleSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemContainerTransitionsProperty: ItemContainerTransitionsProperty::<Impl, IMPL_OFFSET>,
            GroupStyleSelectorProperty: GroupStyleSelectorProperty::<Impl, IMPL_OFFSET>,
            IsGroupingProperty: IsGroupingProperty::<Impl, IMPL_OFFSET>,
            GetItemsOwner: GetItemsOwner::<Impl, IMPL_OFFSET>,
            ItemsControlFromItemContainer: ItemsControlFromItemContainer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPanelTemplate_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPanelTemplate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPanelTemplate";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPanelTemplate_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPanelTemplate_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPanelTemplate_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPanelTemplate, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPanelTemplate as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IItemsPickedEventArgs_Impl: Sized {
    fn AddedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn RemovedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsPickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPickedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IItemsPickedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPickedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPickedEventArgs_Vtbl {
        unsafe extern "system" fn AddedItems<Impl: IItemsPickedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedItems<Impl: IItemsPickedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPickedEventArgs, BASE_OFFSET>(),
            AddedItems: AddedItems::<Impl, IMPL_OFFSET>,
            RemovedItems: RemovedItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPickedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IItemsPresenter_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetHeaderTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenter";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IItemsPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenter_Vtbl {
        unsafe extern "system" fn Header<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTransitions<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTransitions<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IItemsPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenter, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            HeaderTransitions: HeaderTransitions::<Impl, IMPL_OFFSET>,
            SetHeaderTransitions: SetHeaderTransitions::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IItemsPresenter2_Impl: Sized {
    fn Footer(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetFooter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn FooterTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetFooterTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FooterTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetFooterTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenter2";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IItemsPresenter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenter2_Vtbl {
        unsafe extern "system" fn Footer<Impl: IItemsPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Footer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooter<Impl: IItemsPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTemplate<Impl: IItemsPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTemplate<Impl: IItemsPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTransitions<Impl: IItemsPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTransitions<Impl: IItemsPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenter2, BASE_OFFSET>(),
            Footer: Footer::<Impl, IMPL_OFFSET>,
            SetFooter: SetFooter::<Impl, IMPL_OFFSET>,
            FooterTemplate: FooterTemplate::<Impl, IMPL_OFFSET>,
            SetFooterTemplate: SetFooterTemplate::<Impl, IMPL_OFFSET>,
            FooterTransitions: FooterTransitions::<Impl, IMPL_OFFSET>,
            SetFooterTransitions: SetFooterTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenterStatics_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenterStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenterStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenterStatics_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IItemsPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IItemsPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTransitionsProperty<Impl: IItemsPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IItemsPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenterStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            HeaderTransitionsProperty: HeaderTransitionsProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenterStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenterStatics2_Impl: Sized {
    fn FooterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenterStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsPresenterStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsPresenterStatics2_Vtbl {
        unsafe extern "system" fn FooterProperty<Impl: IItemsPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTemplateProperty<Impl: IItemsPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTransitionsProperty<Impl: IItemsPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsPresenterStatics2, BASE_OFFSET>(),
            FooterProperty: FooterProperty::<Impl, IMPL_OFFSET>,
            FooterTemplateProperty: FooterTemplateProperty::<Impl, IMPL_OFFSET>,
            FooterTransitionsProperty: FooterTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IItemsStackPanel_Impl: Sized {
    fn GroupPadding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetGroupPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn FirstCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn FirstVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn ScrollingDirection(&mut self) -> ::windows::core::Result<PanelScrollingDirection>;
    fn GroupHeaderPlacement(&mut self) -> ::windows::core::Result<Primitives::GroupHeaderPlacement>;
    fn SetGroupHeaderPlacement(&mut self, value: Primitives::GroupHeaderPlacement) -> ::windows::core::Result<()>;
    fn ItemsUpdatingScrollMode(&mut self) -> ::windows::core::Result<ItemsUpdatingScrollMode>;
    fn SetItemsUpdatingScrollMode(&mut self, value: ItemsUpdatingScrollMode) -> ::windows::core::Result<()>;
    fn CacheLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCacheLength(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanel";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IItemsStackPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanel_Vtbl {
        unsafe extern "system" fn GroupPadding<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupPadding<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn FirstCacheIndex<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstVisibleIndex<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastVisibleIndex<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastCacheIndex<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollingDirection<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PanelScrollingDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollingDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacement<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderPlacement<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderPlacement(value).into()
        }
        unsafe extern "system" fn ItemsUpdatingScrollMode<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ItemsUpdatingScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsUpdatingScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsUpdatingScrollMode<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ItemsUpdatingScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsUpdatingScrollMode(value).into()
        }
        unsafe extern "system" fn CacheLength<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheLength<Impl: IItemsStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCacheLength(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanel, BASE_OFFSET>(),
            GroupPadding: GroupPadding::<Impl, IMPL_OFFSET>,
            SetGroupPadding: SetGroupPadding::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            FirstCacheIndex: FirstCacheIndex::<Impl, IMPL_OFFSET>,
            FirstVisibleIndex: FirstVisibleIndex::<Impl, IMPL_OFFSET>,
            LastVisibleIndex: LastVisibleIndex::<Impl, IMPL_OFFSET>,
            LastCacheIndex: LastCacheIndex::<Impl, IMPL_OFFSET>,
            ScrollingDirection: ScrollingDirection::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacement: GroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            SetGroupHeaderPlacement: SetGroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            ItemsUpdatingScrollMode: ItemsUpdatingScrollMode::<Impl, IMPL_OFFSET>,
            SetItemsUpdatingScrollMode: SetItemsUpdatingScrollMode::<Impl, IMPL_OFFSET>,
            CacheLength: CacheLength::<Impl, IMPL_OFFSET>,
            SetCacheLength: SetCacheLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanel2_Impl: Sized {
    fn AreStickyGroupHeadersEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreStickyGroupHeadersEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanel2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanel2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanel2_Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabled<Impl: IItemsStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreStickyGroupHeadersEnabled<Impl: IItemsStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreStickyGroupHeadersEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanel2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabled: AreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
            SetAreStickyGroupHeadersEnabled: SetAreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanelStatics_Impl: Sized {
    fn GroupPaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupHeaderPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CacheLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanelStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanelStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanelStatics_Vtbl {
        unsafe extern "system" fn GroupPaddingProperty<Impl: IItemsStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IItemsStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacementProperty<Impl: IItemsStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CacheLengthProperty<Impl: IItemsStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanelStatics, BASE_OFFSET>(),
            GroupPaddingProperty: GroupPaddingProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacementProperty: GroupHeaderPlacementProperty::<Impl, IMPL_OFFSET>,
            CacheLengthProperty: CacheLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanelStatics2_Impl: Sized {
    fn AreStickyGroupHeadersEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanelStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsStackPanelStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsStackPanelStatics2_Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabledProperty<Impl: IItemsStackPanelStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsStackPanelStatics2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabledProperty: AreStickyGroupHeadersEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsStackPanelStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IItemsWrapGrid_Impl: Sized {
    fn GroupPadding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetGroupPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn ItemWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FirstCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn FirstVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastVisibleIndex(&mut self) -> ::windows::core::Result<i32>;
    fn LastCacheIndex(&mut self) -> ::windows::core::Result<i32>;
    fn ScrollingDirection(&mut self) -> ::windows::core::Result<PanelScrollingDirection>;
    fn GroupHeaderPlacement(&mut self) -> ::windows::core::Result<Primitives::GroupHeaderPlacement>;
    fn SetGroupHeaderPlacement(&mut self, value: Primitives::GroupHeaderPlacement) -> ::windows::core::Result<()>;
    fn CacheLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCacheLength(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IItemsWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGrid";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IItemsWrapGrid_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGrid_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGrid_Vtbl {
        unsafe extern "system" fn GroupPadding<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupPadding<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        unsafe extern "system" fn ItemWidth<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn ItemHeight<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn FirstCacheIndex<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstVisibleIndex<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FirstVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastVisibleIndex<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastCacheIndex<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LastCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollingDirection<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PanelScrollingDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollingDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacement<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderPlacement<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderPlacement(value).into()
        }
        unsafe extern "system" fn CacheLength<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheLength<Impl: IItemsWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCacheLength(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGrid, BASE_OFFSET>(),
            GroupPadding: GroupPadding::<Impl, IMPL_OFFSET>,
            SetGroupPadding: SetGroupPadding::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumns: MaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            SetMaximumRowsOrColumns: SetMaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            ItemWidth: ItemWidth::<Impl, IMPL_OFFSET>,
            SetItemWidth: SetItemWidth::<Impl, IMPL_OFFSET>,
            ItemHeight: ItemHeight::<Impl, IMPL_OFFSET>,
            SetItemHeight: SetItemHeight::<Impl, IMPL_OFFSET>,
            FirstCacheIndex: FirstCacheIndex::<Impl, IMPL_OFFSET>,
            FirstVisibleIndex: FirstVisibleIndex::<Impl, IMPL_OFFSET>,
            LastVisibleIndex: LastVisibleIndex::<Impl, IMPL_OFFSET>,
            LastCacheIndex: LastCacheIndex::<Impl, IMPL_OFFSET>,
            ScrollingDirection: ScrollingDirection::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacement: GroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            SetGroupHeaderPlacement: SetGroupHeaderPlacement::<Impl, IMPL_OFFSET>,
            CacheLength: CacheLength::<Impl, IMPL_OFFSET>,
            SetCacheLength: SetCacheLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGrid2_Impl: Sized {
    fn AreStickyGroupHeadersEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreStickyGroupHeadersEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGrid2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGrid2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGrid2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGrid2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGrid2_Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabled<Impl: IItemsWrapGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreStickyGroupHeadersEnabled<Impl: IItemsWrapGrid2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreStickyGroupHeadersEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGrid2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabled: AreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
            SetAreStickyGroupHeadersEnabled: SetAreStickyGroupHeadersEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGrid2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGridStatics_Impl: Sized {
    fn GroupPaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupHeaderPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CacheLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGridStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGridStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGridStatics_Vtbl {
        unsafe extern "system" fn GroupPaddingProperty<Impl: IItemsWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IItemsWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IItemsWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemWidthProperty<Impl: IItemsWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemHeightProperty<Impl: IItemsWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacementProperty<Impl: IItemsWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CacheLengthProperty<Impl: IItemsWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CacheLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGridStatics, BASE_OFFSET>(),
            GroupPaddingProperty: GroupPaddingProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumnsProperty: MaximumRowsOrColumnsProperty::<Impl, IMPL_OFFSET>,
            ItemWidthProperty: ItemWidthProperty::<Impl, IMPL_OFFSET>,
            ItemHeightProperty: ItemHeightProperty::<Impl, IMPL_OFFSET>,
            GroupHeaderPlacementProperty: GroupHeaderPlacementProperty::<Impl, IMPL_OFFSET>,
            CacheLengthProperty: CacheLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGridStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGridStatics2_Impl: Sized {
    fn AreStickyGroupHeadersEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGridStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGridStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IItemsWrapGridStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IItemsWrapGridStatics2_Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabledProperty<Impl: IItemsWrapGridStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IItemsWrapGridStatics2, BASE_OFFSET>(),
            AreStickyGroupHeadersEnabledProperty: AreStickyGroupHeadersEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IItemsWrapGridStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IListBox_Impl: Sized {
    fn SelectedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<SelectionMode>;
    fn SetSelectionMode(&mut self, value: SelectionMode) -> ::windows::core::Result<()>;
    fn ScrollIntoView(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBox";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IListBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBox_Vtbl {
        unsafe extern "system" fn SelectedItems<Impl: IListBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: IListBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn ScrollIntoView<Impl: IListBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollIntoView(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IListBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBox, BASE_OFFSET>(),
            SelectedItems: SelectedItems::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            ScrollIntoView: ScrollIntoView::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBox2_Impl: Sized {
    fn SingleSelectionFollowsFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetSingleSelectionFollowsFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IListBox2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBox2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBox2_Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: IListBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSingleSelectionFollowsFocus<Impl: IListBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSingleSelectionFollowsFocus(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBox2, BASE_OFFSET>(),
            SingleSelectionFollowsFocus: SingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            SetSingleSelectionFollowsFocus: SetSingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListBoxFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxItem_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxItem_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListBoxItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListBoxItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxStatics_Impl: Sized {
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxStatics_Vtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: IListBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxStatics, BASE_OFFSET>(),
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxStatics2_Impl: Sized {
    fn SingleSelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListBoxStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListBoxStatics2_Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: IListBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListBoxStatics2, BASE_OFFSET>(),
            SingleSelectionFollowsFocusProperty: SingleSelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IListPickerFlyout_Impl: Sized {
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMemberPath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayMemberPath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<ListPickerFlyoutSelectionMode>;
    fn SetSelectionMode(&mut self, value: ListPickerFlyoutSelectionMode) -> ::windows::core::Result<()>;
    fn SelectedIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectedIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectedValue(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedValue(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectedValuePath(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSelectedValuePath(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn ItemsPicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemsPicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListPickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IListPickerFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListPickerFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListPickerFlyout_Vtbl {
        unsafe extern "system" fn ItemsSource<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplate<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMemberPath<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMemberPath<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionMode<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ListPickerFlyoutSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ListPickerFlyoutSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn SelectedIndex<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedIndex<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedIndex(value).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedValue<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedValue<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedValue(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedValuePath<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValuePath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedValuePath<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedValuePath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedItems<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsPicked<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsPicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemsPicked<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemsPicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IListPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListPickerFlyout, BASE_OFFSET>(),
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
            ItemTemplate: ItemTemplate::<Impl, IMPL_OFFSET>,
            SetItemTemplate: SetItemTemplate::<Impl, IMPL_OFFSET>,
            DisplayMemberPath: DisplayMemberPath::<Impl, IMPL_OFFSET>,
            SetDisplayMemberPath: SetDisplayMemberPath::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            SelectedIndex: SelectedIndex::<Impl, IMPL_OFFSET>,
            SetSelectedIndex: SetSelectedIndex::<Impl, IMPL_OFFSET>,
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            SetSelectedItem: SetSelectedItem::<Impl, IMPL_OFFSET>,
            SelectedValue: SelectedValue::<Impl, IMPL_OFFSET>,
            SetSelectedValue: SetSelectedValue::<Impl, IMPL_OFFSET>,
            SelectedValuePath: SelectedValuePath::<Impl, IMPL_OFFSET>,
            SetSelectedValuePath: SetSelectedValuePath::<Impl, IMPL_OFFSET>,
            SelectedItems: SelectedItems::<Impl, IMPL_OFFSET>,
            ItemsPicked: ItemsPicked::<Impl, IMPL_OFFSET>,
            RemoveItemsPicked: RemoveItemsPicked::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListPickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListPickerFlyoutPresenter_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListPickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IListPickerFlyoutPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListPickerFlyoutPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListPickerFlyoutPresenter_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListPickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListPickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListPickerFlyoutStatics_Impl: Sized {
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayMemberPathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedValuePathProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListPickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListPickerFlyoutStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListPickerFlyoutStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListPickerFlyoutStatics_Vtbl {
        unsafe extern "system" fn ItemsSourceProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayMemberPathProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionModeProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedIndexProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedValueProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedValuePathProperty<Impl: IListPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedValuePathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListPickerFlyoutStatics, BASE_OFFSET>(),
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateProperty: ItemTemplateProperty::<Impl, IMPL_OFFSET>,
            DisplayMemberPathProperty: DisplayMemberPathProperty::<Impl, IMPL_OFFSET>,
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
            SelectedIndexProperty: SelectedIndexProperty::<Impl, IMPL_OFFSET>,
            SelectedItemProperty: SelectedItemProperty::<Impl, IMPL_OFFSET>,
            SelectedValueProperty: SelectedValueProperty::<Impl, IMPL_OFFSET>,
            SelectedValuePathProperty: SelectedValuePathProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListPickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListView_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListView";
}
#[cfg(feature = "implement_exclusive")]
impl IListView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListView_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListView, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IListViewBase_Impl: Sized {
    fn SelectedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<ListViewSelectionMode>;
    fn SetSelectionMode(&mut self, value: ListViewSelectionMode) -> ::windows::core::Result<()>;
    fn IsSwipeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSwipeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanDragItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanDragItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanReorderItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanReorderItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsItemClickEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsItemClickEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DataFetchSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetDataFetchSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IncrementalLoadingThreshold(&mut self) -> ::windows::core::Result<f64>;
    fn SetIncrementalLoadingThreshold(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IncrementalLoadingTrigger(&mut self) -> ::windows::core::Result<IncrementalLoadingTrigger>;
    fn SetIncrementalLoadingTrigger(&mut self, value: IncrementalLoadingTrigger) -> ::windows::core::Result<()>;
    fn ItemClick(&mut self, handler: &::core::option::Option<ItemClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DragItemsStarting(&mut self, handler: &::core::option::Option<DragItemsStartingEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollIntoView(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn LoadMoreItemsAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::Data::LoadMoreItemsResult>>;
    fn ScrollIntoViewWithAlignment(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, alignment: ScrollIntoViewAlignment) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetHeaderTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IListViewBase_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase_Vtbl {
        unsafe extern "system" fn SelectedItems<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ListViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ListViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn IsSwipeEnabled<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwipeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSwipeEnabled<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSwipeEnabled(value).into()
        }
        unsafe extern "system" fn CanDragItems<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanDragItems<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanDragItems(value).into()
        }
        unsafe extern "system" fn CanReorderItems<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanReorderItems<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanReorderItems(value).into()
        }
        unsafe extern "system" fn IsItemClickEnabled<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemClickEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsItemClickEnabled<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsItemClickEnabled(value).into()
        }
        unsafe extern "system" fn DataFetchSize<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataFetchSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDataFetchSize<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDataFetchSize(value).into()
        }
        unsafe extern "system" fn IncrementalLoadingThreshold<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingThreshold() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIncrementalLoadingThreshold<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIncrementalLoadingThreshold(value).into()
        }
        unsafe extern "system" fn IncrementalLoadingTrigger<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut IncrementalLoadingTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingTrigger() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIncrementalLoadingTrigger<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: IncrementalLoadingTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIncrementalLoadingTrigger(value).into()
        }
        unsafe extern "system" fn ItemClick<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemClick(&*(&handler as *const <ItemClickEventHandler as ::windows::core::Abi>::Abi as *const <ItemClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemClick<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsStarting<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsStarting(&*(&handler as *const <DragItemsStartingEventHandler as ::windows::core::Abi>::Abi as *const <DragItemsStartingEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsStarting<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollIntoView<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollIntoView(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn LoadMoreItemsAsync<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LoadMoreItemsAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollIntoViewWithAlignment<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, alignment: ScrollIntoViewAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollIntoViewWithAlignment(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), alignment).into()
        }
        unsafe extern "system" fn Header<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTransitions<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTransitions<Impl: IListViewBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase, BASE_OFFSET>(),
            SelectedItems: SelectedItems::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            IsSwipeEnabled: IsSwipeEnabled::<Impl, IMPL_OFFSET>,
            SetIsSwipeEnabled: SetIsSwipeEnabled::<Impl, IMPL_OFFSET>,
            CanDragItems: CanDragItems::<Impl, IMPL_OFFSET>,
            SetCanDragItems: SetCanDragItems::<Impl, IMPL_OFFSET>,
            CanReorderItems: CanReorderItems::<Impl, IMPL_OFFSET>,
            SetCanReorderItems: SetCanReorderItems::<Impl, IMPL_OFFSET>,
            IsItemClickEnabled: IsItemClickEnabled::<Impl, IMPL_OFFSET>,
            SetIsItemClickEnabled: SetIsItemClickEnabled::<Impl, IMPL_OFFSET>,
            DataFetchSize: DataFetchSize::<Impl, IMPL_OFFSET>,
            SetDataFetchSize: SetDataFetchSize::<Impl, IMPL_OFFSET>,
            IncrementalLoadingThreshold: IncrementalLoadingThreshold::<Impl, IMPL_OFFSET>,
            SetIncrementalLoadingThreshold: SetIncrementalLoadingThreshold::<Impl, IMPL_OFFSET>,
            IncrementalLoadingTrigger: IncrementalLoadingTrigger::<Impl, IMPL_OFFSET>,
            SetIncrementalLoadingTrigger: SetIncrementalLoadingTrigger::<Impl, IMPL_OFFSET>,
            ItemClick: ItemClick::<Impl, IMPL_OFFSET>,
            RemoveItemClick: RemoveItemClick::<Impl, IMPL_OFFSET>,
            DragItemsStarting: DragItemsStarting::<Impl, IMPL_OFFSET>,
            RemoveDragItemsStarting: RemoveDragItemsStarting::<Impl, IMPL_OFFSET>,
            ScrollIntoView: ScrollIntoView::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            LoadMoreItemsAsync: LoadMoreItemsAsync::<Impl, IMPL_OFFSET>,
            ScrollIntoViewWithAlignment: ScrollIntoViewWithAlignment::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            HeaderTransitions: HeaderTransitions::<Impl, IMPL_OFFSET>,
            SetHeaderTransitions: SetHeaderTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IListViewBase2_Impl: Sized {
    fn ShowsScrollingPlaceholders(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowsScrollingPlaceholders(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ContainerContentChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContainerContentChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDesiredContainerUpdateDuration(&mut self, duration: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn Footer(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetFooter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn FooterTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetFooterTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FooterTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetFooterTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IListViewBase2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase2_Vtbl {
        unsafe extern "system" fn ShowsScrollingPlaceholders<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowsScrollingPlaceholders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowsScrollingPlaceholders<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowsScrollingPlaceholders(value).into()
        }
        unsafe extern "system" fn ContainerContentChanging<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerContentChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContainerContentChanging<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContainerContentChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDesiredContainerUpdateDuration<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, duration: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDesiredContainerUpdateDuration(&*(&duration as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Footer<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Footer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooter<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTemplate<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTemplate<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTransitions<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTransitions<Impl: IListViewBase2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFooterTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase2, BASE_OFFSET>(),
            ShowsScrollingPlaceholders: ShowsScrollingPlaceholders::<Impl, IMPL_OFFSET>,
            SetShowsScrollingPlaceholders: SetShowsScrollingPlaceholders::<Impl, IMPL_OFFSET>,
            ContainerContentChanging: ContainerContentChanging::<Impl, IMPL_OFFSET>,
            RemoveContainerContentChanging: RemoveContainerContentChanging::<Impl, IMPL_OFFSET>,
            SetDesiredContainerUpdateDuration: SetDesiredContainerUpdateDuration::<Impl, IMPL_OFFSET>,
            Footer: Footer::<Impl, IMPL_OFFSET>,
            SetFooter: SetFooter::<Impl, IMPL_OFFSET>,
            FooterTemplate: FooterTemplate::<Impl, IMPL_OFFSET>,
            SetFooterTemplate: SetFooterTemplate::<Impl, IMPL_OFFSET>,
            FooterTransitions: FooterTransitions::<Impl, IMPL_OFFSET>,
            SetFooterTransitions: SetFooterTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase3_Impl: Sized {
    fn ReorderMode(&mut self) -> ::windows::core::Result<ListViewReorderMode>;
    fn SetReorderMode(&mut self, value: ListViewReorderMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase3";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase3_Vtbl {
        unsafe extern "system" fn ReorderMode<Impl: IListViewBase3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ListViewReorderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReorderMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReorderMode<Impl: IListViewBase3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ListViewReorderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetReorderMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase3, BASE_OFFSET>(),
            ReorderMode: ReorderMode::<Impl, IMPL_OFFSET>,
            SetReorderMode: SetReorderMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
pub trait IListViewBase4_Impl: Sized {
    fn SelectedRanges(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::Data::ItemIndexRange>>;
    fn IsMultiSelectCheckBoxEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsMultiSelectCheckBoxEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn DragItemsCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChoosingItemContainer(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChoosingItemContainer(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChoosingGroupHeaderContainer(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChoosingGroupHeaderContainer(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectRange(&mut self, itemindexrange: &::core::option::Option<super::Data::ItemIndexRange>) -> ::windows::core::Result<()>;
    fn DeselectRange(&mut self, itemindexrange: &::core::option::Option<super::Data::ItemIndexRange>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl IListViewBase4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase4_Vtbl {
        unsafe extern "system" fn SelectedRanges<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedRanges() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMultiSelectCheckBoxEnabled<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMultiSelectCheckBoxEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMultiSelectCheckBoxEnabled<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsMultiSelectCheckBoxEnabled(value).into()
        }
        unsafe extern "system" fn DragItemsCompleted<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsCompleted<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChoosingItemContainer<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChoosingItemContainer(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChoosingItemContainer<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveChoosingItemContainer(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChoosingGroupHeaderContainer<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChoosingGroupHeaderContainer(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChoosingGroupHeaderContainer<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveChoosingGroupHeaderContainer(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectRange<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemindexrange: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectRange(&*(&itemindexrange as *const <super::Data::ItemIndexRange as ::windows::core::Abi>::Abi as *const <super::Data::ItemIndexRange as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DeselectRange<Impl: IListViewBase4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, itemindexrange: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeselectRange(&*(&itemindexrange as *const <super::Data::ItemIndexRange as ::windows::core::Abi>::Abi as *const <super::Data::ItemIndexRange as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase4, BASE_OFFSET>(),
            SelectedRanges: SelectedRanges::<Impl, IMPL_OFFSET>,
            IsMultiSelectCheckBoxEnabled: IsMultiSelectCheckBoxEnabled::<Impl, IMPL_OFFSET>,
            SetIsMultiSelectCheckBoxEnabled: SetIsMultiSelectCheckBoxEnabled::<Impl, IMPL_OFFSET>,
            DragItemsCompleted: DragItemsCompleted::<Impl, IMPL_OFFSET>,
            RemoveDragItemsCompleted: RemoveDragItemsCompleted::<Impl, IMPL_OFFSET>,
            ChoosingItemContainer: ChoosingItemContainer::<Impl, IMPL_OFFSET>,
            RemoveChoosingItemContainer: RemoveChoosingItemContainer::<Impl, IMPL_OFFSET>,
            ChoosingGroupHeaderContainer: ChoosingGroupHeaderContainer::<Impl, IMPL_OFFSET>,
            RemoveChoosingGroupHeaderContainer: RemoveChoosingGroupHeaderContainer::<Impl, IMPL_OFFSET>,
            SelectRange: SelectRange::<Impl, IMPL_OFFSET>,
            DeselectRange: DeselectRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase5_Impl: Sized {
    fn SingleSelectionFollowsFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetSingleSelectionFollowsFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsDragSource(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase5";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase5_Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: IListViewBase5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSingleSelectionFollowsFocus<Impl: IListViewBase5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSingleSelectionFollowsFocus(value).into()
        }
        unsafe extern "system" fn IsDragSource<Impl: IListViewBase5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDragSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase5, BASE_OFFSET>(),
            SingleSelectionFollowsFocus: SingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            SetSingleSelectionFollowsFocus: SetSingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            IsDragSource: IsDragSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IListViewBase6_Impl: Sized {
    fn TryStartConnectedAnimationAsync(&mut self, animation: &::core::option::Option<super::Media::Animation::ConnectedAnimation>, item: &::core::option::Option<::windows::core::IInspectable>, elementname: &::windows::core::HSTRING) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<bool>>;
    fn PrepareConnectedAnimation(&mut self, key: &::windows::core::HSTRING, item: &::core::option::Option<::windows::core::IInspectable>, elementname: &::windows::core::HSTRING) -> ::windows::core::Result<super::Media::Animation::ConnectedAnimation>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewBase6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase6";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IListViewBase6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBase6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBase6_Vtbl {
        unsafe extern "system" fn TryStartConnectedAnimationAsync<Impl: IListViewBase6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, animation: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void, elementname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TryStartConnectedAnimationAsync(
                &*(&animation as *const <super::Media::Animation::ConnectedAnimation as ::windows::core::Abi>::Abi as *const <super::Media::Animation::ConnectedAnimation as ::windows::core::DefaultType>::DefaultType),
                &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&elementname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrepareConnectedAnimation<Impl: IListViewBase6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, key: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, item: *mut ::core::ffi::c_void, elementname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrepareConnectedAnimation(
                &*(&key as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
                &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&elementname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBase6, BASE_OFFSET>(),
            TryStartConnectedAnimationAsync: TryStartConnectedAnimationAsync::<Impl, IMPL_OFFSET>,
            PrepareConnectedAnimation: PrepareConnectedAnimation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBase6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewBase>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewBaseFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseHeaderItem_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseHeaderItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseHeaderItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseHeaderItem_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseHeaderItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseHeaderItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseHeaderItemFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseHeaderItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseHeaderItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseHeaderItemFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseHeaderItemFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseHeaderItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics_Impl: Sized {
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSwipeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanDragItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanReorderItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsItemClickEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DataFetchSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IncrementalLoadingThresholdProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IncrementalLoadingTriggerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SemanticZoomOwnerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsActiveViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics_Vtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSwipeEnabledProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSwipeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanDragItemsProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanReorderItemsProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsItemClickEnabledProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemClickEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DataFetchSizeProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataFetchSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IncrementalLoadingThresholdProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingThresholdProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IncrementalLoadingTriggerProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingTriggerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SemanticZoomOwnerProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwnerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActiveViewProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTransitionsProperty<Impl: IListViewBaseStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics, BASE_OFFSET>(),
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
            IsSwipeEnabledProperty: IsSwipeEnabledProperty::<Impl, IMPL_OFFSET>,
            CanDragItemsProperty: CanDragItemsProperty::<Impl, IMPL_OFFSET>,
            CanReorderItemsProperty: CanReorderItemsProperty::<Impl, IMPL_OFFSET>,
            IsItemClickEnabledProperty: IsItemClickEnabledProperty::<Impl, IMPL_OFFSET>,
            DataFetchSizeProperty: DataFetchSizeProperty::<Impl, IMPL_OFFSET>,
            IncrementalLoadingThresholdProperty: IncrementalLoadingThresholdProperty::<Impl, IMPL_OFFSET>,
            IncrementalLoadingTriggerProperty: IncrementalLoadingTriggerProperty::<Impl, IMPL_OFFSET>,
            SemanticZoomOwnerProperty: SemanticZoomOwnerProperty::<Impl, IMPL_OFFSET>,
            IsActiveViewProperty: IsActiveViewProperty::<Impl, IMPL_OFFSET>,
            IsZoomedInViewProperty: IsZoomedInViewProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            HeaderTransitionsProperty: HeaderTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics2_Impl: Sized {
    fn ShowsScrollingPlaceholdersProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics2_Vtbl {
        unsafe extern "system" fn ShowsScrollingPlaceholdersProperty<Impl: IListViewBaseStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowsScrollingPlaceholdersProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterProperty<Impl: IListViewBaseStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTemplateProperty<Impl: IListViewBaseStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTransitionsProperty<Impl: IListViewBaseStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FooterTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics2, BASE_OFFSET>(),
            ShowsScrollingPlaceholdersProperty: ShowsScrollingPlaceholdersProperty::<Impl, IMPL_OFFSET>,
            FooterProperty: FooterProperty::<Impl, IMPL_OFFSET>,
            FooterTemplateProperty: FooterTemplateProperty::<Impl, IMPL_OFFSET>,
            FooterTransitionsProperty: FooterTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics3_Impl: Sized {
    fn ReorderModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics3_Vtbl {
        unsafe extern "system" fn ReorderModeProperty<Impl: IListViewBaseStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReorderModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics3, BASE_OFFSET>(),
            ReorderModeProperty: ReorderModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics4_Impl: Sized {
    fn IsMultiSelectCheckBoxEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics4_Vtbl {
        unsafe extern "system" fn IsMultiSelectCheckBoxEnabledProperty<Impl: IListViewBaseStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMultiSelectCheckBoxEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics4, BASE_OFFSET>(),
            IsMultiSelectCheckBoxEnabledProperty: IsMultiSelectCheckBoxEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics5_Impl: Sized {
    fn SingleSelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewBaseStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewBaseStatics5_Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: IListViewBaseStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewBaseStatics5, BASE_OFFSET>(),
            SingleSelectionFollowsFocusProperty: SingleSelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewBaseStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewHeaderItem_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewHeaderItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewHeaderItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewHeaderItem_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewHeaderItem, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewHeaderItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewHeaderItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewHeaderItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewHeaderItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewHeaderItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewHeaderItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewHeaderItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewHeaderItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewHeaderItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IListViewItem_Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ListViewItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewItem";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IListViewItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewItem_Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IListViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewItem, BASE_OFFSET>(), TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewPersistenceHelper_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewPersistenceHelper {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewPersistenceHelper";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewPersistenceHelper_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewPersistenceHelper_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewPersistenceHelper_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewPersistenceHelper, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewPersistenceHelper as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IListViewPersistenceHelperStatics_Impl: Sized {
    fn GetRelativeScrollPosition(&mut self, listviewbase: &::core::option::Option<ListViewBase>, itemtokeyhandler: &::core::option::Option<ListViewItemToKeyHandler>) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetRelativeScrollPositionAsync(&mut self, listviewbase: &::core::option::Option<ListViewBase>, relativescrollposition: &::windows::core::HSTRING, keytoitemhandler: &::core::option::Option<ListViewKeyToItemHandler>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IListViewPersistenceHelperStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewPersistenceHelperStatics";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IListViewPersistenceHelperStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IListViewPersistenceHelperStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IListViewPersistenceHelperStatics_Vtbl {
        unsafe extern "system" fn GetRelativeScrollPosition<Impl: IListViewPersistenceHelperStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, listviewbase: ::windows::core::RawPtr, itemtokeyhandler: ::windows::core::RawPtr, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRelativeScrollPosition(&*(&listviewbase as *const <ListViewBase as ::windows::core::Abi>::Abi as *const <ListViewBase as ::windows::core::DefaultType>::DefaultType), &*(&itemtokeyhandler as *const <ListViewItemToKeyHandler as ::windows::core::Abi>::Abi as *const <ListViewItemToKeyHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRelativeScrollPositionAsync<Impl: IListViewPersistenceHelperStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, listviewbase: ::windows::core::RawPtr, relativescrollposition: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, keytoitemhandler: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetRelativeScrollPositionAsync(
                &*(&listviewbase as *const <ListViewBase as ::windows::core::Abi>::Abi as *const <ListViewBase as ::windows::core::DefaultType>::DefaultType),
                &*(&relativescrollposition as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
                &*(&keytoitemhandler as *const <ListViewKeyToItemHandler as ::windows::core::Abi>::Abi as *const <ListViewKeyToItemHandler as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IListViewPersistenceHelperStatics, BASE_OFFSET>(),
            GetRelativeScrollPosition: GetRelativeScrollPosition::<Impl, IMPL_OFFSET>,
            SetRelativeScrollPositionAsync: SetRelativeScrollPositionAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IListViewPersistenceHelperStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Media_PlayTo", feature = "Media_Protection", feature = "Storage_Streams", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaElement_Impl: Sized {
    fn PosterSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPosterSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn IsMuted(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsMuted(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsAudioOnly(&mut self) -> ::windows::core::Result<bool>;
    fn AutoPlay(&mut self) -> ::windows::core::Result<bool>;
    fn SetAutoPlay(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Volume(&mut self) -> ::windows::core::Result<f64>;
    fn SetVolume(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Balance(&mut self) -> ::windows::core::Result<f64>;
    fn SetBalance(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn NaturalVideoHeight(&mut self) -> ::windows::core::Result<i32>;
    fn NaturalVideoWidth(&mut self) -> ::windows::core::Result<i32>;
    fn NaturalDuration(&mut self) -> ::windows::core::Result<super::Duration>;
    fn Position(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetPosition(&mut self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn DownloadProgress(&mut self) -> ::windows::core::Result<f64>;
    fn BufferingProgress(&mut self) -> ::windows::core::Result<f64>;
    fn DownloadProgressOffset(&mut self) -> ::windows::core::Result<f64>;
    fn CurrentState(&mut self) -> ::windows::core::Result<super::Media::MediaElementState>;
    fn Markers(&mut self) -> ::windows::core::Result<super::Media::TimelineMarkerCollection>;
    fn CanSeek(&mut self) -> ::windows::core::Result<bool>;
    fn CanPause(&mut self) -> ::windows::core::Result<bool>;
    fn AudioStreamCount(&mut self) -> ::windows::core::Result<i32>;
    fn AudioStreamIndex(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<i32>>;
    fn SetAudioStreamIndex(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<()>;
    fn PlaybackRate(&mut self) -> ::windows::core::Result<f64>;
    fn SetPlaybackRate(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsLooping(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsLooping(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PlayToSource(&mut self) -> ::windows::core::Result<super::super::super::Media::PlayTo::PlayToSource>;
    fn DefaultPlaybackRate(&mut self) -> ::windows::core::Result<f64>;
    fn SetDefaultPlaybackRate(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn AspectRatioWidth(&mut self) -> ::windows::core::Result<i32>;
    fn AspectRatioHeight(&mut self) -> ::windows::core::Result<i32>;
    fn RealTimePlayback(&mut self) -> ::windows::core::Result<bool>;
    fn SetRealTimePlayback(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AudioCategory(&mut self) -> ::windows::core::Result<super::Media::AudioCategory>;
    fn SetAudioCategory(&mut self, value: super::Media::AudioCategory) -> ::windows::core::Result<()>;
    fn AudioDeviceType(&mut self) -> ::windows::core::Result<super::Media::AudioDeviceType>;
    fn SetAudioDeviceType(&mut self, value: super::Media::AudioDeviceType) -> ::windows::core::Result<()>;
    fn ProtectionManager(&mut self) -> ::windows::core::Result<super::super::super::Media::Protection::MediaProtectionManager>;
    fn SetProtectionManager(&mut self, value: &::core::option::Option<super::super::super::Media::Protection::MediaProtectionManager>) -> ::windows::core::Result<()>;
    fn Stereo3DVideoPackingMode(&mut self) -> ::windows::core::Result<super::Media::Stereo3DVideoPackingMode>;
    fn SetStereo3DVideoPackingMode(&mut self, value: super::Media::Stereo3DVideoPackingMode) -> ::windows::core::Result<()>;
    fn Stereo3DVideoRenderMode(&mut self) -> ::windows::core::Result<super::Media::Stereo3DVideoRenderMode>;
    fn SetStereo3DVideoRenderMode(&mut self, value: super::Media::Stereo3DVideoRenderMode) -> ::windows::core::Result<()>;
    fn IsStereo3DVideo(&mut self) -> ::windows::core::Result<bool>;
    fn MediaOpened(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MediaEnded(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaEnded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MediaFailed(&mut self, handler: &::core::option::Option<super::ExceptionRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DownloadProgressChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDownloadProgressChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn BufferingProgressChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBufferingProgressChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CurrentStateChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCurrentStateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MarkerReached(&mut self, handler: &::core::option::Option<super::Media::TimelineMarkerRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMarkerReached(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RateChanged(&mut self, handler: &::core::option::Option<super::Media::RateChangedRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn VolumeChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveVolumeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SeekCompleted(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSeekCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Play(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn CanPlayType(&mut self, r#type: &::windows::core::HSTRING) -> ::windows::core::Result<super::Media::MediaCanPlayResponse>;
    fn SetSource2(&mut self, stream: &::core::option::Option<super::super::super::Storage::Streams::IRandomAccessStream>, mimetype: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn GetAudioStreamLanguage(&mut self, index: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn AddAudioEffect(&mut self, effectid: &::windows::core::HSTRING, effectoptional: bool, effectconfiguration: &::core::option::Option<super::super::super::Foundation::Collections::IPropertySet>) -> ::windows::core::Result<()>;
    fn AddVideoEffect(&mut self, effectid: &::windows::core::HSTRING, effectoptional: bool, effectconfiguration: &::core::option::Option<super::super::super::Foundation::Collections::IPropertySet>) -> ::windows::core::Result<()>;
    fn RemoveAllEffects(&mut self) -> ::windows::core::Result<()>;
    fn ActualStereo3DVideoPackingMode(&mut self) -> ::windows::core::Result<super::Media::Stereo3DVideoPackingMode>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Media_PlayTo", feature = "Media_Protection", feature = "Storage_Streams", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Media_PlayTo", feature = "Media_Protection", feature = "Storage_Streams", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaElement_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElement_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElement_Vtbl {
        unsafe extern "system" fn PosterSource<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosterSource<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPosterSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Source<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsMuted<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMuted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMuted<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsMuted(value).into()
        }
        unsafe extern "system" fn IsAudioOnly<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAudioOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlay<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoPlay(value).into()
        }
        unsafe extern "system" fn Volume<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Volume() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVolume<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVolume(value).into()
        }
        unsafe extern "system" fn Balance<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Balance() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBalance(value).into()
        }
        unsafe extern "system" fn NaturalVideoHeight<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoWidth<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalDuration<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Duration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Position<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Position() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosition<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPosition(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DownloadProgress<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgress() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingProgress<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BufferingProgress() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressOffset<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentState<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::MediaElementState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Markers<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Markers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeek<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanSeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanPause<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamCount<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamIndex<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioStreamIndex<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioStreamIndex(&*(&value as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaybackRate<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaybackRate<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaybackRate(value).into()
        }
        unsafe extern "system" fn IsLooping<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLooping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsLooping<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsLooping(value).into()
        }
        unsafe extern "system" fn PlayToSource<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPlaybackRate<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultPlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultPlaybackRate<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultPlaybackRate(value).into()
        }
        unsafe extern "system" fn AspectRatioWidth<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioHeight<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RealTimePlayback<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RealTimePlayback() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRealTimePlayback<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRealTimePlayback(value).into()
        }
        unsafe extern "system" fn AudioCategory<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::AudioCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioCategory() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioCategory<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::AudioCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioCategory(value).into()
        }
        unsafe extern "system" fn AudioDeviceType<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::AudioDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioDeviceType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioDeviceType<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::AudioDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioDeviceType(value).into()
        }
        unsafe extern "system" fn ProtectionManager<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProtectionManager() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProtectionManager<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProtectionManager(&*(&value as *const <super::super::super::Media::Protection::MediaProtectionManager as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Protection::MediaProtectionManager as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stereo3DVideoPackingMode<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoPackingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DVideoPackingMode<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStereo3DVideoPackingMode(value).into()
        }
        unsafe extern "system" fn Stereo3DVideoRenderMode<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoRenderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoRenderMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DVideoRenderMode<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stereo3DVideoRenderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStereo3DVideoRenderMode(value).into()
        }
        unsafe extern "system" fn IsStereo3DVideo<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStereo3DVideo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaOpened<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaOpened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaOpened<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMediaOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MediaEnded<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaEnded(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaEnded<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMediaEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MediaFailed<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaFailed(&*(&handler as *const <super::ExceptionRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::ExceptionRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaFailed<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMediaFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DownloadProgressChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDownloadProgressChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDownloadProgressChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BufferingProgressChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BufferingProgressChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBufferingProgressChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBufferingProgressChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CurrentStateChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentStateChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCurrentStateChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCurrentStateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MarkerReached<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MarkerReached(&*(&handler as *const <super::Media::TimelineMarkerRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::Media::TimelineMarkerRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMarkerReached<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMarkerReached(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RateChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RateChanged(&*(&handler as *const <super::Media::RateChangedRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::Media::RateChangedRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRateChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VolumeChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VolumeChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveVolumeChanged<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveVolumeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SeekCompleted<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SeekCompleted(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSeekCompleted<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSeekCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stop<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Play<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Play().into()
        }
        unsafe extern "system" fn Pause<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn CanPlayType<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut super::Media::MediaCanPlayResponse) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPlayType(&*(&r#type as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource2<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stream: ::windows::core::RawPtr, mimetype: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource2(&*(&stream as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::Abi>::Abi as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::DefaultType>::DefaultType), &*(&mimetype as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetAudioStreamLanguage<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::windows::core::RawPtr, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioStreamLanguage(&*(&index as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddAudioEffect<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, effectid: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, effectoptional: bool, effectconfiguration: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddAudioEffect(&*(&effectid as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), effectoptional, &*(&effectconfiguration as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AddVideoEffect<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, effectid: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, effectoptional: bool, effectconfiguration: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddVideoEffect(&*(&effectid as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), effectoptional, &*(&effectconfiguration as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllEffects().into()
        }
        unsafe extern "system" fn ActualStereo3DVideoPackingMode<Impl: IMediaElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualStereo3DVideoPackingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElement, BASE_OFFSET>(),
            PosterSource: PosterSource::<Impl, IMPL_OFFSET>,
            SetPosterSource: SetPosterSource::<Impl, IMPL_OFFSET>,
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            IsMuted: IsMuted::<Impl, IMPL_OFFSET>,
            SetIsMuted: SetIsMuted::<Impl, IMPL_OFFSET>,
            IsAudioOnly: IsAudioOnly::<Impl, IMPL_OFFSET>,
            AutoPlay: AutoPlay::<Impl, IMPL_OFFSET>,
            SetAutoPlay: SetAutoPlay::<Impl, IMPL_OFFSET>,
            Volume: Volume::<Impl, IMPL_OFFSET>,
            SetVolume: SetVolume::<Impl, IMPL_OFFSET>,
            Balance: Balance::<Impl, IMPL_OFFSET>,
            SetBalance: SetBalance::<Impl, IMPL_OFFSET>,
            NaturalVideoHeight: NaturalVideoHeight::<Impl, IMPL_OFFSET>,
            NaturalVideoWidth: NaturalVideoWidth::<Impl, IMPL_OFFSET>,
            NaturalDuration: NaturalDuration::<Impl, IMPL_OFFSET>,
            Position: Position::<Impl, IMPL_OFFSET>,
            SetPosition: SetPosition::<Impl, IMPL_OFFSET>,
            DownloadProgress: DownloadProgress::<Impl, IMPL_OFFSET>,
            BufferingProgress: BufferingProgress::<Impl, IMPL_OFFSET>,
            DownloadProgressOffset: DownloadProgressOffset::<Impl, IMPL_OFFSET>,
            CurrentState: CurrentState::<Impl, IMPL_OFFSET>,
            Markers: Markers::<Impl, IMPL_OFFSET>,
            CanSeek: CanSeek::<Impl, IMPL_OFFSET>,
            CanPause: CanPause::<Impl, IMPL_OFFSET>,
            AudioStreamCount: AudioStreamCount::<Impl, IMPL_OFFSET>,
            AudioStreamIndex: AudioStreamIndex::<Impl, IMPL_OFFSET>,
            SetAudioStreamIndex: SetAudioStreamIndex::<Impl, IMPL_OFFSET>,
            PlaybackRate: PlaybackRate::<Impl, IMPL_OFFSET>,
            SetPlaybackRate: SetPlaybackRate::<Impl, IMPL_OFFSET>,
            IsLooping: IsLooping::<Impl, IMPL_OFFSET>,
            SetIsLooping: SetIsLooping::<Impl, IMPL_OFFSET>,
            PlayToSource: PlayToSource::<Impl, IMPL_OFFSET>,
            DefaultPlaybackRate: DefaultPlaybackRate::<Impl, IMPL_OFFSET>,
            SetDefaultPlaybackRate: SetDefaultPlaybackRate::<Impl, IMPL_OFFSET>,
            AspectRatioWidth: AspectRatioWidth::<Impl, IMPL_OFFSET>,
            AspectRatioHeight: AspectRatioHeight::<Impl, IMPL_OFFSET>,
            RealTimePlayback: RealTimePlayback::<Impl, IMPL_OFFSET>,
            SetRealTimePlayback: SetRealTimePlayback::<Impl, IMPL_OFFSET>,
            AudioCategory: AudioCategory::<Impl, IMPL_OFFSET>,
            SetAudioCategory: SetAudioCategory::<Impl, IMPL_OFFSET>,
            AudioDeviceType: AudioDeviceType::<Impl, IMPL_OFFSET>,
            SetAudioDeviceType: SetAudioDeviceType::<Impl, IMPL_OFFSET>,
            ProtectionManager: ProtectionManager::<Impl, IMPL_OFFSET>,
            SetProtectionManager: SetProtectionManager::<Impl, IMPL_OFFSET>,
            Stereo3DVideoPackingMode: Stereo3DVideoPackingMode::<Impl, IMPL_OFFSET>,
            SetStereo3DVideoPackingMode: SetStereo3DVideoPackingMode::<Impl, IMPL_OFFSET>,
            Stereo3DVideoRenderMode: Stereo3DVideoRenderMode::<Impl, IMPL_OFFSET>,
            SetStereo3DVideoRenderMode: SetStereo3DVideoRenderMode::<Impl, IMPL_OFFSET>,
            IsStereo3DVideo: IsStereo3DVideo::<Impl, IMPL_OFFSET>,
            MediaOpened: MediaOpened::<Impl, IMPL_OFFSET>,
            RemoveMediaOpened: RemoveMediaOpened::<Impl, IMPL_OFFSET>,
            MediaEnded: MediaEnded::<Impl, IMPL_OFFSET>,
            RemoveMediaEnded: RemoveMediaEnded::<Impl, IMPL_OFFSET>,
            MediaFailed: MediaFailed::<Impl, IMPL_OFFSET>,
            RemoveMediaFailed: RemoveMediaFailed::<Impl, IMPL_OFFSET>,
            DownloadProgressChanged: DownloadProgressChanged::<Impl, IMPL_OFFSET>,
            RemoveDownloadProgressChanged: RemoveDownloadProgressChanged::<Impl, IMPL_OFFSET>,
            BufferingProgressChanged: BufferingProgressChanged::<Impl, IMPL_OFFSET>,
            RemoveBufferingProgressChanged: RemoveBufferingProgressChanged::<Impl, IMPL_OFFSET>,
            CurrentStateChanged: CurrentStateChanged::<Impl, IMPL_OFFSET>,
            RemoveCurrentStateChanged: RemoveCurrentStateChanged::<Impl, IMPL_OFFSET>,
            MarkerReached: MarkerReached::<Impl, IMPL_OFFSET>,
            RemoveMarkerReached: RemoveMarkerReached::<Impl, IMPL_OFFSET>,
            RateChanged: RateChanged::<Impl, IMPL_OFFSET>,
            RemoveRateChanged: RemoveRateChanged::<Impl, IMPL_OFFSET>,
            VolumeChanged: VolumeChanged::<Impl, IMPL_OFFSET>,
            RemoveVolumeChanged: RemoveVolumeChanged::<Impl, IMPL_OFFSET>,
            SeekCompleted: SeekCompleted::<Impl, IMPL_OFFSET>,
            RemoveSeekCompleted: RemoveSeekCompleted::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Play: Play::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            CanPlayType: CanPlayType::<Impl, IMPL_OFFSET>,
            SetSource2: SetSource2::<Impl, IMPL_OFFSET>,
            GetAudioStreamLanguage: GetAudioStreamLanguage::<Impl, IMPL_OFFSET>,
            AddAudioEffect: AddAudioEffect::<Impl, IMPL_OFFSET>,
            AddVideoEffect: AddVideoEffect::<Impl, IMPL_OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Impl, IMPL_OFFSET>,
            ActualStereo3DVideoPackingMode: ActualStereo3DVideoPackingMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElement as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Media_Core", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaElement2_Impl: Sized {
    fn AreTransportControlsEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreTransportControlsEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn IsFullWindow(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SetMediaStreamSource(&mut self, source: &::core::option::Option<super::super::super::Media::Core::IMediaSource>) -> ::windows::core::Result<()>;
    fn PlayToPreferredSourceUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetPlayToPreferredSourceUri(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Media_Core", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaElement2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement2";
}
#[cfg(all(feature = "Foundation", feature = "Media_Core", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaElement2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElement2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElement2_Vtbl {
        unsafe extern "system" fn AreTransportControlsEnabled<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreTransportControlsEnabled<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreTransportControlsEnabled(value).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        unsafe extern "system" fn SetMediaStreamSource<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaStreamSource(&*(&source as *const <super::super::super::Media::Core::IMediaSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Core::IMediaSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlayToPreferredSourceUri<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToPreferredSourceUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlayToPreferredSourceUri<Impl: IMediaElement2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlayToPreferredSourceUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElement2, BASE_OFFSET>(),
            AreTransportControlsEnabled: AreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            SetAreTransportControlsEnabled: SetAreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            IsFullWindow: IsFullWindow::<Impl, IMPL_OFFSET>,
            SetIsFullWindow: SetIsFullWindow::<Impl, IMPL_OFFSET>,
            SetMediaStreamSource: SetMediaStreamSource::<Impl, IMPL_OFFSET>,
            PlayToPreferredSourceUri: PlayToPreferredSourceUri::<Impl, IMPL_OFFSET>,
            SetPlayToPreferredSourceUri: SetPlayToPreferredSourceUri::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElement2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Media_Casting", feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaElement3_Impl: Sized {
    fn TransportControls(&mut self) -> ::windows::core::Result<MediaTransportControls>;
    fn SetTransportControls(&mut self, value: &::core::option::Option<MediaTransportControls>) -> ::windows::core::Result<()>;
    fn PartialMediaFailureDetected(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePartialMediaFailureDetected(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetPlaybackSource(&mut self, source: &::core::option::Option<super::super::super::Media::Playback::IMediaPlaybackSource>) -> ::windows::core::Result<()>;
    fn GetAsCastingSource(&mut self) -> ::windows::core::Result<super::super::super::Media::Casting::CastingSource>;
}
#[cfg(all(feature = "Foundation", feature = "Media_Casting", feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaElement3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement3";
}
#[cfg(all(feature = "Foundation", feature = "Media_Casting", feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaElement3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElement3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElement3_Vtbl {
        unsafe extern "system" fn TransportControls<Impl: IMediaElement3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TransportControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportControls<Impl: IMediaElement3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransportControls(&*(&value as *const <MediaTransportControls as ::windows::core::Abi>::Abi as *const <MediaTransportControls as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PartialMediaFailureDetected<Impl: IMediaElement3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PartialMediaFailureDetected(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePartialMediaFailureDetected<Impl: IMediaElement3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePartialMediaFailureDetected(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetPlaybackSource<Impl: IMediaElement3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaybackSource(&*(&source as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetAsCastingSource<Impl: IMediaElement3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAsCastingSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElement3, BASE_OFFSET>(),
            TransportControls: TransportControls::<Impl, IMPL_OFFSET>,
            SetTransportControls: SetTransportControls::<Impl, IMPL_OFFSET>,
            PartialMediaFailureDetected: PartialMediaFailureDetected::<Impl, IMPL_OFFSET>,
            RemovePartialMediaFailureDetected: RemovePartialMediaFailureDetected::<Impl, IMPL_OFFSET>,
            SetPlaybackSource: SetPlaybackSource::<Impl, IMPL_OFFSET>,
            GetAsCastingSource: GetAsCastingSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElement3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElementStatics_Impl: Sized {
    fn PosterSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsMutedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAudioOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoPlayProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VolumeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BalanceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalVideoHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalVideoWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalDurationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PositionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DownloadProgressProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BufferingProgressProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DownloadProgressOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CurrentStateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanSeekProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanPauseProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioStreamCountProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioStreamIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaybackRateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsLoopingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultPlaybackRateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AspectRatioWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AspectRatioHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RealTimePlaybackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioCategoryProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioDeviceTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProtectionManagerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Stereo3DVideoPackingModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Stereo3DVideoRenderModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStereo3DVideoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ActualStereo3DVideoPackingModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElementStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElementStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElementStatics_Vtbl {
        unsafe extern "system" fn PosterSourceProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMutedProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMutedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAudioOnlyProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAudioOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlayProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VolumeProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VolumeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BalanceProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BalanceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoHeightProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoWidthProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalVideoWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalDurationProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NaturalDurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PositionProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingProgressProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BufferingProgressProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressOffsetProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DownloadProgressOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentStateProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentStateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeekProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanSeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanPauseProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPauseProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamCountProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamCountProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamIndexProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaybackRateProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaybackRateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsLoopingProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLoopingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToSourceProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPlaybackRateProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultPlaybackRateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioWidthProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioHeightProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AspectRatioHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RealTimePlaybackProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RealTimePlaybackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioCategoryProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioCategoryProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioDeviceTypeProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioDeviceTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtectionManagerProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProtectionManagerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stereo3DVideoPackingModeProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoPackingModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stereo3DVideoRenderModeProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoRenderModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStereo3DVideoProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStereo3DVideoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActualStereo3DVideoPackingModeProperty<Impl: IMediaElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualStereo3DVideoPackingModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElementStatics, BASE_OFFSET>(),
            PosterSourceProperty: PosterSourceProperty::<Impl, IMPL_OFFSET>,
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            IsMutedProperty: IsMutedProperty::<Impl, IMPL_OFFSET>,
            IsAudioOnlyProperty: IsAudioOnlyProperty::<Impl, IMPL_OFFSET>,
            AutoPlayProperty: AutoPlayProperty::<Impl, IMPL_OFFSET>,
            VolumeProperty: VolumeProperty::<Impl, IMPL_OFFSET>,
            BalanceProperty: BalanceProperty::<Impl, IMPL_OFFSET>,
            NaturalVideoHeightProperty: NaturalVideoHeightProperty::<Impl, IMPL_OFFSET>,
            NaturalVideoWidthProperty: NaturalVideoWidthProperty::<Impl, IMPL_OFFSET>,
            NaturalDurationProperty: NaturalDurationProperty::<Impl, IMPL_OFFSET>,
            PositionProperty: PositionProperty::<Impl, IMPL_OFFSET>,
            DownloadProgressProperty: DownloadProgressProperty::<Impl, IMPL_OFFSET>,
            BufferingProgressProperty: BufferingProgressProperty::<Impl, IMPL_OFFSET>,
            DownloadProgressOffsetProperty: DownloadProgressOffsetProperty::<Impl, IMPL_OFFSET>,
            CurrentStateProperty: CurrentStateProperty::<Impl, IMPL_OFFSET>,
            CanSeekProperty: CanSeekProperty::<Impl, IMPL_OFFSET>,
            CanPauseProperty: CanPauseProperty::<Impl, IMPL_OFFSET>,
            AudioStreamCountProperty: AudioStreamCountProperty::<Impl, IMPL_OFFSET>,
            AudioStreamIndexProperty: AudioStreamIndexProperty::<Impl, IMPL_OFFSET>,
            PlaybackRateProperty: PlaybackRateProperty::<Impl, IMPL_OFFSET>,
            IsLoopingProperty: IsLoopingProperty::<Impl, IMPL_OFFSET>,
            PlayToSourceProperty: PlayToSourceProperty::<Impl, IMPL_OFFSET>,
            DefaultPlaybackRateProperty: DefaultPlaybackRateProperty::<Impl, IMPL_OFFSET>,
            AspectRatioWidthProperty: AspectRatioWidthProperty::<Impl, IMPL_OFFSET>,
            AspectRatioHeightProperty: AspectRatioHeightProperty::<Impl, IMPL_OFFSET>,
            RealTimePlaybackProperty: RealTimePlaybackProperty::<Impl, IMPL_OFFSET>,
            AudioCategoryProperty: AudioCategoryProperty::<Impl, IMPL_OFFSET>,
            AudioDeviceTypeProperty: AudioDeviceTypeProperty::<Impl, IMPL_OFFSET>,
            ProtectionManagerProperty: ProtectionManagerProperty::<Impl, IMPL_OFFSET>,
            Stereo3DVideoPackingModeProperty: Stereo3DVideoPackingModeProperty::<Impl, IMPL_OFFSET>,
            Stereo3DVideoRenderModeProperty: Stereo3DVideoRenderModeProperty::<Impl, IMPL_OFFSET>,
            IsStereo3DVideoProperty: IsStereo3DVideoProperty::<Impl, IMPL_OFFSET>,
            ActualStereo3DVideoPackingModeProperty: ActualStereo3DVideoPackingModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElementStatics2_Impl: Sized {
    fn AreTransportControlsEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToPreferredSourceUriProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElementStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElementStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElementStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaElementStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaElementStatics2_Vtbl {
        unsafe extern "system" fn AreTransportControlsEnabledProperty<Impl: IMediaElementStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaElementStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaElementStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToPreferredSourceUriProperty<Impl: IMediaElementStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayToPreferredSourceUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaElementStatics2, BASE_OFFSET>(),
            AreTransportControlsEnabledProperty: AreTransportControlsEnabledProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowProperty: IsFullWindowProperty::<Impl, IMPL_OFFSET>,
            PlayToPreferredSourceUriProperty: PlayToPreferredSourceUriProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaElementStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaPlayerElement_Impl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Media::Playback::IMediaPlaybackSource>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Media::Playback::IMediaPlaybackSource>) -> ::windows::core::Result<()>;
    fn TransportControls(&mut self) -> ::windows::core::Result<MediaTransportControls>;
    fn SetTransportControls(&mut self, value: &::core::option::Option<MediaTransportControls>) -> ::windows::core::Result<()>;
    fn AreTransportControlsEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreTransportControlsEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PosterSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPosterSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn AutoPlay(&mut self) -> ::windows::core::Result<bool>;
    fn SetAutoPlay(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFullWindow(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MediaPlayer(&mut self) -> ::windows::core::Result<super::super::super::Media::Playback::MediaPlayer>;
    fn SetMediaPlayer(&mut self, mediaplayer: &::core::option::Option<super::super::super::Media::Playback::MediaPlayer>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaPlayerElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElement";
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaPlayerElement_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerElement_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerElement_Vtbl {
        unsafe extern "system" fn Source<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TransportControls<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TransportControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportControls<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransportControls(&*(&value as *const <MediaTransportControls as ::windows::core::Abi>::Abi as *const <MediaTransportControls as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AreTransportControlsEnabled<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreTransportControlsEnabled<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreTransportControlsEnabled(value).into()
        }
        unsafe extern "system" fn PosterSource<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosterSource<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPosterSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn AutoPlay<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoPlay(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        unsafe extern "system" fn MediaPlayer<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaPlayer<Impl: IMediaPlayerElement_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediaplayer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaPlayer(&*(&mediaplayer as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerElement, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            TransportControls: TransportControls::<Impl, IMPL_OFFSET>,
            SetTransportControls: SetTransportControls::<Impl, IMPL_OFFSET>,
            AreTransportControlsEnabled: AreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            SetAreTransportControlsEnabled: SetAreTransportControlsEnabled::<Impl, IMPL_OFFSET>,
            PosterSource: PosterSource::<Impl, IMPL_OFFSET>,
            SetPosterSource: SetPosterSource::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            AutoPlay: AutoPlay::<Impl, IMPL_OFFSET>,
            SetAutoPlay: SetAutoPlay::<Impl, IMPL_OFFSET>,
            IsFullWindow: IsFullWindow::<Impl, IMPL_OFFSET>,
            SetIsFullWindow: SetIsFullWindow::<Impl, IMPL_OFFSET>,
            MediaPlayer: MediaPlayer::<Impl, IMPL_OFFSET>,
            SetMediaPlayer: SetMediaPlayer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerElement as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerElementFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaPlayerElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerElementFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerElementFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerElementFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaPlayerElementFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerElementFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerElementFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerElementStatics_Impl: Sized {
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AreTransportControlsEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PosterSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoPlayProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MediaPlayerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerElementStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerElementStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerElementStatics_Vtbl {
        unsafe extern "system" fn SourceProperty<Impl: IMediaPlayerElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreTransportControlsEnabledProperty<Impl: IMediaPlayerElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PosterSourceProperty<Impl: IMediaPlayerElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PosterSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaPlayerElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlayProperty<Impl: IMediaPlayerElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoPlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaPlayerElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaPlayerProperty<Impl: IMediaPlayerElementStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerElementStatics, BASE_OFFSET>(),
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            AreTransportControlsEnabledProperty: AreTransportControlsEnabledProperty::<Impl, IMPL_OFFSET>,
            PosterSourceProperty: PosterSourceProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            AutoPlayProperty: AutoPlayProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowProperty: IsFullWindowProperty::<Impl, IMPL_OFFSET>,
            MediaPlayerProperty: MediaPlayerProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerElementStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaPlayerPresenter_Impl: Sized {
    fn MediaPlayer(&mut self) -> ::windows::core::Result<super::super::super::Media::Playback::MediaPlayer>;
    fn SetMediaPlayer(&mut self, value: &::core::option::Option<super::super::super::Media::Playback::MediaPlayer>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn IsFullWindow(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaPlayerPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenter";
}
#[cfg(all(feature = "Media_Playback", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaPlayerPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerPresenter_Vtbl {
        unsafe extern "system" fn MediaPlayer<Impl: IMediaPlayerPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaPlayer<Impl: IMediaPlayerPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaPlayer(&*(&value as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaPlayerPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaPlayerPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaPlayerPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaPlayerPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerPresenter, BASE_OFFSET>(),
            MediaPlayer: MediaPlayer::<Impl, IMPL_OFFSET>,
            SetMediaPlayer: SetMediaPlayer::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            IsFullWindow: IsFullWindow::<Impl, IMPL_OFFSET>,
            SetIsFullWindow: SetIsFullWindow::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerPresenterFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaPlayerPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerPresenterFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerPresenterFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerPresenterFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaPlayerPresenterFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerPresenterStatics_Impl: Sized {
    fn MediaPlayerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerPresenterStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPlayerPresenterStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPlayerPresenterStatics_Vtbl {
        unsafe extern "system" fn MediaPlayerProperty<Impl: IMediaPlayerPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaPlayerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaPlayerPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaPlayerPresenterStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaPlayerPresenterStatics, BASE_OFFSET>(),
            MediaPlayerProperty: MediaPlayerProperty::<Impl, IMPL_OFFSET>,
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowProperty: IsFullWindowProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPlayerPresenterStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls_Impl: Sized {
    fn IsFullWindowButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindowButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFullWindowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastForwardButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastForwardButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastForwardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastForwardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastRewindButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastRewindButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastRewindEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsFastRewindEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsStopButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsStopButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsStopEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsStopEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVolumeButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVolumeButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVolumeEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVolumeEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPlaybackRateButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPlaybackRateButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPlaybackRateEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPlaybackRateEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSeekBarVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSeekBarVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSeekEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSeekEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCompact(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompact(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControls_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControls_Vtbl {
        unsafe extern "system" fn IsFullWindowButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindowButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindowButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFullWindowEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindowEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFullWindowEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomButtonVisible(value).into()
        }
        unsafe extern "system" fn IsZoomEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomEnabled(value).into()
        }
        unsafe extern "system" fn IsFastForwardButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastForwardButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastForwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFastForwardEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastForwardEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastForwardEnabled(value).into()
        }
        unsafe extern "system" fn IsFastRewindButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastRewindButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastRewindButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFastRewindEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastRewindEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsFastRewindEnabled(value).into()
        }
        unsafe extern "system" fn IsStopButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStopButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsStopButtonVisible(value).into()
        }
        unsafe extern "system" fn IsStopEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStopEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsStopEnabled(value).into()
        }
        unsafe extern "system" fn IsVolumeButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVolumeButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVolumeButtonVisible(value).into()
        }
        unsafe extern "system" fn IsVolumeEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVolumeEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVolumeEnabled(value).into()
        }
        unsafe extern "system" fn IsPlaybackRateButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPlaybackRateButtonVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPlaybackRateButtonVisible(value).into()
        }
        unsafe extern "system" fn IsPlaybackRateEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPlaybackRateEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPlaybackRateEnabled(value).into()
        }
        unsafe extern "system" fn IsSeekBarVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekBarVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSeekBarVisible<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSeekBarVisible(value).into()
        }
        unsafe extern "system" fn IsSeekEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSeekEnabled<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSeekEnabled(value).into()
        }
        unsafe extern "system" fn IsCompact<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompact<Impl: IMediaTransportControls_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompact(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls, BASE_OFFSET>(),
            IsFullWindowButtonVisible: IsFullWindowButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsFullWindowButtonVisible: SetIsFullWindowButtonVisible::<Impl, IMPL_OFFSET>,
            IsFullWindowEnabled: IsFullWindowEnabled::<Impl, IMPL_OFFSET>,
            SetIsFullWindowEnabled: SetIsFullWindowEnabled::<Impl, IMPL_OFFSET>,
            IsZoomButtonVisible: IsZoomButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsZoomButtonVisible: SetIsZoomButtonVisible::<Impl, IMPL_OFFSET>,
            IsZoomEnabled: IsZoomEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomEnabled: SetIsZoomEnabled::<Impl, IMPL_OFFSET>,
            IsFastForwardButtonVisible: IsFastForwardButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsFastForwardButtonVisible: SetIsFastForwardButtonVisible::<Impl, IMPL_OFFSET>,
            IsFastForwardEnabled: IsFastForwardEnabled::<Impl, IMPL_OFFSET>,
            SetIsFastForwardEnabled: SetIsFastForwardEnabled::<Impl, IMPL_OFFSET>,
            IsFastRewindButtonVisible: IsFastRewindButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsFastRewindButtonVisible: SetIsFastRewindButtonVisible::<Impl, IMPL_OFFSET>,
            IsFastRewindEnabled: IsFastRewindEnabled::<Impl, IMPL_OFFSET>,
            SetIsFastRewindEnabled: SetIsFastRewindEnabled::<Impl, IMPL_OFFSET>,
            IsStopButtonVisible: IsStopButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsStopButtonVisible: SetIsStopButtonVisible::<Impl, IMPL_OFFSET>,
            IsStopEnabled: IsStopEnabled::<Impl, IMPL_OFFSET>,
            SetIsStopEnabled: SetIsStopEnabled::<Impl, IMPL_OFFSET>,
            IsVolumeButtonVisible: IsVolumeButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsVolumeButtonVisible: SetIsVolumeButtonVisible::<Impl, IMPL_OFFSET>,
            IsVolumeEnabled: IsVolumeEnabled::<Impl, IMPL_OFFSET>,
            SetIsVolumeEnabled: SetIsVolumeEnabled::<Impl, IMPL_OFFSET>,
            IsPlaybackRateButtonVisible: IsPlaybackRateButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsPlaybackRateButtonVisible: SetIsPlaybackRateButtonVisible::<Impl, IMPL_OFFSET>,
            IsPlaybackRateEnabled: IsPlaybackRateEnabled::<Impl, IMPL_OFFSET>,
            SetIsPlaybackRateEnabled: SetIsPlaybackRateEnabled::<Impl, IMPL_OFFSET>,
            IsSeekBarVisible: IsSeekBarVisible::<Impl, IMPL_OFFSET>,
            SetIsSeekBarVisible: SetIsSeekBarVisible::<Impl, IMPL_OFFSET>,
            IsSeekEnabled: IsSeekEnabled::<Impl, IMPL_OFFSET>,
            SetIsSeekEnabled: SetIsSeekEnabled::<Impl, IMPL_OFFSET>,
            IsCompact: IsCompact::<Impl, IMPL_OFFSET>,
            SetIsCompact: SetIsCompact::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IMediaTransportControls2_Impl: Sized {
    fn IsSkipForwardButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipForwardButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipForwardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipForwardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipBackwardButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipBackwardButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipBackwardEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSkipBackwardEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsNextTrackButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsNextTrackButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPreviousTrackButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPreviousTrackButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn FastPlayFallbackBehaviour(&mut self) -> ::windows::core::Result<super::Media::FastPlayFallbackBehaviour>;
    fn SetFastPlayFallbackBehaviour(&mut self, value: super::Media::FastPlayFallbackBehaviour) -> ::windows::core::Result<()>;
    fn ThumbnailRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveThumbnailRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaTransportControls2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IMediaTransportControls2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControls2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControls2_Vtbl {
        unsafe extern "system" fn IsSkipForwardButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipForwardButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipForwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsSkipForwardEnabled<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipForwardEnabled<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipForwardEnabled(value).into()
        }
        unsafe extern "system" fn IsSkipBackwardButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipBackwardButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipBackwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsSkipBackwardEnabled<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipBackwardEnabled<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSkipBackwardEnabled(value).into()
        }
        unsafe extern "system" fn IsNextTrackButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNextTrackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsNextTrackButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsNextTrackButtonVisible(value).into()
        }
        unsafe extern "system" fn IsPreviousTrackButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPreviousTrackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPreviousTrackButtonVisible<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPreviousTrackButtonVisible(value).into()
        }
        unsafe extern "system" fn FastPlayFallbackBehaviour<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::FastPlayFallbackBehaviour) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FastPlayFallbackBehaviour() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFastPlayFallbackBehaviour<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::FastPlayFallbackBehaviour) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFastPlayFallbackBehaviour(value).into()
        }
        unsafe extern "system" fn ThumbnailRequested<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ThumbnailRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveThumbnailRequested<Impl: IMediaTransportControls2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveThumbnailRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls2, BASE_OFFSET>(),
            IsSkipForwardButtonVisible: IsSkipForwardButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsSkipForwardButtonVisible: SetIsSkipForwardButtonVisible::<Impl, IMPL_OFFSET>,
            IsSkipForwardEnabled: IsSkipForwardEnabled::<Impl, IMPL_OFFSET>,
            SetIsSkipForwardEnabled: SetIsSkipForwardEnabled::<Impl, IMPL_OFFSET>,
            IsSkipBackwardButtonVisible: IsSkipBackwardButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsSkipBackwardButtonVisible: SetIsSkipBackwardButtonVisible::<Impl, IMPL_OFFSET>,
            IsSkipBackwardEnabled: IsSkipBackwardEnabled::<Impl, IMPL_OFFSET>,
            SetIsSkipBackwardEnabled: SetIsSkipBackwardEnabled::<Impl, IMPL_OFFSET>,
            IsNextTrackButtonVisible: IsNextTrackButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsNextTrackButtonVisible: SetIsNextTrackButtonVisible::<Impl, IMPL_OFFSET>,
            IsPreviousTrackButtonVisible: IsPreviousTrackButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsPreviousTrackButtonVisible: SetIsPreviousTrackButtonVisible::<Impl, IMPL_OFFSET>,
            FastPlayFallbackBehaviour: FastPlayFallbackBehaviour::<Impl, IMPL_OFFSET>,
            SetFastPlayFallbackBehaviour: SetFastPlayFallbackBehaviour::<Impl, IMPL_OFFSET>,
            ThumbnailRequested: ThumbnailRequested::<Impl, IMPL_OFFSET>,
            RemoveThumbnailRequested: RemoveThumbnailRequested::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls3_Impl: Sized {
    fn ShowAndHideAutomatically(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowAndHideAutomatically(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsRepeatEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRepeatEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsRepeatButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsRepeatButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Show(&mut self) -> ::windows::core::Result<()>;
    fn Hide(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls3";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControls3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControls3_Vtbl {
        unsafe extern "system" fn ShowAndHideAutomatically<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAndHideAutomatically() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAndHideAutomatically<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowAndHideAutomatically(value).into()
        }
        unsafe extern "system" fn IsRepeatEnabled<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRepeatEnabled<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRepeatEnabled(value).into()
        }
        unsafe extern "system" fn IsRepeatButtonVisible<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRepeatButtonVisible<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsRepeatButtonVisible(value).into()
        }
        unsafe extern "system" fn Show<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Show().into()
        }
        unsafe extern "system" fn Hide<Impl: IMediaTransportControls3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls3, BASE_OFFSET>(),
            ShowAndHideAutomatically: ShowAndHideAutomatically::<Impl, IMPL_OFFSET>,
            SetShowAndHideAutomatically: SetShowAndHideAutomatically::<Impl, IMPL_OFFSET>,
            IsRepeatEnabled: IsRepeatEnabled::<Impl, IMPL_OFFSET>,
            SetIsRepeatEnabled: SetIsRepeatEnabled::<Impl, IMPL_OFFSET>,
            IsRepeatButtonVisible: IsRepeatButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsRepeatButtonVisible: SetIsRepeatButtonVisible::<Impl, IMPL_OFFSET>,
            Show: Show::<Impl, IMPL_OFFSET>,
            Hide: Hide::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls4_Impl: Sized {
    fn IsCompactOverlayButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompactOverlayButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCompactOverlayEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsCompactOverlayEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls4";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControls4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControls4_Vtbl {
        unsafe extern "system" fn IsCompactOverlayButtonVisible<Impl: IMediaTransportControls4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompactOverlayButtonVisible<Impl: IMediaTransportControls4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompactOverlayButtonVisible(value).into()
        }
        unsafe extern "system" fn IsCompactOverlayEnabled<Impl: IMediaTransportControls4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompactOverlayEnabled<Impl: IMediaTransportControls4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsCompactOverlayEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControls4, BASE_OFFSET>(),
            IsCompactOverlayButtonVisible: IsCompactOverlayButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsCompactOverlayButtonVisible: SetIsCompactOverlayButtonVisible::<Impl, IMPL_OFFSET>,
            IsCompactOverlayEnabled: IsCompactOverlayEnabled::<Impl, IMPL_OFFSET>,
            SetIsCompactOverlayEnabled: SetIsCompactOverlayEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControls4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaTransportControls>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaTransportControlsFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsHelper_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsHelper {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelper";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsHelper_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsHelper_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsHelper_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsHelper, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsHelper as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IMediaTransportControlsHelperStatics_Impl: Sized {
    fn DropoutOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetDropoutOrder(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<super::super::super::Foundation::IReference<i32>>;
    fn SetDropoutOrder(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMediaTransportControlsHelperStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelperStatics";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IMediaTransportControlsHelperStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsHelperStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsHelperStatics_Vtbl {
        unsafe extern "system" fn DropoutOrderProperty<Impl: IMediaTransportControlsHelperStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropoutOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDropoutOrder<Impl: IMediaTransportControlsHelperStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDropoutOrder(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDropoutOrder<Impl: IMediaTransportControlsHelperStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDropoutOrder(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsHelperStatics, BASE_OFFSET>(),
            DropoutOrderProperty: DropoutOrderProperty::<Impl, IMPL_OFFSET>,
            GetDropoutOrder: GetDropoutOrder::<Impl, IMPL_OFFSET>,
            SetDropoutOrder: SetDropoutOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsHelperStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics_Impl: Sized {
    fn IsFullWindowButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastForwardButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastForwardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastRewindButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastRewindEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStopButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStopEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVolumeButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVolumeEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPlaybackRateButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPlaybackRateEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSeekBarVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSeekEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStatics_Vtbl {
        unsafe extern "system" fn IsFullWindowButtonVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFullWindowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomButtonVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastForwardButtonVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastForwardEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastForwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastRewindButtonVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastRewindEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFastRewindEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStopButtonVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStopEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsStopEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVolumeButtonVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVolumeEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVolumeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPlaybackRateButtonVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPlaybackRateEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSeekBarVisibleProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekBarVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSeekEnabledProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSeekEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IMediaTransportControlsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics, BASE_OFFSET>(),
            IsFullWindowButtonVisibleProperty: IsFullWindowButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsFullWindowEnabledProperty: IsFullWindowEnabledProperty::<Impl, IMPL_OFFSET>,
            IsZoomButtonVisibleProperty: IsZoomButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsZoomEnabledProperty: IsZoomEnabledProperty::<Impl, IMPL_OFFSET>,
            IsFastForwardButtonVisibleProperty: IsFastForwardButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsFastForwardEnabledProperty: IsFastForwardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsFastRewindButtonVisibleProperty: IsFastRewindButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsFastRewindEnabledProperty: IsFastRewindEnabledProperty::<Impl, IMPL_OFFSET>,
            IsStopButtonVisibleProperty: IsStopButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsStopEnabledProperty: IsStopEnabledProperty::<Impl, IMPL_OFFSET>,
            IsVolumeButtonVisibleProperty: IsVolumeButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsVolumeEnabledProperty: IsVolumeEnabledProperty::<Impl, IMPL_OFFSET>,
            IsPlaybackRateButtonVisibleProperty: IsPlaybackRateButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsPlaybackRateEnabledProperty: IsPlaybackRateEnabledProperty::<Impl, IMPL_OFFSET>,
            IsSeekBarVisibleProperty: IsSeekBarVisibleProperty::<Impl, IMPL_OFFSET>,
            IsSeekEnabledProperty: IsSeekEnabledProperty::<Impl, IMPL_OFFSET>,
            IsCompactProperty: IsCompactProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics2_Impl: Sized {
    fn IsSkipForwardButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipForwardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipBackwardButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipBackwardEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsNextTrackButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPreviousTrackButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FastPlayFallbackBehaviourProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStatics2_Vtbl {
        unsafe extern "system" fn IsSkipForwardButtonVisibleProperty<Impl: IMediaTransportControlsStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipForwardEnabledProperty<Impl: IMediaTransportControlsStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipBackwardButtonVisibleProperty<Impl: IMediaTransportControlsStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipBackwardEnabledProperty<Impl: IMediaTransportControlsStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsNextTrackButtonVisibleProperty<Impl: IMediaTransportControlsStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsNextTrackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPreviousTrackButtonVisibleProperty<Impl: IMediaTransportControlsStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPreviousTrackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FastPlayFallbackBehaviourProperty<Impl: IMediaTransportControlsStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FastPlayFallbackBehaviourProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics2, BASE_OFFSET>(),
            IsSkipForwardButtonVisibleProperty: IsSkipForwardButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsSkipForwardEnabledProperty: IsSkipForwardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsSkipBackwardButtonVisibleProperty: IsSkipBackwardButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsSkipBackwardEnabledProperty: IsSkipBackwardEnabledProperty::<Impl, IMPL_OFFSET>,
            IsNextTrackButtonVisibleProperty: IsNextTrackButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsPreviousTrackButtonVisibleProperty: IsPreviousTrackButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            FastPlayFallbackBehaviourProperty: FastPlayFallbackBehaviourProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics3_Impl: Sized {
    fn ShowAndHideAutomaticallyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRepeatEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRepeatButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStatics3_Vtbl {
        unsafe extern "system" fn ShowAndHideAutomaticallyProperty<Impl: IMediaTransportControlsStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAndHideAutomaticallyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRepeatEnabledProperty<Impl: IMediaTransportControlsStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRepeatButtonVisibleProperty<Impl: IMediaTransportControlsStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRepeatButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics3, BASE_OFFSET>(),
            ShowAndHideAutomaticallyProperty: ShowAndHideAutomaticallyProperty::<Impl, IMPL_OFFSET>,
            IsRepeatEnabledProperty: IsRepeatEnabledProperty::<Impl, IMPL_OFFSET>,
            IsRepeatButtonVisibleProperty: IsRepeatButtonVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics4_Impl: Sized {
    fn IsCompactOverlayButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactOverlayEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTransportControlsStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTransportControlsStatics4_Vtbl {
        unsafe extern "system" fn IsCompactOverlayButtonVisibleProperty<Impl: IMediaTransportControlsStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactOverlayEnabledProperty<Impl: IMediaTransportControlsStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMediaTransportControlsStatics4, BASE_OFFSET>(),
            IsCompactOverlayButtonVisibleProperty: IsCompactOverlayButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsCompactOverlayEnabledProperty: IsCompactOverlayEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTransportControlsStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuBar_Impl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuBarItem>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBar";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuBar_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBar_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBar_Vtbl {
        unsafe extern "system" fn Items<Impl: IMenuBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBar, BASE_OFFSET>(), Items: Items::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBar as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuBarItem_Impl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTitle(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuBarItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItem";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuBarItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItem_Vtbl {
        unsafe extern "system" fn Title<Impl: IMenuBarItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IMenuBarItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Items<Impl: IMenuBarItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItem, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBarItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFlyout_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemFlyout_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemFlyout, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFlyoutFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBarItemFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFlyoutFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemFlyoutFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemFlyoutFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarItemFlyoutFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemStatics_Impl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarItemStatics_Vtbl {
        unsafe extern "system" fn TitleProperty<Impl: IMenuBarItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsProperty<Impl: IMenuBarItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarItemStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            ItemsProperty: ItemsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarStatics_Impl: Sized {
    fn ItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuBarStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuBarStatics_Vtbl {
        unsafe extern "system" fn ItemsProperty<Impl: IMenuBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuBarStatics, BASE_OFFSET>(), ItemsProperty: ItemsProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuFlyout_Impl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
    fn MenuFlyoutPresenterStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetMenuFlyoutPresenterStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyout";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyout_Vtbl {
        unsafe extern "system" fn Items<Impl: IMenuFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuFlyoutPresenterStyle<Impl: IMenuFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuFlyoutPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuFlyoutPresenterStyle<Impl: IMenuFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuFlyoutPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyout, BASE_OFFSET>(),
            Items: Items::<Impl, IMPL_OFFSET>,
            MenuFlyoutPresenterStyle: MenuFlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
            SetMenuFlyoutPresenterStyle: SetMenuFlyoutPresenterStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IMenuFlyout2_Impl: Sized {
    fn ShowAt(&mut self, targetelement: &::core::option::Option<super::UIElement>, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyout2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyout2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IMenuFlyout2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyout2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyout2_Vtbl {
        unsafe extern "system" fn ShowAt<Impl: IMenuFlyout2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, targetelement: ::windows::core::RawPtr, point: super::super::super::Foundation::Point) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowAt(&*(&targetelement as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyout2, BASE_OFFSET>(), ShowAt: ShowAt::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyout2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IMenuFlyoutItem_Impl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Command(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Click(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IMenuFlyoutItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItem_Vtbl {
        unsafe extern "system" fn Text<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Click<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Click(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClick<Impl: IMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItem, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            Command: Command::<Impl, IMPL_OFFSET>,
            SetCommand: SetCommand::<Impl, IMPL_OFFSET>,
            CommandParameter: CommandParameter::<Impl, IMPL_OFFSET>,
            SetCommandParameter: SetCommandParameter::<Impl, IMPL_OFFSET>,
            Click: Click::<Impl, IMPL_OFFSET>,
            RemoveClick: RemoveClick::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItem2_Impl: Sized {
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItem2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItem2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItem2_Vtbl {
        unsafe extern "system" fn Icon<Impl: IMenuFlyoutItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IMenuFlyoutItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItem2, BASE_OFFSET>(),
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IMenuFlyoutItem3_Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::MenuFlyoutItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutItem3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem3";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IMenuFlyoutItem3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItem3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItem3_Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IMenuFlyoutItem3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IMenuFlyoutItem3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IMenuFlyoutItem3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItem3, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverride: KeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            SetKeyboardAcceleratorTextOverride: SetKeyboardAcceleratorTextOverride::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItem3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemBase_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBase";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemBase_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemBase_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemBase_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemBase, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemBase as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemBaseFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemBaseFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemBaseFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemBaseFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemBaseFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemBaseFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStatics_Impl: Sized {
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemStatics_Vtbl {
        unsafe extern "system" fn TextProperty<Impl: IMenuFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: IMenuFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: IMenuFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemStatics, BASE_OFFSET>(),
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            CommandProperty: CommandProperty::<Impl, IMPL_OFFSET>,
            CommandParameterProperty: CommandParameterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStatics2_Impl: Sized {
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemStatics2_Vtbl {
        unsafe extern "system" fn IconProperty<Impl: IMenuFlyoutItemStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemStatics2, BASE_OFFSET>(),
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStatics3_Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutItemStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutItemStatics3_Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IMenuFlyoutItemStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutItemStatics3, BASE_OFFSET>(),
            KeyboardAcceleratorTextOverrideProperty: KeyboardAcceleratorTextOverrideProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutItemStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenter_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenter_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IMenuFlyoutPresenter2_Impl: Sized {
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::MenuFlyoutPresenterTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter2";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IMenuFlyoutPresenter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenter2_Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IMenuFlyoutPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenter2, BASE_OFFSET>(),
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenter3_Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenter3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenter3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenter3_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IMenuFlyoutPresenter3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IMenuFlyoutPresenter3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenter3, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenter3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenterFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenterFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutPresenterFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenterFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenterFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterStatics3_Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenterStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutPresenterStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutPresenterStatics3_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IMenuFlyoutPresenterStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutPresenterStatics3, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutPresenterStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSeparator_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSeparator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSeparator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSeparator_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSeparator, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSeparator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSeparatorFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSeparatorFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSeparatorFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSeparatorFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutSeparatorFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSeparatorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSeparatorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutStatics_Impl: Sized {
    fn MenuFlyoutPresenterStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutStatics_Vtbl {
        unsafe extern "system" fn MenuFlyoutPresenterStyleProperty<Impl: IMenuFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuFlyoutPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutStatics, BASE_OFFSET>(),
            MenuFlyoutPresenterStyleProperty: MenuFlyoutPresenterStyleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IMenuFlyoutSubItem_Impl: Sized {
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IMenuFlyoutSubItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItem_Vtbl {
        unsafe extern "system" fn Items<Impl: IMenuFlyoutSubItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Text<Impl: IMenuFlyoutSubItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IMenuFlyoutSubItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItem, BASE_OFFSET>(),
            Items: Items::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItem2_Impl: Sized {
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItem2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItem2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItem2_Vtbl {
        unsafe extern "system" fn Icon<Impl: IMenuFlyoutSubItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IMenuFlyoutSubItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItem2, BASE_OFFSET>(),
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItemStatics_Impl: Sized {
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItemStatics_Vtbl {
        unsafe extern "system" fn TextProperty<Impl: IMenuFlyoutSubItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItemStatics, BASE_OFFSET>(),
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItemStatics2_Impl: Sized {
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItemStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMenuFlyoutSubItemStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMenuFlyoutSubItemStatics2_Vtbl {
        unsafe extern "system" fn IconProperty<Impl: IMenuFlyoutSubItemStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IMenuFlyoutSubItemStatics2, BASE_OFFSET>(),
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMenuFlyoutSubItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "UI_Xaml_Interop")]
pub trait INavigate_Impl: Sized {
    fn Navigate(&mut self, sourcepagetype: &super::Interop::TypeName) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "UI_Xaml_Interop")]
impl ::windows::core::RuntimeName for INavigate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigate";
}
#[cfg(feature = "UI_Xaml_Interop")]
impl INavigate_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigate_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigate_Vtbl {
        unsafe extern "system" fn Navigate<Impl: INavigate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Navigate(&*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigate, BASE_OFFSET>(), Navigate: Navigate::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigate as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait INavigationView_Impl: Sized {
    fn IsPaneOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CompactModeThresholdWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetCompactModeThresholdWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ExpandedModeThresholdWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetExpandedModeThresholdWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn PaneFooter(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneFooter(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<NavigationViewDisplayMode>;
    fn IsSettingsVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSettingsVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsPaneToggleButtonVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneToggleButtonVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AlwaysShowHeader(&mut self) -> ::windows::core::Result<bool>;
    fn SetAlwaysShowHeader(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCompactPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn OpenPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetOpenPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn PaneToggleButtonStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetPaneToggleButtonStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn MenuItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn MenuItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetMenuItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SettingsItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn AutoSuggestBox(&mut self) -> ::windows::core::Result<AutoSuggestBox>;
    fn SetAutoSuggestBox(&mut self, value: &::core::option::Option<AutoSuggestBox>) -> ::windows::core::Result<()>;
    fn MenuItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetMenuItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn MenuItemTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetMenuItemTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn MenuItemContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetMenuItemContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn MenuItemContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetMenuItemContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn MenuItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromMenuItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ItemInvoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DisplayModeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDisplayModeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl INavigationView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationView_Vtbl {
        unsafe extern "system" fn IsPaneOpen<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneOpen<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneOpen(value).into()
        }
        unsafe extern "system" fn CompactModeThresholdWidth<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactModeThresholdWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactModeThresholdWidth<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCompactModeThresholdWidth(value).into()
        }
        unsafe extern "system" fn ExpandedModeThresholdWidth<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedModeThresholdWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExpandedModeThresholdWidth<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetExpandedModeThresholdWidth(value).into()
        }
        unsafe extern "system" fn PaneFooter<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneFooter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneFooter<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneFooter(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsVisible<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSettingsVisible<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSettingsVisible(value).into()
        }
        unsafe extern "system" fn IsPaneToggleButtonVisible<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneToggleButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneToggleButtonVisible<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneToggleButtonVisible(value).into()
        }
        unsafe extern "system" fn AlwaysShowHeader<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlwaysShowHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlwaysShowHeader<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlwaysShowHeader(value).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactPaneLength<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCompactPaneLength(value).into()
        }
        unsafe extern "system" fn OpenPaneLength<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpenPaneLength<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpenPaneLength(value).into()
        }
        unsafe extern "system" fn PaneToggleButtonStyle<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneToggleButtonStyle<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneToggleButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItems<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsSource<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemsSource<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SettingsItem<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SettingsItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoSuggestBox<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoSuggestBox() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoSuggestBox<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoSuggestBox(&*(&value as *const <AutoSuggestBox as ::windows::core::Abi>::Abi as *const <AutoSuggestBox as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemTemplate<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemTemplate<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemTemplateSelector<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemTemplateSelector<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemContainerStyle<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemContainerStyle<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemContainerStyleSelector<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemContainerStyleSelector<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMenuItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemFromContainer<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromMenuItem<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromMenuItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemInvoked<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemInvoked<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayModeChanged<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDisplayModeChanged<Impl: INavigationView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDisplayModeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationView, BASE_OFFSET>(),
            IsPaneOpen: IsPaneOpen::<Impl, IMPL_OFFSET>,
            SetIsPaneOpen: SetIsPaneOpen::<Impl, IMPL_OFFSET>,
            CompactModeThresholdWidth: CompactModeThresholdWidth::<Impl, IMPL_OFFSET>,
            SetCompactModeThresholdWidth: SetCompactModeThresholdWidth::<Impl, IMPL_OFFSET>,
            ExpandedModeThresholdWidth: ExpandedModeThresholdWidth::<Impl, IMPL_OFFSET>,
            SetExpandedModeThresholdWidth: SetExpandedModeThresholdWidth::<Impl, IMPL_OFFSET>,
            PaneFooter: PaneFooter::<Impl, IMPL_OFFSET>,
            SetPaneFooter: SetPaneFooter::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            IsSettingsVisible: IsSettingsVisible::<Impl, IMPL_OFFSET>,
            SetIsSettingsVisible: SetIsSettingsVisible::<Impl, IMPL_OFFSET>,
            IsPaneToggleButtonVisible: IsPaneToggleButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsPaneToggleButtonVisible: SetIsPaneToggleButtonVisible::<Impl, IMPL_OFFSET>,
            AlwaysShowHeader: AlwaysShowHeader::<Impl, IMPL_OFFSET>,
            SetAlwaysShowHeader: SetAlwaysShowHeader::<Impl, IMPL_OFFSET>,
            CompactPaneLength: CompactPaneLength::<Impl, IMPL_OFFSET>,
            SetCompactPaneLength: SetCompactPaneLength::<Impl, IMPL_OFFSET>,
            OpenPaneLength: OpenPaneLength::<Impl, IMPL_OFFSET>,
            SetOpenPaneLength: SetOpenPaneLength::<Impl, IMPL_OFFSET>,
            PaneToggleButtonStyle: PaneToggleButtonStyle::<Impl, IMPL_OFFSET>,
            SetPaneToggleButtonStyle: SetPaneToggleButtonStyle::<Impl, IMPL_OFFSET>,
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            SetSelectedItem: SetSelectedItem::<Impl, IMPL_OFFSET>,
            MenuItems: MenuItems::<Impl, IMPL_OFFSET>,
            MenuItemsSource: MenuItemsSource::<Impl, IMPL_OFFSET>,
            SetMenuItemsSource: SetMenuItemsSource::<Impl, IMPL_OFFSET>,
            SettingsItem: SettingsItem::<Impl, IMPL_OFFSET>,
            AutoSuggestBox: AutoSuggestBox::<Impl, IMPL_OFFSET>,
            SetAutoSuggestBox: SetAutoSuggestBox::<Impl, IMPL_OFFSET>,
            MenuItemTemplate: MenuItemTemplate::<Impl, IMPL_OFFSET>,
            SetMenuItemTemplate: SetMenuItemTemplate::<Impl, IMPL_OFFSET>,
            MenuItemTemplateSelector: MenuItemTemplateSelector::<Impl, IMPL_OFFSET>,
            SetMenuItemTemplateSelector: SetMenuItemTemplateSelector::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyle: MenuItemContainerStyle::<Impl, IMPL_OFFSET>,
            SetMenuItemContainerStyle: SetMenuItemContainerStyle::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyleSelector: MenuItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetMenuItemContainerStyleSelector: SetMenuItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            MenuItemFromContainer: MenuItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromMenuItem: ContainerFromMenuItem::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ItemInvoked: ItemInvoked::<Impl, IMPL_OFFSET>,
            RemoveItemInvoked: RemoveItemInvoked::<Impl, IMPL_OFFSET>,
            DisplayModeChanged: DisplayModeChanged::<Impl, IMPL_OFFSET>,
            RemoveDisplayModeChanged: RemoveDisplayModeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait INavigationView2_Impl: Sized {
    fn IsBackButtonVisible(&mut self) -> ::windows::core::Result<NavigationViewBackButtonVisible>;
    fn SetIsBackButtonVisible(&mut self, value: NavigationViewBackButtonVisible) -> ::windows::core::Result<()>;
    fn IsBackEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsBackEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn PaneTitle(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPaneTitle(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn BackRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBackRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpening(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl INavigationView2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationView2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationView2_Vtbl {
        unsafe extern "system" fn IsBackButtonVisible<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewBackButtonVisible) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBackButtonVisible<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewBackButtonVisible) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsBackButtonVisible(value).into()
        }
        unsafe extern "system" fn IsBackEnabled<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBackEnabled<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsBackEnabled(value).into()
        }
        unsafe extern "system" fn PaneTitle<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneTitle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneTitle<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackRequested<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBackRequested<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBackRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosed<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosed<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosing<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosing<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpened<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpened<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpening<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpening(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpening<Impl: INavigationView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationView2, BASE_OFFSET>(),
            IsBackButtonVisible: IsBackButtonVisible::<Impl, IMPL_OFFSET>,
            SetIsBackButtonVisible: SetIsBackButtonVisible::<Impl, IMPL_OFFSET>,
            IsBackEnabled: IsBackEnabled::<Impl, IMPL_OFFSET>,
            SetIsBackEnabled: SetIsBackEnabled::<Impl, IMPL_OFFSET>,
            PaneTitle: PaneTitle::<Impl, IMPL_OFFSET>,
            SetPaneTitle: SetPaneTitle::<Impl, IMPL_OFFSET>,
            BackRequested: BackRequested::<Impl, IMPL_OFFSET>,
            RemoveBackRequested: RemoveBackRequested::<Impl, IMPL_OFFSET>,
            PaneClosed: PaneClosed::<Impl, IMPL_OFFSET>,
            RemovePaneClosed: RemovePaneClosed::<Impl, IMPL_OFFSET>,
            PaneClosing: PaneClosing::<Impl, IMPL_OFFSET>,
            RemovePaneClosing: RemovePaneClosing::<Impl, IMPL_OFFSET>,
            PaneOpened: PaneOpened::<Impl, IMPL_OFFSET>,
            RemovePaneOpened: RemovePaneOpened::<Impl, IMPL_OFFSET>,
            PaneOpening: PaneOpening::<Impl, IMPL_OFFSET>,
            RemovePaneOpening: RemovePaneOpening::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationView3_Impl: Sized {
    fn PaneDisplayMode(&mut self) -> ::windows::core::Result<NavigationViewPaneDisplayMode>;
    fn SetPaneDisplayMode(&mut self, value: NavigationViewPaneDisplayMode) -> ::windows::core::Result<()>;
    fn PaneHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn PaneCustomContent(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneCustomContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ContentOverlay(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContentOverlay(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn IsPaneVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SelectionFollowsFocus(&mut self) -> ::windows::core::Result<NavigationViewSelectionFollowsFocus>;
    fn SetSelectionFollowsFocus(&mut self, value: NavigationViewSelectionFollowsFocus) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<NavigationViewTemplateSettings>;
    fn ShoulderNavigationEnabled(&mut self) -> ::windows::core::Result<NavigationViewShoulderNavigationEnabled>;
    fn SetShoulderNavigationEnabled(&mut self, value: NavigationViewShoulderNavigationEnabled) -> ::windows::core::Result<()>;
    fn OverflowLabelMode(&mut self) -> ::windows::core::Result<NavigationViewOverflowLabelMode>;
    fn SetOverflowLabelMode(&mut self, value: NavigationViewOverflowLabelMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView3";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationView3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationView3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationView3_Vtbl {
        unsafe extern "system" fn PaneDisplayMode<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewPaneDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneDisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneDisplayMode<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewPaneDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneDisplayMode(value).into()
        }
        unsafe extern "system" fn PaneHeader<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneHeader<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneCustomContent<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneCustomContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneCustomContent<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneCustomContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentOverlay<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentOverlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentOverlay<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentOverlay(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPaneVisible<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneVisible<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneVisible(value).into()
        }
        unsafe extern "system" fn SelectionFollowsFocus<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewSelectionFollowsFocus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFollowsFocus<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewSelectionFollowsFocus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFollowsFocus(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShoulderNavigationEnabled<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewShoulderNavigationEnabled) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShoulderNavigationEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShoulderNavigationEnabled<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewShoulderNavigationEnabled) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShoulderNavigationEnabled(value).into()
        }
        unsafe extern "system" fn OverflowLabelMode<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewOverflowLabelMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowLabelMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowLabelMode<Impl: INavigationView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: NavigationViewOverflowLabelMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowLabelMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationView3, BASE_OFFSET>(),
            PaneDisplayMode: PaneDisplayMode::<Impl, IMPL_OFFSET>,
            SetPaneDisplayMode: SetPaneDisplayMode::<Impl, IMPL_OFFSET>,
            PaneHeader: PaneHeader::<Impl, IMPL_OFFSET>,
            SetPaneHeader: SetPaneHeader::<Impl, IMPL_OFFSET>,
            PaneCustomContent: PaneCustomContent::<Impl, IMPL_OFFSET>,
            SetPaneCustomContent: SetPaneCustomContent::<Impl, IMPL_OFFSET>,
            ContentOverlay: ContentOverlay::<Impl, IMPL_OFFSET>,
            SetContentOverlay: SetContentOverlay::<Impl, IMPL_OFFSET>,
            IsPaneVisible: IsPaneVisible::<Impl, IMPL_OFFSET>,
            SetIsPaneVisible: SetIsPaneVisible::<Impl, IMPL_OFFSET>,
            SelectionFollowsFocus: SelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            SetSelectionFollowsFocus: SetSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            ShoulderNavigationEnabled: ShoulderNavigationEnabled::<Impl, IMPL_OFFSET>,
            SetShoulderNavigationEnabled: SetShoulderNavigationEnabled::<Impl, IMPL_OFFSET>,
            OverflowLabelMode: OverflowLabelMode::<Impl, IMPL_OFFSET>,
            SetOverflowLabelMode: SetOverflowLabelMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationView3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewBackRequestedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewBackRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewBackRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewBackRequestedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewBackRequestedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewBackRequestedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewBackRequestedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewBackRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewDisplayModeChangedEventArgs_Impl: Sized {
    fn DisplayMode(&mut self) -> ::windows::core::Result<NavigationViewDisplayMode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewDisplayModeChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewDisplayModeChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewDisplayModeChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewDisplayModeChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewDisplayModeChangedEventArgs_Vtbl {
        unsafe extern "system" fn DisplayMode<Impl: INavigationViewDisplayModeChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewDisplayModeChangedEventArgs, BASE_OFFSET>(),
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewDisplayModeChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItem_Impl: Sized {
    fn Icon(&mut self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&mut self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItem_Vtbl {
        unsafe extern "system" fn Icon<Impl: INavigationViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: INavigationViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: INavigationViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItem, BASE_OFFSET>(),
            Icon: Icon::<Impl, IMPL_OFFSET>,
            SetIcon: SetIcon::<Impl, IMPL_OFFSET>,
            CompactPaneLength: CompactPaneLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItem2_Impl: Sized {
    fn SelectsOnInvoked(&mut self) -> ::windows::core::Result<bool>;
    fn SetSelectsOnInvoked(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItem2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItem2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItem2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItem2_Vtbl {
        unsafe extern "system" fn SelectsOnInvoked<Impl: INavigationViewItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectsOnInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectsOnInvoked<Impl: INavigationViewItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectsOnInvoked(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItem2, BASE_OFFSET>(),
            SelectsOnInvoked: SelectsOnInvoked::<Impl, IMPL_OFFSET>,
            SetSelectsOnInvoked: SetSelectsOnInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemBase_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemBase";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemBase_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemBase_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemBase_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemBase, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemBase as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemBaseFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemBaseFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemBaseFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemBaseFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemBaseFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemBaseFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemHeader_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemHeader {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemHeader";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemHeader_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemHeader_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemHeader_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemHeader, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemHeader as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemHeaderFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItemHeader>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemHeaderFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemHeaderFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemHeaderFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemHeaderFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemHeaderFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemHeaderFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemHeaderFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemHeaderFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemInvokedEventArgs_Impl: Sized {
    fn InvokedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn IsSettingsInvoked(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemInvokedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemInvokedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemInvokedEventArgs_Vtbl {
        unsafe extern "system" fn InvokedItem<Impl: INavigationViewItemInvokedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsInvoked<Impl: INavigationViewItemInvokedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemInvokedEventArgs, BASE_OFFSET>(),
            InvokedItem: InvokedItem::<Impl, IMPL_OFFSET>,
            IsSettingsInvoked: IsSettingsInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemInvokedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait INavigationViewItemInvokedEventArgs2_Impl: Sized {
    fn InvokedItemContainer(&mut self) -> ::windows::core::Result<NavigationViewItemBase>;
    fn RecommendedNavigationTransitionInfo(&mut self) -> ::windows::core::Result<super::Media::Animation::NavigationTransitionInfo>;
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationViewItemInvokedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2";
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl INavigationViewItemInvokedEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemInvokedEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemInvokedEventArgs2_Vtbl {
        unsafe extern "system" fn InvokedItemContainer<Impl: INavigationViewItemInvokedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokedItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecommendedNavigationTransitionInfo<Impl: INavigationViewItemInvokedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecommendedNavigationTransitionInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemInvokedEventArgs2, BASE_OFFSET>(),
            InvokedItemContainer: InvokedItemContainer::<Impl, IMPL_OFFSET>,
            RecommendedNavigationTransitionInfo: RecommendedNavigationTransitionInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemInvokedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemSeparator_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemSeparator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemSeparator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemSeparator_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemSeparator, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemSeparator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemSeparatorFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItemSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemSeparatorFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemSeparatorFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemSeparatorFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemSeparatorFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemSeparatorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemSeparatorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemStatics_Impl: Sized {
    fn IconProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemStatics_Vtbl {
        unsafe extern "system" fn IconProperty<Impl: INavigationViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: INavigationViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemStatics, BASE_OFFSET>(),
            IconProperty: IconProperty::<Impl, IMPL_OFFSET>,
            CompactPaneLengthProperty: CompactPaneLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemStatics2_Impl: Sized {
    fn SelectsOnInvokedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewItemStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewItemStatics2_Vtbl {
        unsafe extern "system" fn SelectsOnInvokedProperty<Impl: INavigationViewItemStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectsOnInvokedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewItemStatics2, BASE_OFFSET>(),
            SelectsOnInvokedProperty: SelectsOnInvokedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewList_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewList {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewList";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewList_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewList, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewListFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewList>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewListFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewListFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewListFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewListFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewListFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewListFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewListFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewListFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewPaneClosingEventArgs_Impl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewPaneClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewPaneClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewPaneClosingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewPaneClosingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewPaneClosingEventArgs_Vtbl {
        unsafe extern "system" fn Cancel<Impl: INavigationViewPaneClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: INavigationViewPaneClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewPaneClosingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewPaneClosingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewSelectionChangedEventArgs_Impl: Sized {
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn IsSettingsSelected(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewSelectionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewSelectionChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewSelectionChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewSelectionChangedEventArgs_Vtbl {
        unsafe extern "system" fn SelectedItem<Impl: INavigationViewSelectionChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsSelected<Impl: INavigationViewSelectionChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsSelected() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewSelectionChangedEventArgs, BASE_OFFSET>(),
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            IsSettingsSelected: IsSettingsSelected::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewSelectionChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait INavigationViewSelectionChangedEventArgs2_Impl: Sized {
    fn SelectedItemContainer(&mut self) -> ::windows::core::Result<NavigationViewItemBase>;
    fn RecommendedNavigationTransitionInfo(&mut self) -> ::windows::core::Result<super::Media::Animation::NavigationTransitionInfo>;
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INavigationViewSelectionChangedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2";
}
#[cfg(all(feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl INavigationViewSelectionChangedEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewSelectionChangedEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewSelectionChangedEventArgs2_Vtbl {
        unsafe extern "system" fn SelectedItemContainer<Impl: INavigationViewSelectionChangedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecommendedNavigationTransitionInfo<Impl: INavigationViewSelectionChangedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecommendedNavigationTransitionInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewSelectionChangedEventArgs2, BASE_OFFSET>(),
            SelectedItemContainer: SelectedItemContainer::<Impl, IMPL_OFFSET>,
            RecommendedNavigationTransitionInfo: RecommendedNavigationTransitionInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewSelectionChangedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStatics_Impl: Sized {
    fn IsPaneOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactModeThresholdWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExpandedModeThresholdWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneFooterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSettingsVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneToggleButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AlwaysShowHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpenPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneToggleButtonStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SettingsItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoSuggestBoxProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemContainerStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemContainerStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewStatics_Vtbl {
        unsafe extern "system" fn IsPaneOpenProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactModeThresholdWidthProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactModeThresholdWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExpandedModeThresholdWidthProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedModeThresholdWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneFooterProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneFooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsVisibleProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSettingsVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneToggleButtonVisibleProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneToggleButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AlwaysShowHeaderProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlwaysShowHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenPaneLengthProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonStyleProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsSourceProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SettingsItemProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SettingsItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoSuggestBoxProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoSuggestBoxProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemTemplateProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemTemplateSelectorProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemContainerStyleProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemContainerStyleSelectorProperty<Impl: INavigationViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewStatics, BASE_OFFSET>(),
            IsPaneOpenProperty: IsPaneOpenProperty::<Impl, IMPL_OFFSET>,
            CompactModeThresholdWidthProperty: CompactModeThresholdWidthProperty::<Impl, IMPL_OFFSET>,
            ExpandedModeThresholdWidthProperty: ExpandedModeThresholdWidthProperty::<Impl, IMPL_OFFSET>,
            PaneFooterProperty: PaneFooterProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            IsSettingsVisibleProperty: IsSettingsVisibleProperty::<Impl, IMPL_OFFSET>,
            IsPaneToggleButtonVisibleProperty: IsPaneToggleButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            AlwaysShowHeaderProperty: AlwaysShowHeaderProperty::<Impl, IMPL_OFFSET>,
            CompactPaneLengthProperty: CompactPaneLengthProperty::<Impl, IMPL_OFFSET>,
            OpenPaneLengthProperty: OpenPaneLengthProperty::<Impl, IMPL_OFFSET>,
            PaneToggleButtonStyleProperty: PaneToggleButtonStyleProperty::<Impl, IMPL_OFFSET>,
            MenuItemsProperty: MenuItemsProperty::<Impl, IMPL_OFFSET>,
            MenuItemsSourceProperty: MenuItemsSourceProperty::<Impl, IMPL_OFFSET>,
            SelectedItemProperty: SelectedItemProperty::<Impl, IMPL_OFFSET>,
            SettingsItemProperty: SettingsItemProperty::<Impl, IMPL_OFFSET>,
            AutoSuggestBoxProperty: AutoSuggestBoxProperty::<Impl, IMPL_OFFSET>,
            MenuItemTemplateProperty: MenuItemTemplateProperty::<Impl, IMPL_OFFSET>,
            MenuItemTemplateSelectorProperty: MenuItemTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyleProperty: MenuItemContainerStyleProperty::<Impl, IMPL_OFFSET>,
            MenuItemContainerStyleSelectorProperty: MenuItemContainerStyleSelectorProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStatics2_Impl: Sized {
    fn IsBackButtonVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsBackEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneTitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewStatics2_Vtbl {
        unsafe extern "system" fn IsBackButtonVisibleProperty<Impl: INavigationViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsBackEnabledProperty<Impl: INavigationViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneTitleProperty<Impl: INavigationViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneTitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewStatics2, BASE_OFFSET>(),
            IsBackButtonVisibleProperty: IsBackButtonVisibleProperty::<Impl, IMPL_OFFSET>,
            IsBackEnabledProperty: IsBackEnabledProperty::<Impl, IMPL_OFFSET>,
            PaneTitleProperty: PaneTitleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStatics3_Impl: Sized {
    fn PaneDisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneCustomContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentOverlayProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShoulderNavigationEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowLabelModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewStatics3_Vtbl {
        unsafe extern "system" fn PaneDisplayModeProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneDisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneHeaderProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneCustomContentProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneCustomContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentOverlayProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentOverlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneVisibleProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFollowsFocusProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShoulderNavigationEnabledProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShoulderNavigationEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowLabelModeProperty<Impl: INavigationViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowLabelModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewStatics3, BASE_OFFSET>(),
            PaneDisplayModeProperty: PaneDisplayModeProperty::<Impl, IMPL_OFFSET>,
            PaneHeaderProperty: PaneHeaderProperty::<Impl, IMPL_OFFSET>,
            PaneCustomContentProperty: PaneCustomContentProperty::<Impl, IMPL_OFFSET>,
            ContentOverlayProperty: ContentOverlayProperty::<Impl, IMPL_OFFSET>,
            IsPaneVisibleProperty: IsPaneVisibleProperty::<Impl, IMPL_OFFSET>,
            SelectionFollowsFocusProperty: SelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
            TemplateSettingsProperty: TemplateSettingsProperty::<Impl, IMPL_OFFSET>,
            ShoulderNavigationEnabledProperty: ShoulderNavigationEnabledProperty::<Impl, IMPL_OFFSET>,
            OverflowLabelModeProperty: OverflowLabelModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettings_Impl: Sized {
    fn TopPadding(&mut self) -> ::windows::core::Result<f64>;
    fn OverflowButtonVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn PaneToggleButtonVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn BackButtonVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn TopPaneVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn LeftPaneVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn SingleSelectionFollowsFocus(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettings";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettings_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewTemplateSettings_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewTemplateSettings_Vtbl {
        unsafe extern "system" fn TopPadding<Impl: INavigationViewTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibility<Impl: INavigationViewTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonVisibility<Impl: INavigationViewTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackButtonVisibility<Impl: INavigationViewTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopPaneVisibility<Impl: INavigationViewTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPaneVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftPaneVisibility<Impl: INavigationViewTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftPaneVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: INavigationViewTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewTemplateSettings, BASE_OFFSET>(),
            TopPadding: TopPadding::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibility: OverflowButtonVisibility::<Impl, IMPL_OFFSET>,
            PaneToggleButtonVisibility: PaneToggleButtonVisibility::<Impl, IMPL_OFFSET>,
            BackButtonVisibility: BackButtonVisibility::<Impl, IMPL_OFFSET>,
            TopPaneVisibility: TopPaneVisibility::<Impl, IMPL_OFFSET>,
            LeftPaneVisibility: LeftPaneVisibility::<Impl, IMPL_OFFSET>,
            SingleSelectionFollowsFocus: SingleSelectionFollowsFocus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewTemplateSettings as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettingsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewTemplateSettingsFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewTemplateSettingsFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewTemplateSettingsFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewTemplateSettingsFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewTemplateSettingsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsStatics_Impl: Sized {
    fn TopPaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneToggleButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackButtonVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopPaneVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftPaneVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SingleSelectionFollowsFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettingsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INavigationViewTemplateSettingsStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INavigationViewTemplateSettingsStatics_Vtbl {
        unsafe extern "system" fn TopPaddingProperty<Impl: INavigationViewTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopPaneVisibilityProperty<Impl: INavigationViewTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopPaneVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftPaneVisibilityProperty<Impl: INavigationViewTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftPaneVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: INavigationViewTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, INavigationViewTemplateSettingsStatics, BASE_OFFSET>(),
            TopPaddingProperty: TopPaddingProperty::<Impl, IMPL_OFFSET>,
            OverflowButtonVisibilityProperty: OverflowButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            PaneToggleButtonVisibilityProperty: PaneToggleButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            BackButtonVisibilityProperty: BackButtonVisibilityProperty::<Impl, IMPL_OFFSET>,
            TopPaneVisibilityProperty: TopPaneVisibilityProperty::<Impl, IMPL_OFFSET>,
            LeftPaneVisibilityProperty: LeftPaneVisibilityProperty::<Impl, IMPL_OFFSET>,
            SingleSelectionFollowsFocusProperty: SingleSelectionFollowsFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INavigationViewTemplateSettingsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INotifyEventArgs_Impl: Sized {
    fn Value(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INotifyEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INotifyEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INotifyEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INotifyEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INotifyEventArgs_Vtbl {
        unsafe extern "system" fn Value<Impl: INotifyEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INotifyEventArgs, BASE_OFFSET>(), Value: Value::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INotifyEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait INotifyEventArgs2_Impl: Sized {
    fn CallingUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for INotifyEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INotifyEventArgs2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl INotifyEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: INotifyEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> INotifyEventArgs2_Vtbl {
        unsafe extern "system" fn CallingUri<Impl: INotifyEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CallingUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, INotifyEventArgs2, BASE_OFFSET>(), CallingUri: CallingUri::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<INotifyEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IPage_Impl: Sized {
    fn Frame(&mut self) -> ::windows::core::Result<Frame>;
    fn NavigationCacheMode(&mut self) -> ::windows::core::Result<super::Navigation::NavigationCacheMode>;
    fn SetNavigationCacheMode(&mut self, value: super::Navigation::NavigationCacheMode) -> ::windows::core::Result<()>;
    fn TopAppBar(&mut self) -> ::windows::core::Result<AppBar>;
    fn SetTopAppBar(&mut self, value: &::core::option::Option<AppBar>) -> ::windows::core::Result<()>;
    fn BottomAppBar(&mut self) -> ::windows::core::Result<AppBar>;
    fn SetBottomAppBar(&mut self, value: &::core::option::Option<AppBar>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPage {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPage";
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IPage_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPage_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPage_Vtbl {
        unsafe extern "system" fn Frame<Impl: IPage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Frame() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigationCacheMode<Impl: IPage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Navigation::NavigationCacheMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationCacheMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigationCacheMode<Impl: IPage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Navigation::NavigationCacheMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNavigationCacheMode(value).into()
        }
        unsafe extern "system" fn TopAppBar<Impl: IPage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopAppBar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopAppBar<Impl: IPage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopAppBar(&*(&value as *const <AppBar as ::windows::core::Abi>::Abi as *const <AppBar as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BottomAppBar<Impl: IPage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomAppBar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBottomAppBar<Impl: IPage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBottomAppBar(&*(&value as *const <AppBar as ::windows::core::Abi>::Abi as *const <AppBar as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPage, BASE_OFFSET>(),
            Frame: Frame::<Impl, IMPL_OFFSET>,
            NavigationCacheMode: NavigationCacheMode::<Impl, IMPL_OFFSET>,
            SetNavigationCacheMode: SetNavigationCacheMode::<Impl, IMPL_OFFSET>,
            TopAppBar: TopAppBar::<Impl, IMPL_OFFSET>,
            SetTopAppBar: SetTopAppBar::<Impl, IMPL_OFFSET>,
            BottomAppBar: BottomAppBar::<Impl, IMPL_OFFSET>,
            SetBottomAppBar: SetBottomAppBar::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPage as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Page>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPageFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPageFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPageFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPageFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPageFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPageFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPageFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IPageOverrides_Impl: Sized {
    fn OnNavigatedFrom(&mut self, e: &::core::option::Option<super::Navigation::NavigationEventArgs>) -> ::windows::core::Result<()>;
    fn OnNavigatedTo(&mut self, e: &::core::option::Option<super::Navigation::NavigationEventArgs>) -> ::windows::core::Result<()>;
    fn OnNavigatingFrom(&mut self, e: &::core::option::Option<super::Navigation::NavigatingCancelEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPageOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageOverrides";
}
#[cfg(all(feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IPageOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPageOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPageOverrides_Vtbl {
        unsafe extern "system" fn OnNavigatedFrom<Impl: IPageOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnNavigatedFrom(&*(&e as *const <super::Navigation::NavigationEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnNavigatedTo<Impl: IPageOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnNavigatedTo(&*(&e as *const <super::Navigation::NavigationEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnNavigatingFrom<Impl: IPageOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnNavigatingFrom(&*(&e as *const <super::Navigation::NavigatingCancelEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatingCancelEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPageOverrides, BASE_OFFSET>(),
            OnNavigatedFrom: OnNavigatedFrom::<Impl, IMPL_OFFSET>,
            OnNavigatedTo: OnNavigatedTo::<Impl, IMPL_OFFSET>,
            OnNavigatingFrom: OnNavigatingFrom::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPageOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageStatics_Impl: Sized {
    fn FrameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopAppBarProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BottomAppBarProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPageStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPageStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPageStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPageStatics_Vtbl {
        unsafe extern "system" fn FrameProperty<Impl: IPageStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopAppBarProperty<Impl: IPageStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopAppBarProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BottomAppBarProperty<Impl: IPageStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomAppBarProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPageStatics, BASE_OFFSET>(),
            FrameProperty: FrameProperty::<Impl, IMPL_OFFSET>,
            TopAppBarProperty: TopAppBarProperty::<Impl, IMPL_OFFSET>,
            BottomAppBarProperty: BottomAppBarProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPageStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait IPanel_Impl: Sized {
    fn Children(&mut self) -> ::windows::core::Result<UIElementCollection>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IsItemsHost(&mut self) -> ::windows::core::Result<bool>;
    fn ChildrenTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetChildrenTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanel";
}
#[cfg(all(feature = "Foundation_Collections", feature = "UI_Xaml_Media", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl IPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanel_Vtbl {
        unsafe extern "system" fn Children<Impl: IPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Background<Impl: IPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsItemsHost<Impl: IPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemsHost() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenTransitions<Impl: IPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildrenTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChildrenTransitions<Impl: IPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChildrenTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPanel, BASE_OFFSET>(),
            Children: Children::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            IsItemsHost: IsItemsHost::<Impl, IMPL_OFFSET>,
            ChildrenTransitions: ChildrenTransitions::<Impl, IMPL_OFFSET>,
            SetChildrenTransitions: SetChildrenTransitions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanel2_Impl: Sized {
    fn BackgroundTransition(&mut self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&mut self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IPanel2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanel2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanel2_Vtbl {
        unsafe extern "system" fn BackgroundTransition<Impl: IPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPanel2, BASE_OFFSET>(),
            BackgroundTransition: BackgroundTransition::<Impl, IMPL_OFFSET>,
            SetBackgroundTransition: SetBackgroundTransition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanelFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Panel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPanelFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanelFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanelFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPanelFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPanelFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanelStatics_Impl: Sized {
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsItemsHostProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildrenTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPanelStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPanelStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPanelStatics_Vtbl {
        unsafe extern "system" fn BackgroundProperty<Impl: IPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsItemsHostProperty<Impl: IPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsItemsHostProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenTransitionsProperty<Impl: IPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildrenTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPanelStatics, BASE_OFFSET>(),
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            IsItemsHostProperty: IsItemsHostProperty::<Impl, IMPL_OFFSET>,
            ChildrenTransitionsProperty: ChildrenTransitionsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxView_Impl: Sized {
    fn Child(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn HorizontalShift(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalShift(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn HorizontalSourceEndOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalSourceEndOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn HorizontalSourceOffsetKind(&mut self) -> ::windows::core::Result<ParallaxSourceOffsetKind>;
    fn SetHorizontalSourceOffsetKind(&mut self, value: ParallaxSourceOffsetKind) -> ::windows::core::Result<()>;
    fn HorizontalSourceStartOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalSourceStartOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsHorizontalShiftClamped(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalShiftClamped(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalShiftClamped(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalShiftClamped(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxHorizontalShiftRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxHorizontalShiftRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MaxVerticalShiftRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxVerticalShiftRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Source(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetSource(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn VerticalShift(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalShift(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalSourceEndOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalSourceEndOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalSourceOffsetKind(&mut self) -> ::windows::core::Result<ParallaxSourceOffsetKind>;
    fn SetVerticalSourceOffsetKind(&mut self, value: ParallaxSourceOffsetKind) -> ::windows::core::Result<()>;
    fn VerticalSourceStartOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalSourceStartOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn RefreshAutomaticHorizontalOffsets(&mut self) -> ::windows::core::Result<()>;
    fn RefreshAutomaticVerticalOffsets(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxView";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IParallaxView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IParallaxView_Vtbl {
        unsafe extern "system" fn Child<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalShift<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalShift() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalShift<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalShift(value).into()
        }
        unsafe extern "system" fn HorizontalSourceEndOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceEndOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceEndOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceEndOffset(value).into()
        }
        unsafe extern "system" fn HorizontalSourceOffsetKind<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceOffsetKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceOffsetKind<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceOffsetKind(value).into()
        }
        unsafe extern "system" fn HorizontalSourceStartOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceStartOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceStartOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceStartOffset(value).into()
        }
        unsafe extern "system" fn IsHorizontalShiftClamped<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalShiftClamped() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalShiftClamped<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalShiftClamped(value).into()
        }
        unsafe extern "system" fn IsVerticalShiftClamped<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalShiftClamped() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalShiftClamped<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalShiftClamped(value).into()
        }
        unsafe extern "system" fn MaxHorizontalShiftRatio<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHorizontalShiftRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHorizontalShiftRatio<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxHorizontalShiftRatio(value).into()
        }
        unsafe extern "system" fn MaxVerticalShiftRatio<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxVerticalShiftRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxVerticalShiftRatio<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxVerticalShiftRatio(value).into()
        }
        unsafe extern "system" fn Source<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VerticalShift<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalShift() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalShift<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalShift(value).into()
        }
        unsafe extern "system" fn VerticalSourceEndOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceEndOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceEndOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceEndOffset(value).into()
        }
        unsafe extern "system" fn VerticalSourceOffsetKind<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceOffsetKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceOffsetKind<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceOffsetKind(value).into()
        }
        unsafe extern "system" fn VerticalSourceStartOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceStartOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceStartOffset<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceStartOffset(value).into()
        }
        unsafe extern "system" fn RefreshAutomaticHorizontalOffsets<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RefreshAutomaticHorizontalOffsets().into()
        }
        unsafe extern "system" fn RefreshAutomaticVerticalOffsets<Impl: IParallaxView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RefreshAutomaticVerticalOffsets().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IParallaxView, BASE_OFFSET>(),
            Child: Child::<Impl, IMPL_OFFSET>,
            SetChild: SetChild::<Impl, IMPL_OFFSET>,
            HorizontalShift: HorizontalShift::<Impl, IMPL_OFFSET>,
            SetHorizontalShift: SetHorizontalShift::<Impl, IMPL_OFFSET>,
            HorizontalSourceEndOffset: HorizontalSourceEndOffset::<Impl, IMPL_OFFSET>,
            SetHorizontalSourceEndOffset: SetHorizontalSourceEndOffset::<Impl, IMPL_OFFSET>,
            HorizontalSourceOffsetKind: HorizontalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            SetHorizontalSourceOffsetKind: SetHorizontalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            HorizontalSourceStartOffset: HorizontalSourceStartOffset::<Impl, IMPL_OFFSET>,
            SetHorizontalSourceStartOffset: SetHorizontalSourceStartOffset::<Impl, IMPL_OFFSET>,
            IsHorizontalShiftClamped: IsHorizontalShiftClamped::<Impl, IMPL_OFFSET>,
            SetIsHorizontalShiftClamped: SetIsHorizontalShiftClamped::<Impl, IMPL_OFFSET>,
            IsVerticalShiftClamped: IsVerticalShiftClamped::<Impl, IMPL_OFFSET>,
            SetIsVerticalShiftClamped: SetIsVerticalShiftClamped::<Impl, IMPL_OFFSET>,
            MaxHorizontalShiftRatio: MaxHorizontalShiftRatio::<Impl, IMPL_OFFSET>,
            SetMaxHorizontalShiftRatio: SetMaxHorizontalShiftRatio::<Impl, IMPL_OFFSET>,
            MaxVerticalShiftRatio: MaxVerticalShiftRatio::<Impl, IMPL_OFFSET>,
            SetMaxVerticalShiftRatio: SetMaxVerticalShiftRatio::<Impl, IMPL_OFFSET>,
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            VerticalShift: VerticalShift::<Impl, IMPL_OFFSET>,
            SetVerticalShift: SetVerticalShift::<Impl, IMPL_OFFSET>,
            VerticalSourceEndOffset: VerticalSourceEndOffset::<Impl, IMPL_OFFSET>,
            SetVerticalSourceEndOffset: SetVerticalSourceEndOffset::<Impl, IMPL_OFFSET>,
            VerticalSourceOffsetKind: VerticalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            SetVerticalSourceOffsetKind: SetVerticalSourceOffsetKind::<Impl, IMPL_OFFSET>,
            VerticalSourceStartOffset: VerticalSourceStartOffset::<Impl, IMPL_OFFSET>,
            SetVerticalSourceStartOffset: SetVerticalSourceStartOffset::<Impl, IMPL_OFFSET>,
            RefreshAutomaticHorizontalOffsets: RefreshAutomaticHorizontalOffsets::<Impl, IMPL_OFFSET>,
            RefreshAutomaticVerticalOffsets: RefreshAutomaticVerticalOffsets::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IParallaxView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ParallaxView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IParallaxViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IParallaxViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IParallaxViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IParallaxViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IParallaxViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewStatics_Impl: Sized {
    fn ChildProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceEndOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceOffsetKindProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceStartOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHorizontalShiftRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalShiftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHorizontalShiftClampedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVerticalShiftClampedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceEndOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceOffsetKindProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceStartOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxVerticalShiftRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalShiftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IParallaxViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IParallaxViewStatics_Vtbl {
        unsafe extern "system" fn ChildProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChildProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceEndOffsetProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceEndOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceOffsetKindProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceOffsetKindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceStartOffsetProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceStartOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHorizontalShiftRatioProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHorizontalShiftRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalShiftProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalShiftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHorizontalShiftClampedProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalShiftClampedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVerticalShiftClampedProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalShiftClampedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceEndOffsetProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceEndOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceOffsetKindProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceOffsetKindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceStartOffsetProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSourceStartOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxVerticalShiftRatioProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxVerticalShiftRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalShiftProperty<Impl: IParallaxViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalShiftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IParallaxViewStatics, BASE_OFFSET>(),
            ChildProperty: ChildProperty::<Impl, IMPL_OFFSET>,
            HorizontalSourceEndOffsetProperty: HorizontalSourceEndOffsetProperty::<Impl, IMPL_OFFSET>,
            HorizontalSourceOffsetKindProperty: HorizontalSourceOffsetKindProperty::<Impl, IMPL_OFFSET>,
            HorizontalSourceStartOffsetProperty: HorizontalSourceStartOffsetProperty::<Impl, IMPL_OFFSET>,
            MaxHorizontalShiftRatioProperty: MaxHorizontalShiftRatioProperty::<Impl, IMPL_OFFSET>,
            HorizontalShiftProperty: HorizontalShiftProperty::<Impl, IMPL_OFFSET>,
            IsHorizontalShiftClampedProperty: IsHorizontalShiftClampedProperty::<Impl, IMPL_OFFSET>,
            IsVerticalShiftClampedProperty: IsVerticalShiftClampedProperty::<Impl, IMPL_OFFSET>,
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            VerticalSourceEndOffsetProperty: VerticalSourceEndOffsetProperty::<Impl, IMPL_OFFSET>,
            VerticalSourceOffsetKindProperty: VerticalSourceOffsetKindProperty::<Impl, IMPL_OFFSET>,
            VerticalSourceStartOffsetProperty: VerticalSourceStartOffsetProperty::<Impl, IMPL_OFFSET>,
            MaxVerticalShiftRatioProperty: MaxVerticalShiftRatioProperty::<Impl, IMPL_OFFSET>,
            VerticalShiftProperty: VerticalShiftProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IParallaxViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPasswordBox_Impl: Sized {
    fn Password(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPassword(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PasswordChar(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPasswordChar(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsPasswordRevealButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPasswordRevealButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn PasswordChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePasswordChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPasswordBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox_Vtbl {
        unsafe extern "system" fn Password<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Password() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPassword<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPassword(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PasswordChar<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordChar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPasswordChar<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPasswordChar(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPasswordRevealButtonEnabled<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPasswordRevealButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPasswordRevealButtonEnabled<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPasswordRevealButtonEnabled(value).into()
        }
        unsafe extern "system" fn MaxLength<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        unsafe extern "system" fn PasswordChanged<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePasswordChanged<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePasswordChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IPasswordBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox, BASE_OFFSET>(),
            Password: Password::<Impl, IMPL_OFFSET>,
            SetPassword: SetPassword::<Impl, IMPL_OFFSET>,
            PasswordChar: PasswordChar::<Impl, IMPL_OFFSET>,
            SetPasswordChar: SetPasswordChar::<Impl, IMPL_OFFSET>,
            IsPasswordRevealButtonEnabled: IsPasswordRevealButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsPasswordRevealButtonEnabled: SetIsPasswordRevealButtonEnabled::<Impl, IMPL_OFFSET>,
            MaxLength: MaxLength::<Impl, IMPL_OFFSET>,
            SetMaxLength: SetMaxLength::<Impl, IMPL_OFFSET>,
            PasswordChanged: PasswordChanged::<Impl, IMPL_OFFSET>,
            RemovePasswordChanged: RemovePasswordChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPasswordBox2_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&mut self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPasswordBox2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox2_Vtbl {
        unsafe extern "system" fn Header<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn Paste<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: IPasswordBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus: PreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus: SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            Paste: Paste::<Impl, IMPL_OFFSET>,
            RemovePaste: RemovePaste::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IPasswordBox3_Impl: Sized {
    fn PasswordRevealMode(&mut self) -> ::windows::core::Result<PasswordRevealMode>;
    fn SetPasswordRevealMode(&mut self, value: PasswordRevealMode) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn InputScope(&mut self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&mut self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox3";
}
#[cfg(all(feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IPasswordBox3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox3_Vtbl {
        unsafe extern "system" fn PasswordRevealMode<Impl: IPasswordBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PasswordRevealMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordRevealMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPasswordRevealMode<Impl: IPasswordBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: PasswordRevealMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPasswordRevealMode(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IPasswordBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IPasswordBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn InputScope<Impl: IPasswordBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: IPasswordBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox3, BASE_OFFSET>(),
            PasswordRevealMode: PasswordRevealMode::<Impl, IMPL_OFFSET>,
            SetPasswordRevealMode: SetPasswordRevealMode::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
            InputScope: InputScope::<Impl, IMPL_OFFSET>,
            SetInputScope: SetInputScope::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPasswordBox4_Impl: Sized {
    fn PasswordChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePasswordChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPasswordBox4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox4_Vtbl {
        unsafe extern "system" fn PasswordChanging<Impl: IPasswordBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePasswordChanging<Impl: IPasswordBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePasswordChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox4, BASE_OFFSET>(),
            PasswordChanging: PasswordChanging::<Impl, IMPL_OFFSET>,
            RemovePasswordChanging: RemovePasswordChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IPasswordBox5_Impl: Sized {
    fn CanPasteClipboardContent(&mut self) -> ::windows::core::Result<bool>;
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PasteFromClipboard(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPasswordBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox5";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IPasswordBox5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBox5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBox5_Vtbl {
        unsafe extern "system" fn CanPasteClipboardContent<Impl: IPasswordBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: IPasswordBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IPasswordBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Description<Impl: IPasswordBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IPasswordBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PasteFromClipboard<Impl: IPasswordBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PasteFromClipboard().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBox5, BASE_OFFSET>(),
            CanPasteClipboardContent: CanPasteClipboardContent::<Impl, IMPL_OFFSET>,
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            PasteFromClipboard: PasteFromClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxPasswordChangingEventArgs_Impl: Sized {
    fn IsContentChanging(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxPasswordChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxPasswordChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxPasswordChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxPasswordChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxPasswordChangingEventArgs_Vtbl {
        unsafe extern "system" fn IsContentChanging<Impl: IPasswordBoxPasswordChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxPasswordChangingEventArgs, BASE_OFFSET>(),
            IsContentChanging: IsContentChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxPasswordChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics_Impl: Sized {
    fn PasswordProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PasswordCharProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPasswordRevealButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStatics_Vtbl {
        unsafe extern "system" fn PasswordProperty<Impl: IPasswordBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PasswordCharProperty<Impl: IPasswordBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordCharProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPasswordRevealButtonEnabledProperty<Impl: IPasswordBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPasswordRevealButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: IPasswordBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics, BASE_OFFSET>(),
            PasswordProperty: PasswordProperty::<Impl, IMPL_OFFSET>,
            PasswordCharProperty: PasswordCharProperty::<Impl, IMPL_OFFSET>,
            IsPasswordRevealButtonEnabledProperty: IsPasswordRevealButtonEnabledProperty::<Impl, IMPL_OFFSET>,
            MaxLengthProperty: MaxLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics2_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStatics2_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IPasswordBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IPasswordBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IPasswordBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IPasswordBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: IPasswordBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocusProperty: PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics3_Impl: Sized {
    fn PasswordRevealModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStatics3_Vtbl {
        unsafe extern "system" fn PasswordRevealModeProperty<Impl: IPasswordBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PasswordRevealModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IPasswordBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: IPasswordBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics3, BASE_OFFSET>(),
            PasswordRevealModeProperty: PasswordRevealModeProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
            InputScopeProperty: InputScopeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics5_Impl: Sized {
    fn CanPasteClipboardContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPasswordBoxStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPasswordBoxStatics5_Vtbl {
        unsafe extern "system" fn CanPasteClipboardContentProperty<Impl: IPasswordBoxStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IPasswordBoxStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IPasswordBoxStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPasswordBoxStatics5, BASE_OFFSET>(),
            CanPasteClipboardContentProperty: CanPasteClipboardContentProperty::<Impl, IMPL_OFFSET>,
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPasswordBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPathIcon_Impl: Sized {
    fn Data(&mut self) -> ::windows::core::Result<super::Media::Geometry>;
    fn SetData(&mut self, value: &::core::option::Option<super::Media::Geometry>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPathIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIcon";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPathIcon_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIcon_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIcon_Vtbl {
        unsafe extern "system" fn Data<Impl: IPathIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetData<Impl: IPathIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetData(&*(&value as *const <super::Media::Geometry as ::windows::core::Abi>::Abi as *const <super::Media::Geometry as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIcon, BASE_OFFSET>(),
            Data: Data::<Impl, IMPL_OFFSET>,
            SetData: SetData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PathIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPathIconFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPathIconSource_Impl: Sized {
    fn Data(&mut self) -> ::windows::core::Result<super::Media::Geometry>;
    fn SetData(&mut self, value: &::core::option::Option<super::Media::Geometry>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPathIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSource";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPathIconSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconSource_Vtbl {
        unsafe extern "system" fn Data<Impl: IPathIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetData<Impl: IPathIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetData(&*(&value as *const <super::Media::Geometry as ::windows::core::Abi>::Abi as *const <super::Media::Geometry as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconSource, BASE_OFFSET>(),
            Data: Data::<Impl, IMPL_OFFSET>,
            SetData: SetData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconSourceFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PathIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconSourceFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconSourceFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconSourceFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPathIconSourceFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconSourceStatics_Impl: Sized {
    fn DataProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconSourceStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconSourceStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconSourceStatics_Vtbl {
        unsafe extern "system" fn DataProperty<Impl: IPathIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconSourceStatics, BASE_OFFSET>(), DataProperty: DataProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconStatics_Impl: Sized {
    fn DataProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPathIconStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPathIconStatics_Vtbl {
        unsafe extern "system" fn DataProperty<Impl: IPathIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPathIconStatics, BASE_OFFSET>(), DataProperty: DataProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPathIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Contacts", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IPersonPicture_Impl: Sized {
    fn BadgeNumber(&mut self) -> ::windows::core::Result<i32>;
    fn SetBadgeNumber(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn BadgeGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetBadgeGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn BadgeImageSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetBadgeImageSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn BadgeText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetBadgeText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsGroup(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsGroup(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Contact(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Contacts::Contact>;
    fn SetContact(&mut self, value: &::core::option::Option<super::super::super::ApplicationModel::Contacts::Contact>) -> ::windows::core::Result<()>;
    fn DisplayName(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayName(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Initials(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetInitials(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PreferSmallImage(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreferSmallImage(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ProfilePicture(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetProfilePicture(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "ApplicationModel_Contacts", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPersonPicture {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPicture";
}
#[cfg(all(feature = "ApplicationModel_Contacts", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IPersonPicture_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersonPicture_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersonPicture_Vtbl {
        unsafe extern "system" fn BadgeNumber<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeNumber<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeNumber(value).into()
        }
        unsafe extern "system" fn BadgeGlyph<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeGlyph<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BadgeImageSource<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeImageSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeImageSource<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeImageSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BadgeText<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeText<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBadgeText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGroup<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroup() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroup<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsGroup(value).into()
        }
        unsafe extern "system" fn Contact<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Contact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContact<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContact(&*(&value as *const <super::super::super::ApplicationModel::Contacts::Contact as ::windows::core::Abi>::Abi as *const <super::super::super::ApplicationModel::Contacts::Contact as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayName<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayName<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Initials<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Initials() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitials<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInitials(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreferSmallImage<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreferSmallImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreferSmallImage<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreferSmallImage(value).into()
        }
        unsafe extern "system" fn ProfilePicture<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProfilePicture() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProfilePicture<Impl: IPersonPicture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProfilePicture(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPersonPicture, BASE_OFFSET>(),
            BadgeNumber: BadgeNumber::<Impl, IMPL_OFFSET>,
            SetBadgeNumber: SetBadgeNumber::<Impl, IMPL_OFFSET>,
            BadgeGlyph: BadgeGlyph::<Impl, IMPL_OFFSET>,
            SetBadgeGlyph: SetBadgeGlyph::<Impl, IMPL_OFFSET>,
            BadgeImageSource: BadgeImageSource::<Impl, IMPL_OFFSET>,
            SetBadgeImageSource: SetBadgeImageSource::<Impl, IMPL_OFFSET>,
            BadgeText: BadgeText::<Impl, IMPL_OFFSET>,
            SetBadgeText: SetBadgeText::<Impl, IMPL_OFFSET>,
            IsGroup: IsGroup::<Impl, IMPL_OFFSET>,
            SetIsGroup: SetIsGroup::<Impl, IMPL_OFFSET>,
            Contact: Contact::<Impl, IMPL_OFFSET>,
            SetContact: SetContact::<Impl, IMPL_OFFSET>,
            DisplayName: DisplayName::<Impl, IMPL_OFFSET>,
            SetDisplayName: SetDisplayName::<Impl, IMPL_OFFSET>,
            Initials: Initials::<Impl, IMPL_OFFSET>,
            SetInitials: SetInitials::<Impl, IMPL_OFFSET>,
            PreferSmallImage: PreferSmallImage::<Impl, IMPL_OFFSET>,
            SetPreferSmallImage: SetPreferSmallImage::<Impl, IMPL_OFFSET>,
            ProfilePicture: ProfilePicture::<Impl, IMPL_OFFSET>,
            SetProfilePicture: SetProfilePicture::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersonPicture as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPersonPictureFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PersonPicture>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPersonPictureFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPictureFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPersonPictureFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersonPictureFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersonPictureFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPersonPictureFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPersonPictureFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersonPictureFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPersonPictureStatics_Impl: Sized {
    fn BadgeNumberProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeImageSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContactProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayNameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InitialsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreferSmallImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProfilePictureProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPersonPictureStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPictureStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPersonPictureStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersonPictureStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersonPictureStatics_Vtbl {
        unsafe extern "system" fn BadgeNumberProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeNumberProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeGlyphProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeImageSourceProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeImageSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeTextProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BadgeTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsGroupProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContactProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayNameProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitialsProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreferSmallImageProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreferSmallImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProfilePictureProperty<Impl: IPersonPictureStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProfilePictureProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPersonPictureStatics, BASE_OFFSET>(),
            BadgeNumberProperty: BadgeNumberProperty::<Impl, IMPL_OFFSET>,
            BadgeGlyphProperty: BadgeGlyphProperty::<Impl, IMPL_OFFSET>,
            BadgeImageSourceProperty: BadgeImageSourceProperty::<Impl, IMPL_OFFSET>,
            BadgeTextProperty: BadgeTextProperty::<Impl, IMPL_OFFSET>,
            IsGroupProperty: IsGroupProperty::<Impl, IMPL_OFFSET>,
            ContactProperty: ContactProperty::<Impl, IMPL_OFFSET>,
            DisplayNameProperty: DisplayNameProperty::<Impl, IMPL_OFFSET>,
            InitialsProperty: InitialsProperty::<Impl, IMPL_OFFSET>,
            PreferSmallImageProperty: PreferSmallImageProperty::<Impl, IMPL_OFFSET>,
            ProfilePictureProperty: ProfilePictureProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersonPictureStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerConfirmedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerConfirmedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerConfirmedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerConfirmedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerConfirmedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerConfirmedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerConfirmedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerConfirmedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPickerFlyout_Impl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ConfirmationButtonsVisible(&mut self) -> ::windows::core::Result<bool>;
    fn SetConfirmationButtonsVisible(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Confirmed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveConfirmed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<bool>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPickerFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerFlyout_Vtbl {
        unsafe extern "system" fn Content<Impl: IPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ConfirmationButtonsVisible<Impl: IPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfirmationButtonsVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfirmationButtonsVisible<Impl: IPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConfirmationButtonsVisible(value).into()
        }
        unsafe extern "system" fn Confirmed<Impl: IPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Confirmed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveConfirmed<Impl: IPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveConfirmed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IPickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerFlyout, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            ConfirmationButtonsVisible: ConfirmationButtonsVisible::<Impl, IMPL_OFFSET>,
            SetConfirmationButtonsVisible: SetConfirmationButtonsVisible::<Impl, IMPL_OFFSET>,
            Confirmed: Confirmed::<Impl, IMPL_OFFSET>,
            RemoveConfirmed: RemoveConfirmed::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerFlyoutPresenter_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerFlyoutPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerFlyoutPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerFlyoutPresenter_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerFlyoutStatics_Impl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ConfirmationButtonsVisibleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerFlyoutStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPickerFlyoutStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPickerFlyoutStatics_Vtbl {
        unsafe extern "system" fn ContentProperty<Impl: IPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfirmationButtonsVisibleProperty<Impl: IPickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfirmationButtonsVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPickerFlyoutStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            ConfirmationButtonsVisibleProperty: ConfirmationButtonsVisibleProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IPivot_Impl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetTitle(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TitleTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetTitleTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn SelectedIndex(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectedIndex(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn IsLocked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsLocked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<SelectionChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemLoading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemLoading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemLoaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemLoaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemUnloading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemUnloading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemUnloaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemUnloaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IPivot {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IPivot_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivot_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivot_Vtbl {
        unsafe extern "system" fn Title<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TitleTemplate<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitleTemplate<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitleTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedIndex<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedIndex<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedIndex(value).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsLocked<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsLocked<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsLocked(value).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <SelectionChangedEventHandler as ::windows::core::Abi>::Abi as *const <SelectionChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemLoading<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemLoading<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemLoaded<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemLoaded<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemUnloading<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemUnloading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemUnloading<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemUnloading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemUnloaded<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PivotItemUnloaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemUnloaded<Impl: IPivot_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePivotItemUnloaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivot, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            TitleTemplate: TitleTemplate::<Impl, IMPL_OFFSET>,
            SetTitleTemplate: SetTitleTemplate::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            SelectedIndex: SelectedIndex::<Impl, IMPL_OFFSET>,
            SetSelectedIndex: SetSelectedIndex::<Impl, IMPL_OFFSET>,
            SelectedItem: SelectedItem::<Impl, IMPL_OFFSET>,
            SetSelectedItem: SetSelectedItem::<Impl, IMPL_OFFSET>,
            IsLocked: IsLocked::<Impl, IMPL_OFFSET>,
            SetIsLocked: SetIsLocked::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            PivotItemLoading: PivotItemLoading::<Impl, IMPL_OFFSET>,
            RemovePivotItemLoading: RemovePivotItemLoading::<Impl, IMPL_OFFSET>,
            PivotItemLoaded: PivotItemLoaded::<Impl, IMPL_OFFSET>,
            RemovePivotItemLoaded: RemovePivotItemLoaded::<Impl, IMPL_OFFSET>,
            PivotItemUnloading: PivotItemUnloading::<Impl, IMPL_OFFSET>,
            RemovePivotItemUnloading: RemovePivotItemUnloading::<Impl, IMPL_OFFSET>,
            PivotItemUnloaded: PivotItemUnloaded::<Impl, IMPL_OFFSET>,
            RemovePivotItemUnloaded: RemovePivotItemUnloaded::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivot as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivot2_Impl: Sized {
    fn LeftHeader(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetLeftHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn LeftHeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetLeftHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn RightHeader(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetRightHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn RightHeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetRightHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivot2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot2";
}
#[cfg(feature = "implement_exclusive")]
impl IPivot2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivot2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivot2_Vtbl {
        unsafe extern "system" fn LeftHeader<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeader<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LeftHeaderTemplate<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeaderTemplate<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightHeader<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightHeader<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightHeaderTemplate<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightHeaderTemplate<Impl: IPivot2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivot2, BASE_OFFSET>(),
            LeftHeader: LeftHeader::<Impl, IMPL_OFFSET>,
            SetLeftHeader: SetLeftHeader::<Impl, IMPL_OFFSET>,
            LeftHeaderTemplate: LeftHeaderTemplate::<Impl, IMPL_OFFSET>,
            SetLeftHeaderTemplate: SetLeftHeaderTemplate::<Impl, IMPL_OFFSET>,
            RightHeader: RightHeader::<Impl, IMPL_OFFSET>,
            SetRightHeader: SetRightHeader::<Impl, IMPL_OFFSET>,
            RightHeaderTemplate: RightHeaderTemplate::<Impl, IMPL_OFFSET>,
            SetRightHeaderTemplate: SetRightHeaderTemplate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivot2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivot3_Impl: Sized {
    fn HeaderFocusVisualPlacement(&mut self) -> ::windows::core::Result<PivotHeaderFocusVisualPlacement>;
    fn SetHeaderFocusVisualPlacement(&mut self, value: PivotHeaderFocusVisualPlacement) -> ::windows::core::Result<()>;
    fn IsHeaderItemsCarouselEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHeaderItemsCarouselEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivot3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot3";
}
#[cfg(feature = "implement_exclusive")]
impl IPivot3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivot3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivot3_Vtbl {
        unsafe extern "system" fn HeaderFocusVisualPlacement<Impl: IPivot3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut PivotHeaderFocusVisualPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderFocusVisualPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderFocusVisualPlacement<Impl: IPivot3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: PivotHeaderFocusVisualPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderFocusVisualPlacement(value).into()
        }
        unsafe extern "system" fn IsHeaderItemsCarouselEnabled<Impl: IPivot3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderItemsCarouselEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHeaderItemsCarouselEnabled<Impl: IPivot3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHeaderItemsCarouselEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivot3, BASE_OFFSET>(),
            HeaderFocusVisualPlacement: HeaderFocusVisualPlacement::<Impl, IMPL_OFFSET>,
            SetHeaderFocusVisualPlacement: SetHeaderFocusVisualPlacement::<Impl, IMPL_OFFSET>,
            IsHeaderItemsCarouselEnabled: IsHeaderItemsCarouselEnabled::<Impl, IMPL_OFFSET>,
            SetIsHeaderItemsCarouselEnabled: SetIsHeaderItemsCarouselEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivot3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Pivot>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPivotFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItem_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItem";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItem_Vtbl {
        unsafe extern "system" fn Header<Impl: IPivotItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IPivotItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItem, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemEventArgs_Impl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<PivotItem>;
    fn SetItem(&mut self, value: &::core::option::Option<PivotItem>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItemEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItemEventArgs_Vtbl {
        unsafe extern "system" fn Item<Impl: IPivotItemEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IPivotItemEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(&*(&value as *const <PivotItem as ::windows::core::Abi>::Abi as *const <PivotItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItemEventArgs, BASE_OFFSET>(),
            Item: Item::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItemEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PivotItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPivotItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItemFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemStatics_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotItemStatics_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IPivotItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotItemStatics, BASE_OFFSET>(), HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStatics_Impl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TitleTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedIndexProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsLockedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SlideInAnimationGroupProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetSlideInAnimationGroup(&mut self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<PivotSlideInAnimationGroup>;
    fn SetSlideInAnimationGroup(&mut self, element: &::core::option::Option<super::FrameworkElement>, value: PivotSlideInAnimationGroup) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotStatics_Vtbl {
        unsafe extern "system" fn TitleProperty<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitleTemplateProperty<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedIndexProperty<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsLockedProperty<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsLockedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SlideInAnimationGroupProperty<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SlideInAnimationGroupProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSlideInAnimationGroup<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut PivotSlideInAnimationGroup) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSlideInAnimationGroup(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSlideInAnimationGroup<Impl: IPivotStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: PivotSlideInAnimationGroup) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSlideInAnimationGroup(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            TitleTemplateProperty: TitleTemplateProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            SelectedIndexProperty: SelectedIndexProperty::<Impl, IMPL_OFFSET>,
            SelectedItemProperty: SelectedItemProperty::<Impl, IMPL_OFFSET>,
            IsLockedProperty: IsLockedProperty::<Impl, IMPL_OFFSET>,
            SlideInAnimationGroupProperty: SlideInAnimationGroupProperty::<Impl, IMPL_OFFSET>,
            GetSlideInAnimationGroup: GetSlideInAnimationGroup::<Impl, IMPL_OFFSET>,
            SetSlideInAnimationGroup: SetSlideInAnimationGroup::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStatics2_Impl: Sized {
    fn LeftHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftHeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightHeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotStatics2_Vtbl {
        unsafe extern "system" fn LeftHeaderProperty<Impl: IPivotStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftHeaderTemplateProperty<Impl: IPivotStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightHeaderProperty<Impl: IPivotStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightHeaderTemplateProperty<Impl: IPivotStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightHeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotStatics2, BASE_OFFSET>(),
            LeftHeaderProperty: LeftHeaderProperty::<Impl, IMPL_OFFSET>,
            LeftHeaderTemplateProperty: LeftHeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            RightHeaderProperty: RightHeaderProperty::<Impl, IMPL_OFFSET>,
            RightHeaderTemplateProperty: RightHeaderTemplateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStatics3_Impl: Sized {
    fn HeaderFocusVisualPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHeaderItemsCarouselEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPivotStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPivotStatics3_Vtbl {
        unsafe extern "system" fn HeaderFocusVisualPlacementProperty<Impl: IPivotStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderFocusVisualPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHeaderItemsCarouselEnabledProperty<Impl: IPivotStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHeaderItemsCarouselEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IPivotStatics3, BASE_OFFSET>(),
            HeaderFocusVisualPlacementProperty: HeaderFocusVisualPlacementProperty::<Impl, IMPL_OFFSET>,
            IsHeaderItemsCarouselEnabledProperty: IsHeaderItemsCarouselEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPivotStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IProgressBar_Impl: Sized {
    fn IsIndeterminate(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsIndeterminate(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ShowError(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowError(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ShowPaused(&mut self) -> ::windows::core::Result<bool>;
    fn SetShowPaused(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ProgressBarTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IProgressBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBar";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IProgressBar_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressBar_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressBar_Vtbl {
        unsafe extern "system" fn IsIndeterminate<Impl: IProgressBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIndeterminate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsIndeterminate<Impl: IProgressBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsIndeterminate(value).into()
        }
        unsafe extern "system" fn ShowError<Impl: IProgressBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowError() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowError<Impl: IProgressBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowError(value).into()
        }
        unsafe extern "system" fn ShowPaused<Impl: IProgressBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowPaused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowPaused<Impl: IProgressBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetShowPaused(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IProgressBar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressBar, BASE_OFFSET>(),
            IsIndeterminate: IsIndeterminate::<Impl, IMPL_OFFSET>,
            SetIsIndeterminate: SetIsIndeterminate::<Impl, IMPL_OFFSET>,
            ShowError: ShowError::<Impl, IMPL_OFFSET>,
            SetShowError: SetShowError::<Impl, IMPL_OFFSET>,
            ShowPaused: ShowPaused::<Impl, IMPL_OFFSET>,
            SetShowPaused: SetShowPaused::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressBar as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressBarFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ProgressBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressBarFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressBarFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressBarFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IProgressBarFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressBarFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressBarFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressBarStatics_Impl: Sized {
    fn IsIndeterminateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowErrorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowPausedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressBarStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressBarStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressBarStatics_Vtbl {
        unsafe extern "system" fn IsIndeterminateProperty<Impl: IProgressBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIndeterminateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowErrorProperty<Impl: IProgressBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowErrorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowPausedProperty<Impl: IProgressBarStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowPausedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressBarStatics, BASE_OFFSET>(),
            IsIndeterminateProperty: IsIndeterminateProperty::<Impl, IMPL_OFFSET>,
            ShowErrorProperty: ShowErrorProperty::<Impl, IMPL_OFFSET>,
            ShowPausedProperty: ShowPausedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressBarStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IProgressRing_Impl: Sized {
    fn IsActive(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsActive(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ProgressRingTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IProgressRing {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressRing";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IProgressRing_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressRing_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressRing_Vtbl {
        unsafe extern "system" fn IsActive<Impl: IProgressRing_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsActive<Impl: IProgressRing_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsActive(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IProgressRing_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressRing, BASE_OFFSET>(),
            IsActive: IsActive::<Impl, IMPL_OFFSET>,
            SetIsActive: SetIsActive::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressRing as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressRingStatics_Impl: Sized {
    fn IsActiveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressRingStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressRingStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressRingStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IProgressRingStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IProgressRingStatics_Vtbl {
        unsafe extern "system" fn IsActiveProperty<Impl: IProgressRingStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IProgressRingStatics, BASE_OFFSET>(),
            IsActiveProperty: IsActiveProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IProgressRingStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButton_Impl: Sized {
    fn GroupName(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGroupName(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButton";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRadioButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRadioButton_Vtbl {
        unsafe extern "system" fn GroupName<Impl: IRadioButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupName<Impl: IRadioButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRadioButton, BASE_OFFSET>(),
            GroupName: GroupName::<Impl, IMPL_OFFSET>,
            SetGroupName: SetGroupName::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRadioButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RadioButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRadioButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRadioButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRadioButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRadioButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRadioButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonStatics_Impl: Sized {
    fn GroupNameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRadioButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRadioButtonStatics_Vtbl {
        unsafe extern "system" fn GroupNameProperty<Impl: IRadioButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GroupNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRadioButtonStatics, BASE_OFFSET>(),
            GroupNameProperty: GroupNameProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRadioButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRatingControl_Impl: Sized {
    fn Caption(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCaption(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn InitialSetValue(&mut self) -> ::windows::core::Result<i32>;
    fn SetInitialSetValue(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn IsClearEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsClearEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsReadOnly(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn MaxRating(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxRating(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn PlaceholderValue(&mut self) -> ::windows::core::Result<f64>;
    fn SetPlaceholderValue(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemInfo(&mut self) -> ::windows::core::Result<RatingItemInfo>;
    fn SetItemInfo(&mut self, value: &::core::option::Option<RatingItemInfo>) -> ::windows::core::Result<()>;
    fn Value(&mut self) -> ::windows::core::Result<f64>;
    fn SetValue(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ValueChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveValueChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRatingControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControl";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRatingControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingControl_Vtbl {
        unsafe extern "system" fn Caption<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Caption() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCaption<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCaption(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InitialSetValue<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialSetValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitialSetValue<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInitialSetValue(value).into()
        }
        unsafe extern "system" fn IsClearEnabled<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsClearEnabled<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsClearEnabled(value).into()
        }
        unsafe extern "system" fn IsReadOnly<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn MaxRating<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxRating() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxRating<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxRating(value).into()
        }
        unsafe extern "system" fn PlaceholderValue<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderValue<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderValue(value).into()
        }
        unsafe extern "system" fn ItemInfo<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemInfo<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemInfo(&*(&value as *const <RatingItemInfo as ::windows::core::Abi>::Abi as *const <RatingItemInfo as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Value<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetValue(value).into()
        }
        unsafe extern "system" fn ValueChanged<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ValueChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveValueChanged<Impl: IRatingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveValueChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingControl, BASE_OFFSET>(),
            Caption: Caption::<Impl, IMPL_OFFSET>,
            SetCaption: SetCaption::<Impl, IMPL_OFFSET>,
            InitialSetValue: InitialSetValue::<Impl, IMPL_OFFSET>,
            SetInitialSetValue: SetInitialSetValue::<Impl, IMPL_OFFSET>,
            IsClearEnabled: IsClearEnabled::<Impl, IMPL_OFFSET>,
            SetIsClearEnabled: SetIsClearEnabled::<Impl, IMPL_OFFSET>,
            IsReadOnly: IsReadOnly::<Impl, IMPL_OFFSET>,
            SetIsReadOnly: SetIsReadOnly::<Impl, IMPL_OFFSET>,
            MaxRating: MaxRating::<Impl, IMPL_OFFSET>,
            SetMaxRating: SetMaxRating::<Impl, IMPL_OFFSET>,
            PlaceholderValue: PlaceholderValue::<Impl, IMPL_OFFSET>,
            SetPlaceholderValue: SetPlaceholderValue::<Impl, IMPL_OFFSET>,
            ItemInfo: ItemInfo::<Impl, IMPL_OFFSET>,
            SetItemInfo: SetItemInfo::<Impl, IMPL_OFFSET>,
            Value: Value::<Impl, IMPL_OFFSET>,
            SetValue: SetValue::<Impl, IMPL_OFFSET>,
            ValueChanged: ValueChanged::<Impl, IMPL_OFFSET>,
            RemoveValueChanged: RemoveValueChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingControlFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingControlFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingControlFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingControlFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingControlFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingControlStatics_Impl: Sized {
    fn CaptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InitialSetValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsClearEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsReadOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxRatingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemInfoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingControlStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingControlStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingControlStatics_Vtbl {
        unsafe extern "system" fn CaptionProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CaptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitialSetValueProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitialSetValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsClearEnabledProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsClearEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsReadOnlyProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxRatingProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxRatingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderValueProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemInfoProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInfoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ValueProperty<Impl: IRatingControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingControlStatics, BASE_OFFSET>(),
            CaptionProperty: CaptionProperty::<Impl, IMPL_OFFSET>,
            InitialSetValueProperty: InitialSetValueProperty::<Impl, IMPL_OFFSET>,
            IsClearEnabledProperty: IsClearEnabledProperty::<Impl, IMPL_OFFSET>,
            IsReadOnlyProperty: IsReadOnlyProperty::<Impl, IMPL_OFFSET>,
            MaxRatingProperty: MaxRatingProperty::<Impl, IMPL_OFFSET>,
            PlaceholderValueProperty: PlaceholderValueProperty::<Impl, IMPL_OFFSET>,
            ItemInfoProperty: ItemInfoProperty::<Impl, IMPL_OFFSET>,
            ValueProperty: ValueProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfo_Impl: Sized {
    fn DisabledGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisabledGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Glyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PointerOverGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPointerOverGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PointerOverPlaceholderGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPointerOverPlaceholderGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn UnsetGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetUnsetGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfo";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemFontInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemFontInfo_Vtbl {
        unsafe extern "system" fn DisabledGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Glyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverPlaceholderGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverPlaceholderGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverPlaceholderGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsetGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnsetGlyph<Impl: IRatingItemFontInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUnsetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemFontInfo, BASE_OFFSET>(),
            DisabledGlyph: DisabledGlyph::<Impl, IMPL_OFFSET>,
            SetDisabledGlyph: SetDisabledGlyph::<Impl, IMPL_OFFSET>,
            Glyph: Glyph::<Impl, IMPL_OFFSET>,
            SetGlyph: SetGlyph::<Impl, IMPL_OFFSET>,
            PointerOverGlyph: PointerOverGlyph::<Impl, IMPL_OFFSET>,
            SetPointerOverGlyph: SetPointerOverGlyph::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderGlyph: PointerOverPlaceholderGlyph::<Impl, IMPL_OFFSET>,
            SetPointerOverPlaceholderGlyph: SetPointerOverPlaceholderGlyph::<Impl, IMPL_OFFSET>,
            PlaceholderGlyph: PlaceholderGlyph::<Impl, IMPL_OFFSET>,
            SetPlaceholderGlyph: SetPlaceholderGlyph::<Impl, IMPL_OFFSET>,
            UnsetGlyph: UnsetGlyph::<Impl, IMPL_OFFSET>,
            SetUnsetGlyph: SetUnsetGlyph::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemFontInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemFontInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemFontInfoFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemFontInfoFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemFontInfoFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemFontInfoFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemFontInfoFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoStatics_Impl: Sized {
    fn DisabledGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverPlaceholderGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UnsetGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfoStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemFontInfoStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemFontInfoStatics_Vtbl {
        unsafe extern "system" fn DisabledGlyphProperty<Impl: IRatingItemFontInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphProperty<Impl: IRatingItemFontInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderGlyphProperty<Impl: IRatingItemFontInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverGlyphProperty<Impl: IRatingItemFontInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverPlaceholderGlyphProperty<Impl: IRatingItemFontInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsetGlyphProperty<Impl: IRatingItemFontInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemFontInfoStatics, BASE_OFFSET>(),
            DisabledGlyphProperty: DisabledGlyphProperty::<Impl, IMPL_OFFSET>,
            GlyphProperty: GlyphProperty::<Impl, IMPL_OFFSET>,
            PlaceholderGlyphProperty: PlaceholderGlyphProperty::<Impl, IMPL_OFFSET>,
            PointerOverGlyphProperty: PointerOverGlyphProperty::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderGlyphProperty: PointerOverPlaceholderGlyphProperty::<Impl, IMPL_OFFSET>,
            UnsetGlyphProperty: UnsetGlyphProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemFontInfoStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRatingItemImageInfo_Impl: Sized {
    fn DisabledImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetDisabledImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Image(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PlaceholderImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPlaceholderImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PointerOverImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPointerOverImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PointerOverPlaceholderImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPointerOverPlaceholderImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn UnsetImage(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetUnsetImage(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRatingItemImageInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfo";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRatingItemImageInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemImageInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemImageInfo_Vtbl {
        unsafe extern "system" fn DisabledImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Image<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Image() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverPlaceholderImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverPlaceholderImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointerOverPlaceholderImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsetImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnsetImage<Impl: IRatingItemImageInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUnsetImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemImageInfo, BASE_OFFSET>(),
            DisabledImage: DisabledImage::<Impl, IMPL_OFFSET>,
            SetDisabledImage: SetDisabledImage::<Impl, IMPL_OFFSET>,
            Image: Image::<Impl, IMPL_OFFSET>,
            SetImage: SetImage::<Impl, IMPL_OFFSET>,
            PlaceholderImage: PlaceholderImage::<Impl, IMPL_OFFSET>,
            SetPlaceholderImage: SetPlaceholderImage::<Impl, IMPL_OFFSET>,
            PointerOverImage: PointerOverImage::<Impl, IMPL_OFFSET>,
            SetPointerOverImage: SetPointerOverImage::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderImage: PointerOverPlaceholderImage::<Impl, IMPL_OFFSET>,
            SetPointerOverPlaceholderImage: SetPointerOverPlaceholderImage::<Impl, IMPL_OFFSET>,
            UnsetImage: UnsetImage::<Impl, IMPL_OFFSET>,
            SetUnsetImage: SetUnsetImage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemImageInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemImageInfoFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemImageInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemImageInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemImageInfoFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemImageInfoFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemImageInfoFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemImageInfoFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemImageInfoFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemImageInfoFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemImageInfoStatics_Impl: Sized {
    fn DisabledImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverPlaceholderImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UnsetImageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemImageInfoStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemImageInfoStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemImageInfoStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemImageInfoStatics_Vtbl {
        unsafe extern "system" fn DisabledImageProperty<Impl: IRatingItemImageInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ImageProperty<Impl: IRatingItemImageInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderImageProperty<Impl: IRatingItemImageInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverImageProperty<Impl: IRatingItemImageInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverPlaceholderImageProperty<Impl: IRatingItemImageInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsetImageProperty<Impl: IRatingItemImageInfoStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsetImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemImageInfoStatics, BASE_OFFSET>(),
            DisabledImageProperty: DisabledImageProperty::<Impl, IMPL_OFFSET>,
            ImageProperty: ImageProperty::<Impl, IMPL_OFFSET>,
            PlaceholderImageProperty: PlaceholderImageProperty::<Impl, IMPL_OFFSET>,
            PointerOverImageProperty: PointerOverImageProperty::<Impl, IMPL_OFFSET>,
            PointerOverPlaceholderImageProperty: PointerOverPlaceholderImageProperty::<Impl, IMPL_OFFSET>,
            UnsetImageProperty: UnsetImageProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemImageInfoStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemInfo_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemInfo";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemInfo_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemInfo, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemInfoFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemInfoFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRatingItemInfoFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRatingItemInfoFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemInfoFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRatingItemInfoFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRatingItemInfoFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRefreshContainer_Impl: Sized {
    fn Visualizer(&mut self) -> ::windows::core::Result<RefreshVisualizer>;
    fn SetVisualizer(&mut self, value: &::core::option::Option<RefreshVisualizer>) -> ::windows::core::Result<()>;
    fn PullDirection(&mut self) -> ::windows::core::Result<RefreshPullDirection>;
    fn SetPullDirection(&mut self, value: RefreshPullDirection) -> ::windows::core::Result<()>;
    fn RefreshRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RequestRefresh(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRefreshContainer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainer";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRefreshContainer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshContainer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshContainer_Vtbl {
        unsafe extern "system" fn Visualizer<Impl: IRefreshContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Visualizer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVisualizer<Impl: IRefreshContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVisualizer(&*(&value as *const <RefreshVisualizer as ::windows::core::Abi>::Abi as *const <RefreshVisualizer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PullDirection<Impl: IRefreshContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshPullDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PullDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPullDirection<Impl: IRefreshContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RefreshPullDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPullDirection(value).into()
        }
        unsafe extern "system" fn RefreshRequested<Impl: IRefreshContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RefreshRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshRequested<Impl: IRefreshContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRefreshRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RequestRefresh<Impl: IRefreshContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestRefresh().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshContainer, BASE_OFFSET>(),
            Visualizer: Visualizer::<Impl, IMPL_OFFSET>,
            SetVisualizer: SetVisualizer::<Impl, IMPL_OFFSET>,
            PullDirection: PullDirection::<Impl, IMPL_OFFSET>,
            SetPullDirection: SetPullDirection::<Impl, IMPL_OFFSET>,
            RefreshRequested: RefreshRequested::<Impl, IMPL_OFFSET>,
            RemoveRefreshRequested: RemoveRefreshRequested::<Impl, IMPL_OFFSET>,
            RequestRefresh: RequestRefresh::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshContainer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshContainerFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RefreshContainer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshContainerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshContainerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshContainerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshContainerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRefreshContainerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshContainerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshContainerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshContainerStatics_Impl: Sized {
    fn VisualizerProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PullDirectionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshContainerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshContainerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshContainerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshContainerStatics_Vtbl {
        unsafe extern "system" fn VisualizerProperty<Impl: IRefreshContainerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VisualizerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PullDirectionProperty<Impl: IRefreshContainerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PullDirectionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshContainerStatics, BASE_OFFSET>(),
            VisualizerProperty: VisualizerProperty::<Impl, IMPL_OFFSET>,
            PullDirectionProperty: PullDirectionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshContainerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshInteractionRatioChangedEventArgs_Impl: Sized {
    fn InteractionRatio(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshInteractionRatioChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshInteractionRatioChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshInteractionRatioChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshInteractionRatioChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshInteractionRatioChangedEventArgs_Vtbl {
        unsafe extern "system" fn InteractionRatio<Impl: IRefreshInteractionRatioChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InteractionRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshInteractionRatioChangedEventArgs, BASE_OFFSET>(),
            InteractionRatio: InteractionRatio::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshInteractionRatioChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRefreshRequestedEventArgs_Impl: Sized {
    fn GetDeferral(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Deferral>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRefreshRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshRequestedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRefreshRequestedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshRequestedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshRequestedEventArgs_Vtbl {
        unsafe extern "system" fn GetDeferral<Impl: IRefreshRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshRequestedEventArgs, BASE_OFFSET>(),
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshStateChangedEventArgs_Impl: Sized {
    fn OldState(&mut self) -> ::windows::core::Result<RefreshVisualizerState>;
    fn NewState(&mut self) -> ::windows::core::Result<RefreshVisualizerState>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshStateChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshStateChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshStateChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshStateChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshStateChangedEventArgs_Vtbl {
        unsafe extern "system" fn OldState<Impl: IRefreshStateChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewState<Impl: IRefreshStateChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshStateChangedEventArgs, BASE_OFFSET>(),
            OldState: OldState::<Impl, IMPL_OFFSET>,
            NewState: NewState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshStateChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRefreshVisualizer_Impl: Sized {
    fn RequestRefresh(&mut self) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<RefreshVisualizerOrientation>;
    fn SetOrientation(&mut self, value: RefreshVisualizerOrientation) -> ::windows::core::Result<()>;
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn State(&mut self) -> ::windows::core::Result<RefreshVisualizerState>;
    fn RefreshRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RefreshStateChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshStateChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRefreshVisualizer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizer";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRefreshVisualizer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshVisualizer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshVisualizer_Vtbl {
        unsafe extern "system" fn RequestRefresh<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestRefresh().into()
        }
        unsafe extern "system" fn Orientation<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerOrientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RefreshVisualizerOrientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn Content<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn State<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).State() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RefreshRequested<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RefreshRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshRequested<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRefreshRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RefreshStateChanged<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RefreshStateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshStateChanged<Impl: IRefreshVisualizer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRefreshStateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshVisualizer, BASE_OFFSET>(),
            RequestRefresh: RequestRefresh::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            State: State::<Impl, IMPL_OFFSET>,
            RefreshRequested: RefreshRequested::<Impl, IMPL_OFFSET>,
            RemoveRefreshRequested: RemoveRefreshRequested::<Impl, IMPL_OFFSET>,
            RefreshStateChanged: RefreshStateChanged::<Impl, IMPL_OFFSET>,
            RemoveRefreshStateChanged: RemoveRefreshStateChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshVisualizer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshVisualizerFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RefreshVisualizer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshVisualizerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshVisualizerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshVisualizerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshVisualizerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRefreshVisualizerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshVisualizerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshVisualizerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshVisualizerStatics_Impl: Sized {
    fn InfoProviderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshVisualizerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshVisualizerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRefreshVisualizerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRefreshVisualizerStatics_Vtbl {
        unsafe extern "system" fn InfoProviderProperty<Impl: IRefreshVisualizerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InfoProviderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IRefreshVisualizerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentProperty<Impl: IRefreshVisualizerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StateProperty<Impl: IRefreshVisualizerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRefreshVisualizerStatics, BASE_OFFSET>(),
            InfoProviderProperty: InfoProviderProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            StateProperty: StateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRefreshVisualizerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRelativePanel_Impl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRelativePanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanel";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRelativePanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanel_Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRelativePanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanel, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanel2_Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanel2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanel2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanel2_Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IRelativePanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IRelativePanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanel2, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RelativePanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanelFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanelFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRelativePanelFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanelFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelStatics_Impl: Sized {
    fn LeftOfProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetLeftOf(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetLeftOf(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AboveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAbove(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAbove(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn RightOfProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRightOf(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetRightOf(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn BelowProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetBelow(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetBelow(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignHorizontalCenterWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignHorizontalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignHorizontalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignVerticalCenterWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignVerticalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignVerticalCenterWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignLeftWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignLeftWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignLeftWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignTopWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignTopWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignTopWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignRightWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignRightWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignRightWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignBottomWithProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignBottomWith(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignBottomWith(&mut self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignLeftWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignLeftWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignLeftWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignTopWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignTopWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignTopWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignRightWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignRightWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignRightWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignBottomWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignBottomWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignBottomWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignHorizontalCenterWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignHorizontalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignHorizontalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignVerticalCenterWithPanelProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignVerticalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignVerticalCenterWithPanel(&mut self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanelStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanelStatics_Vtbl {
        unsafe extern "system" fn LeftOfProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftOfProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeftOf<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLeftOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftOf<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AboveProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AboveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAbove<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAbove(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAbove<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAbove(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightOfProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightOfProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRightOf<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRightOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightOf<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BelowProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BelowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBelow<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBelow(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBelow<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBelow(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignHorizontalCenterWithProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignHorizontalCenterWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignHorizontalCenterWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignHorizontalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignHorizontalCenterWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignHorizontalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignVerticalCenterWithProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignVerticalCenterWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignVerticalCenterWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignVerticalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignVerticalCenterWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignVerticalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignLeftWithProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignLeftWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignLeftWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignLeftWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignLeftWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignLeftWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignTopWithProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignTopWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignTopWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignTopWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignTopWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignTopWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignRightWithProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignRightWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignRightWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignRightWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignRightWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignRightWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignBottomWithProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignBottomWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignBottomWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignBottomWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignBottomWith<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignBottomWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignLeftWithPanelProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignLeftWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignLeftWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignLeftWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignLeftWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignLeftWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignTopWithPanelProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignTopWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignTopWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignTopWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignTopWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignTopWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignRightWithPanelProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignRightWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignRightWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignRightWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignRightWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignRightWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignBottomWithPanelProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignBottomWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignBottomWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignBottomWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignBottomWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignBottomWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignHorizontalCenterWithPanelProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignHorizontalCenterWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignHorizontalCenterWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignHorizontalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignHorizontalCenterWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignHorizontalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignVerticalCenterWithPanelProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AlignVerticalCenterWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignVerticalCenterWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlignVerticalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignVerticalCenterWithPanel<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlignVerticalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRelativePanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanelStatics, BASE_OFFSET>(),
            LeftOfProperty: LeftOfProperty::<Impl, IMPL_OFFSET>,
            GetLeftOf: GetLeftOf::<Impl, IMPL_OFFSET>,
            SetLeftOf: SetLeftOf::<Impl, IMPL_OFFSET>,
            AboveProperty: AboveProperty::<Impl, IMPL_OFFSET>,
            GetAbove: GetAbove::<Impl, IMPL_OFFSET>,
            SetAbove: SetAbove::<Impl, IMPL_OFFSET>,
            RightOfProperty: RightOfProperty::<Impl, IMPL_OFFSET>,
            GetRightOf: GetRightOf::<Impl, IMPL_OFFSET>,
            SetRightOf: SetRightOf::<Impl, IMPL_OFFSET>,
            BelowProperty: BelowProperty::<Impl, IMPL_OFFSET>,
            GetBelow: GetBelow::<Impl, IMPL_OFFSET>,
            SetBelow: SetBelow::<Impl, IMPL_OFFSET>,
            AlignHorizontalCenterWithProperty: AlignHorizontalCenterWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignHorizontalCenterWith: GetAlignHorizontalCenterWith::<Impl, IMPL_OFFSET>,
            SetAlignHorizontalCenterWith: SetAlignHorizontalCenterWith::<Impl, IMPL_OFFSET>,
            AlignVerticalCenterWithProperty: AlignVerticalCenterWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignVerticalCenterWith: GetAlignVerticalCenterWith::<Impl, IMPL_OFFSET>,
            SetAlignVerticalCenterWith: SetAlignVerticalCenterWith::<Impl, IMPL_OFFSET>,
            AlignLeftWithProperty: AlignLeftWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignLeftWith: GetAlignLeftWith::<Impl, IMPL_OFFSET>,
            SetAlignLeftWith: SetAlignLeftWith::<Impl, IMPL_OFFSET>,
            AlignTopWithProperty: AlignTopWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignTopWith: GetAlignTopWith::<Impl, IMPL_OFFSET>,
            SetAlignTopWith: SetAlignTopWith::<Impl, IMPL_OFFSET>,
            AlignRightWithProperty: AlignRightWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignRightWith: GetAlignRightWith::<Impl, IMPL_OFFSET>,
            SetAlignRightWith: SetAlignRightWith::<Impl, IMPL_OFFSET>,
            AlignBottomWithProperty: AlignBottomWithProperty::<Impl, IMPL_OFFSET>,
            GetAlignBottomWith: GetAlignBottomWith::<Impl, IMPL_OFFSET>,
            SetAlignBottomWith: SetAlignBottomWith::<Impl, IMPL_OFFSET>,
            AlignLeftWithPanelProperty: AlignLeftWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignLeftWithPanel: GetAlignLeftWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignLeftWithPanel: SetAlignLeftWithPanel::<Impl, IMPL_OFFSET>,
            AlignTopWithPanelProperty: AlignTopWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignTopWithPanel: GetAlignTopWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignTopWithPanel: SetAlignTopWithPanel::<Impl, IMPL_OFFSET>,
            AlignRightWithPanelProperty: AlignRightWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignRightWithPanel: GetAlignRightWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignRightWithPanel: SetAlignRightWithPanel::<Impl, IMPL_OFFSET>,
            AlignBottomWithPanelProperty: AlignBottomWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignBottomWithPanel: GetAlignBottomWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignBottomWithPanel: SetAlignBottomWithPanel::<Impl, IMPL_OFFSET>,
            AlignHorizontalCenterWithPanelProperty: AlignHorizontalCenterWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignHorizontalCenterWithPanel: GetAlignHorizontalCenterWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignHorizontalCenterWithPanel: SetAlignHorizontalCenterWithPanel::<Impl, IMPL_OFFSET>,
            AlignVerticalCenterWithPanelProperty: AlignVerticalCenterWithPanelProperty::<Impl, IMPL_OFFSET>,
            GetAlignVerticalCenterWithPanel: GetAlignVerticalCenterWithPanel::<Impl, IMPL_OFFSET>,
            SetAlignVerticalCenterWithPanel: SetAlignVerticalCenterWithPanel::<Impl, IMPL_OFFSET>,
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelStatics2_Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRelativePanelStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRelativePanelStatics2_Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IRelativePanelStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRelativePanelStatics2, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRelativePanelStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait IRichEditBox_Impl: Sized {
    fn IsReadOnly(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AcceptsReturn(&mut self) -> ::windows::core::Result<bool>;
    fn SetAcceptsReturn(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn IsSpellCheckEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSpellCheckEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsTextPredictionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextPredictionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Document(&mut self) -> ::windows::core::Result<super::super::Text::ITextDocument>;
    fn InputScope(&mut self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&mut self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
    fn TextChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox";
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl IRichEditBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox_Vtbl {
        unsafe extern "system" fn IsReadOnly<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn AcceptsReturn<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAcceptsReturn<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAcceptsReturn(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn IsSpellCheckEnabled<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSpellCheckEnabled<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSpellCheckEnabled(value).into()
        }
        unsafe extern "system" fn IsTextPredictionEnabled<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextPredictionEnabled<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextPredictionEnabled(value).into()
        }
        unsafe extern "system" fn Document<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Document() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScope<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IRichEditBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox, BASE_OFFSET>(),
            IsReadOnly: IsReadOnly::<Impl, IMPL_OFFSET>,
            SetIsReadOnly: SetIsReadOnly::<Impl, IMPL_OFFSET>,
            AcceptsReturn: AcceptsReturn::<Impl, IMPL_OFFSET>,
            SetAcceptsReturn: SetAcceptsReturn::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabled: IsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            SetIsSpellCheckEnabled: SetIsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabled: IsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextPredictionEnabled: SetIsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            Document: Document::<Impl, IMPL_OFFSET>,
            InputScope: InputScope::<Impl, IMPL_OFFSET>,
            SetInputScope: SetInputScope::<Impl, IMPL_OFFSET>,
            TextChanged: TextChanged::<Impl, IMPL_OFFSET>,
            RemoveTextChanged: RemoveTextChanged::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichEditBox2_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&mut self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichEditBox2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox2_Vtbl {
        unsafe extern "system" fn Header<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn Paste<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: IRichEditBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus: PreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus: SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            Paste: Paste::<Impl, IMPL_OFFSET>,
            RemovePaste: RemovePaste::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRichEditBox3_Impl: Sized {
    fn TextCompositionStarted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionEnded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionEnded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn DesiredCandidateWindowAlignment(&mut self) -> ::windows::core::Result<CandidateWindowAlignment>;
    fn SetDesiredCandidateWindowAlignment(&mut self, value: CandidateWindowAlignment) -> ::windows::core::Result<()>;
    fn CandidateWindowBoundsChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidateWindowBoundsChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRichEditBox3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox3_Vtbl {
        unsafe extern "system" fn TextCompositionStarted<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionStarted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionStarted<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionChanged<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionChanged<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionEnded<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionEnded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionEnded<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn DesiredCandidateWindowAlignment<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDesiredCandidateWindowAlignment<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDesiredCandidateWindowAlignment(value).into()
        }
        unsafe extern "system" fn CandidateWindowBoundsChanged<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidateWindowBoundsChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidateWindowBoundsChanged<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCandidateWindowBoundsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanging<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanging<Impl: IRichEditBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox3, BASE_OFFSET>(),
            TextCompositionStarted: TextCompositionStarted::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionStarted: RemoveTextCompositionStarted::<Impl, IMPL_OFFSET>,
            TextCompositionChanged: TextCompositionChanged::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionChanged: RemoveTextCompositionChanged::<Impl, IMPL_OFFSET>,
            TextCompositionEnded: TextCompositionEnded::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionEnded: RemoveTextCompositionEnded::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
            DesiredCandidateWindowAlignment: DesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            SetDesiredCandidateWindowAlignment: SetDesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            CandidateWindowBoundsChanged: CandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            RemoveCandidateWindowBoundsChanged: RemoveCandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            TextChanging: TextChanging::<Impl, IMPL_OFFSET>,
            RemoveTextChanging: RemoveTextChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IRichEditBox4_Impl: Sized {
    fn GetLinguisticAlternativesAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>>;
    fn ClipboardCopyFormat(&mut self) -> ::windows::core::Result<RichEditClipboardFormat>;
    fn SetClipboardCopyFormat(&mut self, value: RichEditClipboardFormat) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IRichEditBox4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox4_Vtbl {
        unsafe extern "system" fn GetLinguisticAlternativesAsync<Impl: IRichEditBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLinguisticAlternativesAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClipboardCopyFormat<Impl: IRichEditBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut RichEditClipboardFormat) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClipboardCopyFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClipboardCopyFormat<Impl: IRichEditBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: RichEditClipboardFormat) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClipboardCopyFormat(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox4, BASE_OFFSET>(),
            GetLinguisticAlternativesAsync: GetLinguisticAlternativesAsync::<Impl, IMPL_OFFSET>,
            ClipboardCopyFormat: ClipboardCopyFormat::<Impl, IMPL_OFFSET>,
            SetClipboardCopyFormat: SetClipboardCopyFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichEditBox5_Impl: Sized {
    fn SelectionHighlightColorWhenNotFocused(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColorWhenNotFocused(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn MaxLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox5";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichEditBox5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox5_Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocused<Impl: IRichEditBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColorWhenNotFocused<Impl: IRichEditBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColorWhenNotFocused(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxLength<Impl: IRichEditBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: IRichEditBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocused: SelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColorWhenNotFocused: SetSelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
            MaxLength: MaxLength::<Impl, IMPL_OFFSET>,
            SetMaxLength: SetMaxLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRichEditBox6_Impl: Sized {
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn CharacterCasing(&mut self) -> ::windows::core::Result<CharacterCasing>;
    fn SetCharacterCasing(&mut self, value: CharacterCasing) -> ::windows::core::Result<()>;
    fn DisabledFormattingAccelerators(&mut self) -> ::windows::core::Result<DisabledFormattingAccelerators>;
    fn SetDisabledFormattingAccelerators(&mut self, value: DisabledFormattingAccelerators) -> ::windows::core::Result<()>;
    fn CopyingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCopyingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CuttingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCuttingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox6";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRichEditBox6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox6_Vtbl {
        unsafe extern "system" fn HorizontalTextAlignment<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn CharacterCasing<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterCasing<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterCasing(value).into()
        }
        unsafe extern "system" fn DisabledFormattingAccelerators<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut DisabledFormattingAccelerators) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledFormattingAccelerators() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledFormattingAccelerators<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: DisabledFormattingAccelerators) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabledFormattingAccelerators(value).into()
        }
        unsafe extern "system" fn CopyingToClipboard<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CopyingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCopyingToClipboard<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCopyingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CuttingToClipboard<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CuttingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCuttingToClipboard<Impl: IRichEditBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCuttingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox6, BASE_OFFSET>(),
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            CharacterCasing: CharacterCasing::<Impl, IMPL_OFFSET>,
            SetCharacterCasing: SetCharacterCasing::<Impl, IMPL_OFFSET>,
            DisabledFormattingAccelerators: DisabledFormattingAccelerators::<Impl, IMPL_OFFSET>,
            SetDisabledFormattingAccelerators: SetDisabledFormattingAccelerators::<Impl, IMPL_OFFSET>,
            CopyingToClipboard: CopyingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCopyingToClipboard: RemoveCopyingToClipboard::<Impl, IMPL_OFFSET>,
            CuttingToClipboard: CuttingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCuttingToClipboard: RemoveCuttingToClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichEditBox7_Impl: Sized {
    fn ContentLinkForegroundColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetContentLinkForegroundColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn ContentLinkBackgroundColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetContentLinkBackgroundColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn ContentLinkProviders(&mut self) -> ::windows::core::Result<super::Documents::ContentLinkProviderCollection>;
    fn SetContentLinkProviders(&mut self, value: &::core::option::Option<super::Documents::ContentLinkProviderCollection>) -> ::windows::core::Result<()>;
    fn HandwritingView(&mut self) -> ::windows::core::Result<HandwritingView>;
    fn SetHandwritingView(&mut self, value: &::core::option::Option<HandwritingView>) -> ::windows::core::Result<()>;
    fn IsHandwritingViewEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHandwritingViewEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ContentLinkChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLinkChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContentLinkInvoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLinkInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox7";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichEditBox7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox7_Vtbl {
        unsafe extern "system" fn ContentLinkForegroundColor<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkForegroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkForegroundColor<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentLinkForegroundColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkBackgroundColor<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkBackgroundColor<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentLinkBackgroundColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkProviders<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkProviders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkProviders<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentLinkProviders(&*(&value as *const <super::Documents::ContentLinkProviderCollection as ::windows::core::Abi>::Abi as *const <super::Documents::ContentLinkProviderCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HandwritingView<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandwritingView<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandwritingView(&*(&value as *const <HandwritingView as ::windows::core::Abi>::Abi as *const <HandwritingView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHandwritingViewEnabled<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHandwritingViewEnabled<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHandwritingViewEnabled(value).into()
        }
        unsafe extern "system" fn ContentLinkChanged<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLinkChanged<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContentLinkChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkInvoked<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLinkInvoked<Impl: IRichEditBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContentLinkInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox7, BASE_OFFSET>(),
            ContentLinkForegroundColor: ContentLinkForegroundColor::<Impl, IMPL_OFFSET>,
            SetContentLinkForegroundColor: SetContentLinkForegroundColor::<Impl, IMPL_OFFSET>,
            ContentLinkBackgroundColor: ContentLinkBackgroundColor::<Impl, IMPL_OFFSET>,
            SetContentLinkBackgroundColor: SetContentLinkBackgroundColor::<Impl, IMPL_OFFSET>,
            ContentLinkProviders: ContentLinkProviders::<Impl, IMPL_OFFSET>,
            SetContentLinkProviders: SetContentLinkProviders::<Impl, IMPL_OFFSET>,
            HandwritingView: HandwritingView::<Impl, IMPL_OFFSET>,
            SetHandwritingView: SetHandwritingView::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabled: IsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
            SetIsHandwritingViewEnabled: SetIsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
            ContentLinkChanged: ContentLinkChanged::<Impl, IMPL_OFFSET>,
            RemoveContentLinkChanged: RemoveContentLinkChanged::<Impl, IMPL_OFFSET>,
            ContentLinkInvoked: ContentLinkInvoked::<Impl, IMPL_OFFSET>,
            RemoveContentLinkInvoked: RemoveContentLinkInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IRichEditBox8_Impl: Sized {
    fn TextDocument(&mut self) -> ::windows::core::Result<super::super::Text::RichEditTextDocument>;
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn ProofingMenuFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectionChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichEditBox8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox8";
}
#[cfg(all(feature = "Foundation", feature = "UI_Text", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IRichEditBox8_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBox8_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBox8_Vtbl {
        unsafe extern "system" fn TextDocument<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDocument() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ProofingMenuFlyout<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanging<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanging<Impl: IRichEditBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBox8, BASE_OFFSET>(),
            TextDocument: TextDocument::<Impl, IMPL_OFFSET>,
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyout: ProofingMenuFlyout::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            SelectionChanging: SelectionChanging::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanging: RemoveSelectionChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBox8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RichEditBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRichEditBoxFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxSelectionChangingEventArgs_Impl: Sized {
    fn SelectionStart(&mut self) -> ::windows::core::Result<i32>;
    fn SelectionLength(&mut self) -> ::windows::core::Result<i32>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxSelectionChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxSelectionChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxSelectionChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxSelectionChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxSelectionChangingEventArgs_Vtbl {
        unsafe extern "system" fn SelectionStart<Impl: IRichEditBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionLength<Impl: IRichEditBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IRichEditBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IRichEditBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxSelectionChangingEventArgs, BASE_OFFSET>(),
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionLength: SelectionLength::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxSelectionChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics_Impl: Sized {
    fn IsReadOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AcceptsReturnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSpellCheckEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextPredictionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics_Vtbl {
        unsafe extern "system" fn IsReadOnlyProperty<Impl: IRichEditBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptsReturnProperty<Impl: IRichEditBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: IRichEditBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: IRichEditBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSpellCheckEnabledProperty<Impl: IRichEditBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextPredictionEnabledProperty<Impl: IRichEditBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: IRichEditBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics, BASE_OFFSET>(),
            IsReadOnlyProperty: IsReadOnlyProperty::<Impl, IMPL_OFFSET>,
            AcceptsReturnProperty: AcceptsReturnProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabledProperty: IsSpellCheckEnabledProperty::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabledProperty: IsTextPredictionEnabledProperty::<Impl, IMPL_OFFSET>,
            InputScopeProperty: InputScopeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics2_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics2_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IRichEditBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IRichEditBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IRichEditBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IRichEditBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: IRichEditBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: IRichEditBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocusProperty: PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics3_Impl: Sized {
    fn DesiredCandidateWindowAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics3_Vtbl {
        unsafe extern "system" fn DesiredCandidateWindowAlignmentProperty<Impl: IRichEditBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IRichEditBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics3, BASE_OFFSET>(),
            DesiredCandidateWindowAlignmentProperty: DesiredCandidateWindowAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics4_Impl: Sized {
    fn ClipboardCopyFormatProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics4_Vtbl {
        unsafe extern "system" fn ClipboardCopyFormatProperty<Impl: IRichEditBoxStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClipboardCopyFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics4, BASE_OFFSET>(),
            ClipboardCopyFormatProperty: ClipboardCopyFormatProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics5_Impl: Sized {
    fn SelectionHighlightColorWhenNotFocusedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics5_Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocusedProperty<Impl: IRichEditBoxStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocusedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: IRichEditBoxStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocusedProperty: SelectionHighlightColorWhenNotFocusedProperty::<Impl, IMPL_OFFSET>,
            MaxLengthProperty: MaxLengthProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics6_Impl: Sized {
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterCasingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisabledFormattingAcceleratorsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics6_Vtbl {
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: IRichEditBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterCasingProperty<Impl: IRichEditBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisabledFormattingAcceleratorsProperty<Impl: IRichEditBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisabledFormattingAcceleratorsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics6, BASE_OFFSET>(),
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
            CharacterCasingProperty: CharacterCasingProperty::<Impl, IMPL_OFFSET>,
            DisabledFormattingAcceleratorsProperty: DisabledFormattingAcceleratorsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics7_Impl: Sized {
    fn ContentLinkForegroundColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentLinkBackgroundColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentLinkProvidersProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HandwritingViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHandwritingViewEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics7_Vtbl {
        unsafe extern "system" fn ContentLinkForegroundColorProperty<Impl: IRichEditBoxStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkForegroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkBackgroundColorProperty<Impl: IRichEditBoxStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkBackgroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkProvidersProperty<Impl: IRichEditBoxStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLinkProvidersProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HandwritingViewProperty<Impl: IRichEditBoxStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHandwritingViewEnabledProperty<Impl: IRichEditBoxStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics7, BASE_OFFSET>(),
            ContentLinkForegroundColorProperty: ContentLinkForegroundColorProperty::<Impl, IMPL_OFFSET>,
            ContentLinkBackgroundColorProperty: ContentLinkBackgroundColorProperty::<Impl, IMPL_OFFSET>,
            ContentLinkProvidersProperty: ContentLinkProvidersProperty::<Impl, IMPL_OFFSET>,
            HandwritingViewProperty: HandwritingViewProperty::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabledProperty: IsHandwritingViewEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics8_Impl: Sized {
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProofingMenuFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics8";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics8_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxStatics8_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxStatics8_Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IRichEditBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProofingMenuFlyoutProperty<Impl: IRichEditBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IRichEditBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxStatics8, BASE_OFFSET>(),
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyoutProperty: ProofingMenuFlyoutProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxStatics8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxTextChangingEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxTextChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxTextChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxTextChangingEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxTextChangingEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxTextChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxTextChangingEventArgs2_Impl: Sized {
    fn IsContentChanging(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxTextChangingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxTextChangingEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichEditBoxTextChangingEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichEditBoxTextChangingEventArgs2_Vtbl {
        unsafe extern "system" fn IsContentChanging<Impl: IRichEditBoxTextChangingEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichEditBoxTextChangingEventArgs2, BASE_OFFSET>(),
            IsContentChanging: IsContentChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichEditBoxTextChangingEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichTextBlock_Impl: Sized {
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn TextTrimming(&mut self) -> ::windows::core::Result<super::TextTrimming>;
    fn SetTextTrimming(&mut self, value: super::TextTrimming) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn Blocks(&mut self) -> ::windows::core::Result<super::Documents::BlockCollection>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn LineHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&mut self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&mut self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn OverflowContentTarget(&mut self) -> ::windows::core::Result<RichTextBlockOverflow>;
    fn SetOverflowContentTarget(&mut self, value: &::core::option::Option<RichTextBlockOverflow>) -> ::windows::core::Result<()>;
    fn IsTextSelectionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextSelectionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HasOverflowContent(&mut self) -> ::windows::core::Result<bool>;
    fn SelectedText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ContentStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn Select(&mut self, start: &::core::option::Option<super::Documents::TextPointer>, end: &::core::option::Option<super::Documents::TextPointer>) -> ::windows::core::Result<()>;
    fn GetPositionFromPoint(&mut self, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
    fn TextIndent(&mut self) -> ::windows::core::Result<f64>;
    fn SetTextIndent(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichTextBlock_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock_Vtbl {
        unsafe extern "system" fn FontSize<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn TextTrimming<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimming() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextTrimming<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextTrimming(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn Blocks<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Blocks() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Padding<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineHeight<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn OverflowContentTarget<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowContentTarget<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowContentTarget(&*(&value as *const <RichTextBlockOverflow as ::windows::core::Abi>::Abi as *const <RichTextBlockOverflow as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTextSelectionEnabled<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSelectionEnabled<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextSelectionEnabled(value).into()
        }
        unsafe extern "system" fn HasOverflowContent<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedText<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionStart<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionEnd<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn Select<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: ::windows::core::RawPtr, end: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Select(&*(&start as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType), &*(&end as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetPositionFromPoint<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::super::Foundation::Point, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPositionFromPoint(&*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextIndent<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextIndent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextIndent<Impl: IRichTextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextIndent(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock, BASE_OFFSET>(),
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            TextTrimming: TextTrimming::<Impl, IMPL_OFFSET>,
            SetTextTrimming: SetTextTrimming::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            Blocks: Blocks::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            LineHeight: LineHeight::<Impl, IMPL_OFFSET>,
            SetLineHeight: SetLineHeight::<Impl, IMPL_OFFSET>,
            LineStackingStrategy: LineStackingStrategy::<Impl, IMPL_OFFSET>,
            SetLineStackingStrategy: SetLineStackingStrategy::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            OverflowContentTarget: OverflowContentTarget::<Impl, IMPL_OFFSET>,
            SetOverflowContentTarget: SetOverflowContentTarget::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabled: IsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextSelectionEnabled: SetIsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            HasOverflowContent: HasOverflowContent::<Impl, IMPL_OFFSET>,
            SelectedText: SelectedText::<Impl, IMPL_OFFSET>,
            ContentStart: ContentStart::<Impl, IMPL_OFFSET>,
            ContentEnd: ContentEnd::<Impl, IMPL_OFFSET>,
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionEnd: SelectionEnd::<Impl, IMPL_OFFSET>,
            BaselineOffset: BaselineOffset::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            Select: Select::<Impl, IMPL_OFFSET>,
            GetPositionFromPoint: GetPositionFromPoint::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
            TextIndent: TextIndent::<Impl, IMPL_OFFSET>,
            SetTextIndent: SetTextIndent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IRichTextBlock2_Impl: Sized {
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TextLineBounds(&mut self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&mut self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn OpticalMarginAlignment(&mut self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&mut self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IRichTextBlock2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock2_Vtbl {
        unsafe extern "system" fn MaxLines<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OpticalMarginAlignment<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IRichTextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock2, BASE_OFFSET>(),
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
            TextLineBounds: TextLineBounds::<Impl, IMPL_OFFSET>,
            SetTextLineBounds: SetTextLineBounds::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignment: OpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            SetOpticalMarginAlignment: SetOpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlock3_Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlock3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock3_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IRichTextBlock3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IRichTextBlock3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock3, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
pub trait IRichTextBlock4_Impl: Sized {
    fn TextDecorations(&mut self) -> ::windows::core::Result<super::super::Text::TextDecorations>;
    fn SetTextDecorations(&mut self, value: super::super::Text::TextDecorations) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock4";
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl IRichTextBlock4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock4_Vtbl {
        unsafe extern "system" fn TextDecorations<Impl: IRichTextBlock4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorations() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextDecorations<Impl: IRichTextBlock4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextDecorations(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock4, BASE_OFFSET>(),
            TextDecorations: TextDecorations::<Impl, IMPL_OFFSET>,
            SetTextDecorations: SetTextDecorations::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait IRichTextBlock5_Impl: Sized {
    fn IsTextTrimmed(&mut self) -> ::windows::core::Result<bool>;
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextHighlighters(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Documents::TextHighlighter>>;
    fn IsTextTrimmedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock5";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl IRichTextBlock5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock5_Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: IRichTextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignment<Impl: IRichTextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: IRichTextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn TextHighlighters<Impl: IRichTextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextHighlighters() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: IRichTextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: IRichTextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock5, BASE_OFFSET>(),
            IsTextTrimmed: IsTextTrimmed::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            TextHighlighters: TextHighlighters::<Impl, IMPL_OFFSET>,
            IsTextTrimmedChanged: IsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsTextTrimmedChanged: RemoveIsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IRichTextBlock6_Impl: Sized {
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlock6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock6";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IRichTextBlock6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlock6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlock6_Vtbl {
        unsafe extern "system" fn SelectionFlyout<Impl: IRichTextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IRichTextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: IRichTextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlock6, BASE_OFFSET>(),
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            CopySelectionToClipboard: CopySelectionToClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlock6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait IRichTextBlockOverflow_Impl: Sized {
    fn OverflowContentTarget(&mut self) -> ::windows::core::Result<RichTextBlockOverflow>;
    fn SetOverflowContentTarget(&mut self, value: &::core::option::Option<RichTextBlockOverflow>) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn ContentSource(&mut self) -> ::windows::core::Result<RichTextBlock>;
    fn HasOverflowContent(&mut self) -> ::windows::core::Result<bool>;
    fn ContentStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&mut self) -> ::windows::core::Result<f64>;
    fn GetPositionFromPoint(&mut self, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl IRichTextBlockOverflow_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflow_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflow_Vtbl {
        unsafe extern "system" fn OverflowContentTarget<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowContentTarget<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverflowContentTarget(&*(&value as *const <RichTextBlockOverflow as ::windows::core::Abi>::Abi as *const <RichTextBlockOverflow as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentSource<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContent<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPositionFromPoint<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::super::Foundation::Point, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPositionFromPoint(&*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IRichTextBlockOverflow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflow, BASE_OFFSET>(),
            OverflowContentTarget: OverflowContentTarget::<Impl, IMPL_OFFSET>,
            SetOverflowContentTarget: SetOverflowContentTarget::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            ContentSource: ContentSource::<Impl, IMPL_OFFSET>,
            HasOverflowContent: HasOverflowContent::<Impl, IMPL_OFFSET>,
            ContentStart: ContentStart::<Impl, IMPL_OFFSET>,
            ContentEnd: ContentEnd::<Impl, IMPL_OFFSET>,
            BaselineOffset: BaselineOffset::<Impl, IMPL_OFFSET>,
            GetPositionFromPoint: GetPositionFromPoint::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflow as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflow2_Impl: Sized {
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflow2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflow2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflow2_Vtbl {
        unsafe extern "system" fn MaxLines<Impl: IRichTextBlockOverflow2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IRichTextBlockOverflow2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflow2, BASE_OFFSET>(),
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflow2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IRichTextBlockOverflow3_Impl: Sized {
    fn IsTextTrimmed(&mut self) -> ::windows::core::Result<bool>;
    fn IsTextTrimmedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IRichTextBlockOverflow3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflow3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflow3_Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: IRichTextBlockOverflow3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: IRichTextBlockOverflow3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: IRichTextBlockOverflow3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflow3, BASE_OFFSET>(),
            IsTextTrimmed: IsTextTrimmed::<Impl, IMPL_OFFSET>,
            IsTextTrimmedChanged: IsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsTextTrimmedChanged: RemoveIsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflow3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStatics_Impl: Sized {
    fn OverflowContentTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasOverflowContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflowStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflowStatics_Vtbl {
        unsafe extern "system" fn OverflowContentTargetProperty<Impl: IRichTextBlockOverflowStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRichTextBlockOverflowStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContentProperty<Impl: IRichTextBlockOverflowStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflowStatics, BASE_OFFSET>(),
            OverflowContentTargetProperty: OverflowContentTargetProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            HasOverflowContentProperty: HasOverflowContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflowStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStatics2_Impl: Sized {
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflowStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflowStatics2_Vtbl {
        unsafe extern "system" fn MaxLinesProperty<Impl: IRichTextBlockOverflowStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflowStatics2, BASE_OFFSET>(),
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflowStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStatics3_Impl: Sized {
    fn IsTextTrimmedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockOverflowStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockOverflowStatics3_Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: IRichTextBlockOverflowStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockOverflowStatics3, BASE_OFFSET>(),
            IsTextTrimmedProperty: IsTextTrimmedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockOverflowStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics_Impl: Sized {
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextTrimmingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowContentTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSelectionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasOverflowContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextIndentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics_Vtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextTrimmingProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimmingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowContentTargetProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverflowContentTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSelectionEnabledProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContentProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasOverflowContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedTextProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextIndentProperty<Impl: IRichTextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextIndentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics, BASE_OFFSET>(),
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            TextTrimmingProperty: TextTrimmingProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            LineHeightProperty: LineHeightProperty::<Impl, IMPL_OFFSET>,
            LineStackingStrategyProperty: LineStackingStrategyProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            OverflowContentTargetProperty: OverflowContentTargetProperty::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabledProperty: IsTextSelectionEnabledProperty::<Impl, IMPL_OFFSET>,
            HasOverflowContentProperty: HasOverflowContentProperty::<Impl, IMPL_OFFSET>,
            SelectedTextProperty: SelectedTextProperty::<Impl, IMPL_OFFSET>,
            TextIndentProperty: TextIndentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics2_Impl: Sized {
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpticalMarginAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics2_Vtbl {
        unsafe extern "system" fn MaxLinesProperty<Impl: IRichTextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: IRichTextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IRichTextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: IRichTextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: IRichTextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IRichTextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics2, BASE_OFFSET>(),
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
            TextLineBoundsProperty: TextLineBoundsProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignmentProperty: OpticalMarginAlignmentProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics3_Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics3_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IRichTextBlockStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics3, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics4_Impl: Sized {
    fn TextDecorationsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics4_Vtbl {
        unsafe extern "system" fn TextDecorationsProperty<Impl: IRichTextBlockStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorationsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics4, BASE_OFFSET>(),
            TextDecorationsProperty: TextDecorationsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics5_Impl: Sized {
    fn IsTextTrimmedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics5_Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: IRichTextBlockStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: IRichTextBlockStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics5, BASE_OFFSET>(),
            IsTextTrimmedProperty: IsTextTrimmedProperty::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics6_Impl: Sized {
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRichTextBlockStatics6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRichTextBlockStatics6_Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IRichTextBlockStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRichTextBlockStatics6, BASE_OFFSET>(),
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRichTextBlockStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRowDefinition_Impl: Sized {
    fn Height(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetHeight(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn MaxHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMaxHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MinHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ActualHeight(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRowDefinition {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRowDefinition";
}
#[cfg(feature = "implement_exclusive")]
impl IRowDefinition_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRowDefinition_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRowDefinition_Vtbl {
        unsafe extern "system" fn Height<Impl: IRowDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Height() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeight<Impl: IRowDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeight(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxHeight<Impl: IRowDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHeight<Impl: IRowDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxHeight(value).into()
        }
        unsafe extern "system" fn MinHeight<Impl: IRowDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinHeight<Impl: IRowDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinHeight(value).into()
        }
        unsafe extern "system" fn ActualHeight<Impl: IRowDefinition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ActualHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRowDefinition, BASE_OFFSET>(),
            Height: Height::<Impl, IMPL_OFFSET>,
            SetHeight: SetHeight::<Impl, IMPL_OFFSET>,
            MaxHeight: MaxHeight::<Impl, IMPL_OFFSET>,
            SetMaxHeight: SetMaxHeight::<Impl, IMPL_OFFSET>,
            MinHeight: MinHeight::<Impl, IMPL_OFFSET>,
            SetMinHeight: SetMinHeight::<Impl, IMPL_OFFSET>,
            ActualHeight: ActualHeight::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRowDefinition as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRowDefinitionStatics_Impl: Sized {
    fn HeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRowDefinitionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRowDefinitionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRowDefinitionStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRowDefinitionStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRowDefinitionStatics_Vtbl {
        unsafe extern "system" fn HeightProperty<Impl: IRowDefinitionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHeightProperty<Impl: IRowDefinitionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinHeightProperty<Impl: IRowDefinitionStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IRowDefinitionStatics, BASE_OFFSET>(),
            HeightProperty: HeightProperty::<Impl, IMPL_OFFSET>,
            MaxHeightProperty: MaxHeightProperty::<Impl, IMPL_OFFSET>,
            MinHeightProperty: MinHeightProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRowDefinitionStatics as ::windows::core::Interface>::IID
    }
}
pub trait IScrollAnchorProvider_Impl: Sized {
    fn CurrentAnchor(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn RegisterAnchorCandidate(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn UnregisterAnchorCandidate(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IScrollAnchorProvider {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollAnchorProvider";
}
impl IScrollAnchorProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollAnchorProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollAnchorProvider_Vtbl {
        unsafe extern "system" fn CurrentAnchor<Impl: IScrollAnchorProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentAnchor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterAnchorCandidate<Impl: IScrollAnchorProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterAnchorCandidate(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnregisterAnchorCandidate<Impl: IScrollAnchorProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterAnchorCandidate(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollAnchorProvider, BASE_OFFSET>(),
            CurrentAnchor: CurrentAnchor::<Impl, IMPL_OFFSET>,
            RegisterAnchorCandidate: RegisterAnchorCandidate::<Impl, IMPL_OFFSET>,
            UnregisterAnchorCandidate: UnregisterAnchorCandidate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollAnchorProvider as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollContentPresenter_Impl: Sized {
    fn CanVerticallyScroll(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanVerticallyScroll(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanHorizontallyScroll(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanHorizontallyScroll(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ExtentWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ExtentHeight(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportHeight(&mut self) -> ::windows::core::Result<f64>;
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ScrollOwner(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetScrollOwner(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn LineUp(&mut self) -> ::windows::core::Result<()>;
    fn LineDown(&mut self) -> ::windows::core::Result<()>;
    fn LineLeft(&mut self) -> ::windows::core::Result<()>;
    fn LineRight(&mut self) -> ::windows::core::Result<()>;
    fn PageUp(&mut self) -> ::windows::core::Result<()>;
    fn PageDown(&mut self) -> ::windows::core::Result<()>;
    fn PageLeft(&mut self) -> ::windows::core::Result<()>;
    fn PageRight(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelUp(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelDown(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelLeft(&mut self) -> ::windows::core::Result<()>;
    fn MouseWheelRight(&mut self) -> ::windows::core::Result<()>;
    fn SetHorizontalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn SetVerticalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn MakeVisible(&mut self, visual: &::core::option::Option<super::UIElement>, rectangle: &super::super::super::Foundation::Rect) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollContentPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenter";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollContentPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollContentPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollContentPresenter_Vtbl {
        unsafe extern "system" fn CanVerticallyScroll<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanVerticallyScroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanVerticallyScroll<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanVerticallyScroll(value).into()
        }
        unsafe extern "system" fn CanHorizontallyScroll<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanHorizontallyScroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanHorizontallyScroll<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanHorizontallyScroll(value).into()
        }
        unsafe extern "system" fn ExtentWidth<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeight<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidth<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeight<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollOwner<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollOwner() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetScrollOwner<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetScrollOwner(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineUp<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineUp().into()
        }
        unsafe extern "system" fn LineDown<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineDown().into()
        }
        unsafe extern "system" fn LineLeft<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineLeft().into()
        }
        unsafe extern "system" fn LineRight<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LineRight().into()
        }
        unsafe extern "system" fn PageUp<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageUp().into()
        }
        unsafe extern "system" fn PageDown<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageDown().into()
        }
        unsafe extern "system" fn PageLeft<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageLeft().into()
        }
        unsafe extern "system" fn PageRight<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PageRight().into()
        }
        unsafe extern "system" fn MouseWheelUp<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelUp().into()
        }
        unsafe extern "system" fn MouseWheelDown<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelDown().into()
        }
        unsafe extern "system" fn MouseWheelLeft<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelLeft().into()
        }
        unsafe extern "system" fn MouseWheelRight<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseWheelRight().into()
        }
        unsafe extern "system" fn SetHorizontalOffset<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalOffset(offset).into()
        }
        unsafe extern "system" fn SetVerticalOffset<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalOffset(offset).into()
        }
        unsafe extern "system" fn MakeVisible<Impl: IScrollContentPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, visual: ::windows::core::RawPtr, rectangle: super::super::super::Foundation::Rect, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MakeVisible(&*(&visual as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&rectangle as *const <super::super::super::Foundation::Rect as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Rect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollContentPresenter, BASE_OFFSET>(),
            CanVerticallyScroll: CanVerticallyScroll::<Impl, IMPL_OFFSET>,
            SetCanVerticallyScroll: SetCanVerticallyScroll::<Impl, IMPL_OFFSET>,
            CanHorizontallyScroll: CanHorizontallyScroll::<Impl, IMPL_OFFSET>,
            SetCanHorizontallyScroll: SetCanHorizontallyScroll::<Impl, IMPL_OFFSET>,
            ExtentWidth: ExtentWidth::<Impl, IMPL_OFFSET>,
            ExtentHeight: ExtentHeight::<Impl, IMPL_OFFSET>,
            ViewportWidth: ViewportWidth::<Impl, IMPL_OFFSET>,
            ViewportHeight: ViewportHeight::<Impl, IMPL_OFFSET>,
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            ScrollOwner: ScrollOwner::<Impl, IMPL_OFFSET>,
            SetScrollOwner: SetScrollOwner::<Impl, IMPL_OFFSET>,
            LineUp: LineUp::<Impl, IMPL_OFFSET>,
            LineDown: LineDown::<Impl, IMPL_OFFSET>,
            LineLeft: LineLeft::<Impl, IMPL_OFFSET>,
            LineRight: LineRight::<Impl, IMPL_OFFSET>,
            PageUp: PageUp::<Impl, IMPL_OFFSET>,
            PageDown: PageDown::<Impl, IMPL_OFFSET>,
            PageLeft: PageLeft::<Impl, IMPL_OFFSET>,
            PageRight: PageRight::<Impl, IMPL_OFFSET>,
            MouseWheelUp: MouseWheelUp::<Impl, IMPL_OFFSET>,
            MouseWheelDown: MouseWheelDown::<Impl, IMPL_OFFSET>,
            MouseWheelLeft: MouseWheelLeft::<Impl, IMPL_OFFSET>,
            MouseWheelRight: MouseWheelRight::<Impl, IMPL_OFFSET>,
            SetHorizontalOffset: SetHorizontalOffset::<Impl, IMPL_OFFSET>,
            SetVerticalOffset: SetVerticalOffset::<Impl, IMPL_OFFSET>,
            MakeVisible: MakeVisible::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollContentPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollContentPresenter2_Impl: Sized {
    fn CanContentRenderOutsideBounds(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SizesContentToTemplatedParent(&mut self) -> ::windows::core::Result<bool>;
    fn SetSizesContentToTemplatedParent(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollContentPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollContentPresenter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollContentPresenter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollContentPresenter2_Vtbl {
        unsafe extern "system" fn CanContentRenderOutsideBounds<Impl: IScrollContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(value).into()
        }
        unsafe extern "system" fn SizesContentToTemplatedParent<Impl: IScrollContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SizesContentToTemplatedParent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSizesContentToTemplatedParent<Impl: IScrollContentPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSizesContentToTemplatedParent(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollContentPresenter2, BASE_OFFSET>(),
            CanContentRenderOutsideBounds: CanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SetCanContentRenderOutsideBounds: SetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SizesContentToTemplatedParent: SizesContentToTemplatedParent::<Impl, IMPL_OFFSET>,
            SetSizesContentToTemplatedParent: SetSizesContentToTemplatedParent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollContentPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollContentPresenterStatics2_Impl: Sized {
    fn CanContentRenderOutsideBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SizesContentToTemplatedParentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollContentPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollContentPresenterStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollContentPresenterStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollContentPresenterStatics2_Vtbl {
        unsafe extern "system" fn CanContentRenderOutsideBoundsProperty<Impl: IScrollContentPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SizesContentToTemplatedParentProperty<Impl: IScrollContentPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SizesContentToTemplatedParentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollContentPresenterStatics2, BASE_OFFSET>(),
            CanContentRenderOutsideBoundsProperty: CanContentRenderOutsideBoundsProperty::<Impl, IMPL_OFFSET>,
            SizesContentToTemplatedParentProperty: SizesContentToTemplatedParentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollContentPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IScrollViewer_Impl: Sized {
    fn HorizontalScrollBarVisibility(&mut self) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetHorizontalScrollBarVisibility(&mut self, value: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn VerticalScrollBarVisibility(&mut self) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetVerticalScrollBarVisibility(&mut self, value: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn IsHorizontalRailEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalRailEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalRailEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalRailEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsHorizontalScrollChainingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalScrollChainingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalScrollChainingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalScrollChainingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomChainingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomChainingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsScrollInertiaEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsScrollInertiaEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomInertiaEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomInertiaEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HorizontalScrollMode(&mut self) -> ::windows::core::Result<ScrollMode>;
    fn SetHorizontalScrollMode(&mut self, value: ScrollMode) -> ::windows::core::Result<()>;
    fn VerticalScrollMode(&mut self) -> ::windows::core::Result<ScrollMode>;
    fn SetVerticalScrollMode(&mut self, value: ScrollMode) -> ::windows::core::Result<()>;
    fn ZoomMode(&mut self) -> ::windows::core::Result<ZoomMode>;
    fn SetZoomMode(&mut self, value: ZoomMode) -> ::windows::core::Result<()>;
    fn HorizontalSnapPointsAlignment(&mut self) -> ::windows::core::Result<Primitives::SnapPointsAlignment>;
    fn SetHorizontalSnapPointsAlignment(&mut self, value: Primitives::SnapPointsAlignment) -> ::windows::core::Result<()>;
    fn VerticalSnapPointsAlignment(&mut self) -> ::windows::core::Result<Primitives::SnapPointsAlignment>;
    fn SetVerticalSnapPointsAlignment(&mut self, value: Primitives::SnapPointsAlignment) -> ::windows::core::Result<()>;
    fn HorizontalSnapPointsType(&mut self) -> ::windows::core::Result<SnapPointsType>;
    fn SetHorizontalSnapPointsType(&mut self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn VerticalSnapPointsType(&mut self) -> ::windows::core::Result<SnapPointsType>;
    fn SetVerticalSnapPointsType(&mut self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn ZoomSnapPointsType(&mut self) -> ::windows::core::Result<SnapPointsType>;
    fn SetZoomSnapPointsType(&mut self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ScrollableWidth(&mut self) -> ::windows::core::Result<f64>;
    fn ComputedHorizontalScrollBarVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn ExtentWidth(&mut self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ViewportHeight(&mut self) -> ::windows::core::Result<f64>;
    fn ScrollableHeight(&mut self) -> ::windows::core::Result<f64>;
    fn ComputedVerticalScrollBarVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn ExtentHeight(&mut self) -> ::windows::core::Result<f64>;
    fn MinZoomFactor(&mut self) -> ::windows::core::Result<f32>;
    fn SetMinZoomFactor(&mut self, value: f32) -> ::windows::core::Result<()>;
    fn MaxZoomFactor(&mut self) -> ::windows::core::Result<f32>;
    fn SetMaxZoomFactor(&mut self, value: f32) -> ::windows::core::Result<()>;
    fn ZoomFactor(&mut self) -> ::windows::core::Result<f32>;
    fn ZoomSnapPoints(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<f32>>;
    fn ViewChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollToHorizontalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn ScrollToVerticalOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn ZoomToFactor(&mut self, factor: f32) -> ::windows::core::Result<()>;
    fn InvalidateScrollInfo(&mut self) -> ::windows::core::Result<()>;
    fn IsDeferredScrollingEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDeferredScrollingEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn BringIntoViewOnFocusChange(&mut self) -> ::windows::core::Result<bool>;
    fn SetBringIntoViewOnFocusChange(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IScrollViewer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewer_Vtbl {
        unsafe extern "system" fn HorizontalScrollBarVisibility<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollBarVisibility<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollBarVisibility(value).into()
        }
        unsafe extern "system" fn VerticalScrollBarVisibility<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollBarVisibility<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollBarVisibility(value).into()
        }
        unsafe extern "system" fn IsHorizontalRailEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalRailEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalRailEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalRailEnabled(value).into()
        }
        unsafe extern "system" fn IsVerticalRailEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalRailEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalRailEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalRailEnabled(value).into()
        }
        unsafe extern "system" fn IsHorizontalScrollChainingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalScrollChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalScrollChainingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalScrollChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsVerticalScrollChainingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalScrollChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalScrollChainingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalScrollChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomChainingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomChainingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsScrollInertiaEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsScrollInertiaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsScrollInertiaEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsScrollInertiaEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomInertiaEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomInertiaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomInertiaEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomInertiaEnabled(value).into()
        }
        unsafe extern "system" fn HorizontalScrollMode<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollMode<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollMode(value).into()
        }
        unsafe extern "system" fn VerticalScrollMode<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollMode<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollMode(value).into()
        }
        unsafe extern "system" fn ZoomMode<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomMode<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomMode(value).into()
        }
        unsafe extern "system" fn HorizontalSnapPointsAlignment<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSnapPointsAlignment<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSnapPointsAlignment(value).into()
        }
        unsafe extern "system" fn VerticalSnapPointsAlignment<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSnapPointsAlignment<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSnapPointsAlignment(value).into()
        }
        unsafe extern "system" fn HorizontalSnapPointsType<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSnapPointsType<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalSnapPointsType(value).into()
        }
        unsafe extern "system" fn VerticalSnapPointsType<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSnapPointsType<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalSnapPointsType(value).into()
        }
        unsafe extern "system" fn ZoomSnapPointsType<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomSnapPointsType<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomSnapPointsType(value).into()
        }
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidth<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableWidth<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedHorizontalScrollBarVisibility<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedHorizontalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentWidth<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeight<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableHeight<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedVerticalScrollBarVisibility<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedVerticalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeight<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinZoomFactor<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinZoomFactor<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinZoomFactor(value).into()
        }
        unsafe extern "system" fn MaxZoomFactor<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxZoomFactor<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxZoomFactor(value).into()
        }
        unsafe extern "system" fn ZoomFactor<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPoints<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPoints() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewChanged<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChanged<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollToHorizontalOffset<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollToHorizontalOffset(offset).into()
        }
        unsafe extern "system" fn ScrollToVerticalOffset<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScrollToVerticalOffset(offset).into()
        }
        unsafe extern "system" fn ZoomToFactor<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, factor: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ZoomToFactor(factor).into()
        }
        unsafe extern "system" fn InvalidateScrollInfo<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InvalidateScrollInfo().into()
        }
        unsafe extern "system" fn IsDeferredScrollingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDeferredScrollingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDeferredScrollingEnabled<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDeferredScrollingEnabled(value).into()
        }
        unsafe extern "system" fn BringIntoViewOnFocusChange<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BringIntoViewOnFocusChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBringIntoViewOnFocusChange<Impl: IScrollViewer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBringIntoViewOnFocusChange(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer, BASE_OFFSET>(),
            HorizontalScrollBarVisibility: HorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollBarVisibility: SetHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            VerticalScrollBarVisibility: VerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetVerticalScrollBarVisibility: SetVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            IsHorizontalRailEnabled: IsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalRailEnabled: SetIsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalRailEnabled: IsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalRailEnabled: SetIsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            IsHorizontalScrollChainingEnabled: IsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalScrollChainingEnabled: SetIsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalScrollChainingEnabled: IsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalScrollChainingEnabled: SetIsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsZoomChainingEnabled: IsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomChainingEnabled: SetIsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            IsScrollInertiaEnabled: IsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsScrollInertiaEnabled: SetIsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            IsZoomInertiaEnabled: IsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomInertiaEnabled: SetIsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            HorizontalScrollMode: HorizontalScrollMode::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollMode: SetHorizontalScrollMode::<Impl, IMPL_OFFSET>,
            VerticalScrollMode: VerticalScrollMode::<Impl, IMPL_OFFSET>,
            SetVerticalScrollMode: SetVerticalScrollMode::<Impl, IMPL_OFFSET>,
            ZoomMode: ZoomMode::<Impl, IMPL_OFFSET>,
            SetZoomMode: SetZoomMode::<Impl, IMPL_OFFSET>,
            HorizontalSnapPointsAlignment: HorizontalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalSnapPointsAlignment: SetHorizontalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsAlignment: VerticalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalSnapPointsAlignment: SetVerticalSnapPointsAlignment::<Impl, IMPL_OFFSET>,
            HorizontalSnapPointsType: HorizontalSnapPointsType::<Impl, IMPL_OFFSET>,
            SetHorizontalSnapPointsType: SetHorizontalSnapPointsType::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsType: VerticalSnapPointsType::<Impl, IMPL_OFFSET>,
            SetVerticalSnapPointsType: SetVerticalSnapPointsType::<Impl, IMPL_OFFSET>,
            ZoomSnapPointsType: ZoomSnapPointsType::<Impl, IMPL_OFFSET>,
            SetZoomSnapPointsType: SetZoomSnapPointsType::<Impl, IMPL_OFFSET>,
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            ViewportWidth: ViewportWidth::<Impl, IMPL_OFFSET>,
            ScrollableWidth: ScrollableWidth::<Impl, IMPL_OFFSET>,
            ComputedHorizontalScrollBarVisibility: ComputedHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            ExtentWidth: ExtentWidth::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            ViewportHeight: ViewportHeight::<Impl, IMPL_OFFSET>,
            ScrollableHeight: ScrollableHeight::<Impl, IMPL_OFFSET>,
            ComputedVerticalScrollBarVisibility: ComputedVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            ExtentHeight: ExtentHeight::<Impl, IMPL_OFFSET>,
            MinZoomFactor: MinZoomFactor::<Impl, IMPL_OFFSET>,
            SetMinZoomFactor: SetMinZoomFactor::<Impl, IMPL_OFFSET>,
            MaxZoomFactor: MaxZoomFactor::<Impl, IMPL_OFFSET>,
            SetMaxZoomFactor: SetMaxZoomFactor::<Impl, IMPL_OFFSET>,
            ZoomFactor: ZoomFactor::<Impl, IMPL_OFFSET>,
            ZoomSnapPoints: ZoomSnapPoints::<Impl, IMPL_OFFSET>,
            ViewChanged: ViewChanged::<Impl, IMPL_OFFSET>,
            RemoveViewChanged: RemoveViewChanged::<Impl, IMPL_OFFSET>,
            ScrollToHorizontalOffset: ScrollToHorizontalOffset::<Impl, IMPL_OFFSET>,
            ScrollToVerticalOffset: ScrollToVerticalOffset::<Impl, IMPL_OFFSET>,
            ZoomToFactor: ZoomToFactor::<Impl, IMPL_OFFSET>,
            InvalidateScrollInfo: InvalidateScrollInfo::<Impl, IMPL_OFFSET>,
            IsDeferredScrollingEnabled: IsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            SetIsDeferredScrollingEnabled: SetIsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            BringIntoViewOnFocusChange: BringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
            SetBringIntoViewOnFocusChange: SetBringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollViewer2_Impl: Sized {
    fn TopLeftHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetTopLeftHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn LeftHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetLeftHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn TopHeader(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetTopHeader(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ViewChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChangeView(&mut self, horizontaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, verticaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, zoomfactor: &::core::option::Option<super::super::super::Foundation::IReference<f32>>) -> ::windows::core::Result<bool>;
    fn ChangeViewWithOptionalAnimation(&mut self, horizontaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, verticaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, zoomfactor: &::core::option::Option<super::super::super::Foundation::IReference<f32>>, disableanimation: bool) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollViewer2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewer2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewer2_Vtbl {
        unsafe extern "system" fn TopLeftHeader<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopLeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopLeftHeader<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopLeftHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LeftHeader<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeader<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TopHeader<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopHeader<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ViewChanging<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChanging(&*(&handler as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChanging<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChangeView<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, horizontaloffset: ::windows::core::RawPtr, verticaloffset: ::windows::core::RawPtr, zoomfactor: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChangeView(
                &*(&horizontaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&verticaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&zoomfactor as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeViewWithOptionalAnimation<Impl: IScrollViewer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, horizontaloffset: ::windows::core::RawPtr, verticaloffset: ::windows::core::RawPtr, zoomfactor: ::windows::core::RawPtr, disableanimation: bool, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChangeViewWithOptionalAnimation(
                &*(&horizontaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&verticaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&zoomfactor as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::DefaultType>::DefaultType),
                disableanimation,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer2, BASE_OFFSET>(),
            TopLeftHeader: TopLeftHeader::<Impl, IMPL_OFFSET>,
            SetTopLeftHeader: SetTopLeftHeader::<Impl, IMPL_OFFSET>,
            LeftHeader: LeftHeader::<Impl, IMPL_OFFSET>,
            SetLeftHeader: SetLeftHeader::<Impl, IMPL_OFFSET>,
            TopHeader: TopHeader::<Impl, IMPL_OFFSET>,
            SetTopHeader: SetTopHeader::<Impl, IMPL_OFFSET>,
            ViewChanging: ViewChanging::<Impl, IMPL_OFFSET>,
            RemoveViewChanging: RemoveViewChanging::<Impl, IMPL_OFFSET>,
            ChangeView: ChangeView::<Impl, IMPL_OFFSET>,
            ChangeViewWithOptionalAnimation: ChangeViewWithOptionalAnimation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollViewer3_Impl: Sized {
    fn DirectManipulationStarted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDirectManipulationStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DirectManipulationCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDirectManipulationCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollViewer3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewer3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewer3_Vtbl {
        unsafe extern "system" fn DirectManipulationStarted<Impl: IScrollViewer3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DirectManipulationStarted(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDirectManipulationStarted<Impl: IScrollViewer3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDirectManipulationStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DirectManipulationCompleted<Impl: IScrollViewer3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DirectManipulationCompleted(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDirectManipulationCompleted<Impl: IScrollViewer3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDirectManipulationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer3, BASE_OFFSET>(),
            DirectManipulationStarted: DirectManipulationStarted::<Impl, IMPL_OFFSET>,
            RemoveDirectManipulationStarted: RemoveDirectManipulationStarted::<Impl, IMPL_OFFSET>,
            DirectManipulationCompleted: DirectManipulationCompleted::<Impl, IMPL_OFFSET>,
            RemoveDirectManipulationCompleted: RemoveDirectManipulationCompleted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IScrollViewer4_Impl: Sized {
    fn ReduceViewportForCoreInputViewOcclusions(&mut self) -> ::windows::core::Result<bool>;
    fn SetReduceViewportForCoreInputViewOcclusions(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HorizontalAnchorRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalAnchorRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalAnchorRatio(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalAnchorRatio(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn CanContentRenderOutsideBounds(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AnchorRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveAnchorRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IScrollViewer4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IScrollViewer4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewer4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewer4_Vtbl {
        unsafe extern "system" fn ReduceViewportForCoreInputViewOcclusions<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReduceViewportForCoreInputViewOcclusions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReduceViewportForCoreInputViewOcclusions<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetReduceViewportForCoreInputViewOcclusions(value).into()
        }
        unsafe extern "system" fn HorizontalAnchorRatio<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalAnchorRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalAnchorRatio<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalAnchorRatio(value).into()
        }
        unsafe extern "system" fn VerticalAnchorRatio<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalAnchorRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalAnchorRatio<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalAnchorRatio(value).into()
        }
        unsafe extern "system" fn CanContentRenderOutsideBounds<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(value).into()
        }
        unsafe extern "system" fn AnchorRequested<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnchorRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAnchorRequested<Impl: IScrollViewer4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAnchorRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewer4, BASE_OFFSET>(),
            ReduceViewportForCoreInputViewOcclusions: ReduceViewportForCoreInputViewOcclusions::<Impl, IMPL_OFFSET>,
            SetReduceViewportForCoreInputViewOcclusions: SetReduceViewportForCoreInputViewOcclusions::<Impl, IMPL_OFFSET>,
            HorizontalAnchorRatio: HorizontalAnchorRatio::<Impl, IMPL_OFFSET>,
            SetHorizontalAnchorRatio: SetHorizontalAnchorRatio::<Impl, IMPL_OFFSET>,
            VerticalAnchorRatio: VerticalAnchorRatio::<Impl, IMPL_OFFSET>,
            SetVerticalAnchorRatio: SetVerticalAnchorRatio::<Impl, IMPL_OFFSET>,
            CanContentRenderOutsideBounds: CanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SetCanContentRenderOutsideBounds: SetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            AnchorRequested: AnchorRequested::<Impl, IMPL_OFFSET>,
            RemoveAnchorRequested: RemoveAnchorRequested::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewer4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStatics_Impl: Sized {
    fn HorizontalSnapPointsAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSnapPointsAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSnapPointsTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSnapPointsTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomSnapPointsTypeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ViewportWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ScrollableWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ComputedHorizontalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExtentWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ViewportHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ScrollableHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ComputedVerticalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExtentHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinZoomFactorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxZoomFactorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomFactorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomSnapPointsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetHorizontalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetHorizontalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>, horizontalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn VerticalScrollBarVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVerticalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetVerticalScrollBarVisibility(&mut self, element: &::core::option::Option<super::DependencyObject>, verticalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn IsHorizontalRailEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsHorizontalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, ishorizontalrailenabled: bool) -> ::windows::core::Result<()>;
    fn IsVerticalRailEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVerticalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsVerticalRailEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isverticalrailenabled: bool) -> ::windows::core::Result<()>;
    fn IsHorizontalScrollChainingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsHorizontalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, ishorizontalscrollchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsVerticalScrollChainingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVerticalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsVerticalScrollChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isverticalscrollchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsZoomChainingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsZoomChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsZoomChainingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, iszoomchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsScrollInertiaEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsScrollInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsScrollInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isscrollinertiaenabled: bool) -> ::windows::core::Result<()>;
    fn IsZoomInertiaEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsZoomInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsZoomInertiaEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, iszoominertiaenabled: bool) -> ::windows::core::Result<()>;
    fn HorizontalScrollModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetHorizontalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollMode>;
    fn SetHorizontalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>, horizontalscrollmode: ScrollMode) -> ::windows::core::Result<()>;
    fn VerticalScrollModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVerticalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollMode>;
    fn SetVerticalScrollMode(&mut self, element: &::core::option::Option<super::DependencyObject>, verticalscrollmode: ScrollMode) -> ::windows::core::Result<()>;
    fn ZoomModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetZoomMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ZoomMode>;
    fn SetZoomMode(&mut self, element: &::core::option::Option<super::DependencyObject>, zoommode: ZoomMode) -> ::windows::core::Result<()>;
    fn IsDeferredScrollingEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsDeferredScrollingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsDeferredScrollingEnabled(&mut self, element: &::core::option::Option<super::DependencyObject>, isdeferredscrollingenabled: bool) -> ::windows::core::Result<()>;
    fn BringIntoViewOnFocusChangeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetBringIntoViewOnFocusChange(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetBringIntoViewOnFocusChange(&mut self, element: &::core::option::Option<super::DependencyObject>, bringintoviewonfocuschange: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerStatics_Vtbl {
        unsafe extern "system" fn HorizontalSnapPointsAlignmentProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSnapPointsAlignmentProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSnapPointsTypeProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSnapPointsTypeProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPointsTypeProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalOffsetProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidthProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableWidthProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedHorizontalScrollBarVisibilityProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedHorizontalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentWidthProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffsetProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeightProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewportHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableHeightProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScrollableHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedVerticalScrollBarVisibilityProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ComputedVerticalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeightProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExtentHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinZoomFactorProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxZoomFactorProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomFactorProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPointsProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalScrollBarVisibilityProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHorizontalScrollBarVisibility<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHorizontalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollBarVisibility<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, horizontalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), horizontalscrollbarvisibility).into()
        }
        unsafe extern "system" fn VerticalScrollBarVisibilityProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVerticalScrollBarVisibility<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVerticalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollBarVisibility<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, verticalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), verticalscrollbarvisibility).into()
        }
        unsafe extern "system" fn IsHorizontalRailEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalRailEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsHorizontalRailEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsHorizontalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalRailEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, ishorizontalrailenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), ishorizontalrailenabled).into()
        }
        unsafe extern "system" fn IsVerticalRailEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalRailEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVerticalRailEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsVerticalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalRailEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isverticalrailenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isverticalrailenabled).into()
        }
        unsafe extern "system" fn IsHorizontalScrollChainingEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHorizontalScrollChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsHorizontalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, ishorizontalscrollchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), ishorizontalscrollchainingenabled).into()
        }
        unsafe extern "system" fn IsVerticalScrollChainingEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVerticalScrollChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVerticalScrollChainingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsVerticalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalScrollChainingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isverticalscrollchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsVerticalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isverticalscrollchainingenabled).into()
        }
        unsafe extern "system" fn IsZoomChainingEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsZoomChainingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsZoomChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomChainingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, iszoomchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), iszoomchainingenabled).into()
        }
        unsafe extern "system" fn IsScrollInertiaEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsScrollInertiaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsScrollInertiaEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsScrollInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsScrollInertiaEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isscrollinertiaenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsScrollInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isscrollinertiaenabled).into()
        }
        unsafe extern "system" fn IsZoomInertiaEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomInertiaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsZoomInertiaEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsZoomInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomInertiaEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, iszoominertiaenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), iszoominertiaenabled).into()
        }
        unsafe extern "system" fn HorizontalScrollModeProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHorizontalScrollMode<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHorizontalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollMode<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, horizontalscrollmode: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), horizontalscrollmode).into()
        }
        unsafe extern "system" fn VerticalScrollModeProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalScrollModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVerticalScrollMode<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVerticalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollMode<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, verticalscrollmode: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), verticalscrollmode).into()
        }
        unsafe extern "system" fn ZoomModeProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZoomMode<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetZoomMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomMode<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, zoommode: ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), zoommode).into()
        }
        unsafe extern "system" fn IsDeferredScrollingEnabledProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDeferredScrollingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsDeferredScrollingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsDeferredScrollingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDeferredScrollingEnabled<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isdeferredscrollingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDeferredScrollingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isdeferredscrollingenabled).into()
        }
        unsafe extern "system" fn BringIntoViewOnFocusChangeProperty<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BringIntoViewOnFocusChangeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBringIntoViewOnFocusChange<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBringIntoViewOnFocusChange(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBringIntoViewOnFocusChange<Impl: IScrollViewerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, bringintoviewonfocuschange: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBringIntoViewOnFocusChange(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), bringintoviewonfocuschange).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerStatics, BASE_OFFSET>(),
            HorizontalSnapPointsAlignmentProperty: HorizontalSnapPointsAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsAlignmentProperty: VerticalSnapPointsAlignmentProperty::<Impl, IMPL_OFFSET>,
            HorizontalSnapPointsTypeProperty: HorizontalSnapPointsTypeProperty::<Impl, IMPL_OFFSET>,
            VerticalSnapPointsTypeProperty: VerticalSnapPointsTypeProperty::<Impl, IMPL_OFFSET>,
            ZoomSnapPointsTypeProperty: ZoomSnapPointsTypeProperty::<Impl, IMPL_OFFSET>,
            HorizontalOffsetProperty: HorizontalOffsetProperty::<Impl, IMPL_OFFSET>,
            ViewportWidthProperty: ViewportWidthProperty::<Impl, IMPL_OFFSET>,
            ScrollableWidthProperty: ScrollableWidthProperty::<Impl, IMPL_OFFSET>,
            ComputedHorizontalScrollBarVisibilityProperty: ComputedHorizontalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            ExtentWidthProperty: ExtentWidthProperty::<Impl, IMPL_OFFSET>,
            VerticalOffsetProperty: VerticalOffsetProperty::<Impl, IMPL_OFFSET>,
            ViewportHeightProperty: ViewportHeightProperty::<Impl, IMPL_OFFSET>,
            ScrollableHeightProperty: ScrollableHeightProperty::<Impl, IMPL_OFFSET>,
            ComputedVerticalScrollBarVisibilityProperty: ComputedVerticalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            ExtentHeightProperty: ExtentHeightProperty::<Impl, IMPL_OFFSET>,
            MinZoomFactorProperty: MinZoomFactorProperty::<Impl, IMPL_OFFSET>,
            MaxZoomFactorProperty: MaxZoomFactorProperty::<Impl, IMPL_OFFSET>,
            ZoomFactorProperty: ZoomFactorProperty::<Impl, IMPL_OFFSET>,
            ZoomSnapPointsProperty: ZoomSnapPointsProperty::<Impl, IMPL_OFFSET>,
            HorizontalScrollBarVisibilityProperty: HorizontalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            GetHorizontalScrollBarVisibility: GetHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollBarVisibility: SetHorizontalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            VerticalScrollBarVisibilityProperty: VerticalScrollBarVisibilityProperty::<Impl, IMPL_OFFSET>,
            GetVerticalScrollBarVisibility: GetVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            SetVerticalScrollBarVisibility: SetVerticalScrollBarVisibility::<Impl, IMPL_OFFSET>,
            IsHorizontalRailEnabledProperty: IsHorizontalRailEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsHorizontalRailEnabled: GetIsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalRailEnabled: SetIsHorizontalRailEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalRailEnabledProperty: IsVerticalRailEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsVerticalRailEnabled: GetIsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalRailEnabled: SetIsVerticalRailEnabled::<Impl, IMPL_OFFSET>,
            IsHorizontalScrollChainingEnabledProperty: IsHorizontalScrollChainingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsHorizontalScrollChainingEnabled: GetIsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsHorizontalScrollChainingEnabled: SetIsHorizontalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsVerticalScrollChainingEnabledProperty: IsVerticalScrollChainingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsVerticalScrollChainingEnabled: GetIsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsVerticalScrollChainingEnabled: SetIsVerticalScrollChainingEnabled::<Impl, IMPL_OFFSET>,
            IsZoomChainingEnabledProperty: IsZoomChainingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsZoomChainingEnabled: GetIsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomChainingEnabled: SetIsZoomChainingEnabled::<Impl, IMPL_OFFSET>,
            IsScrollInertiaEnabledProperty: IsScrollInertiaEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsScrollInertiaEnabled: GetIsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsScrollInertiaEnabled: SetIsScrollInertiaEnabled::<Impl, IMPL_OFFSET>,
            IsZoomInertiaEnabledProperty: IsZoomInertiaEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsZoomInertiaEnabled: GetIsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomInertiaEnabled: SetIsZoomInertiaEnabled::<Impl, IMPL_OFFSET>,
            HorizontalScrollModeProperty: HorizontalScrollModeProperty::<Impl, IMPL_OFFSET>,
            GetHorizontalScrollMode: GetHorizontalScrollMode::<Impl, IMPL_OFFSET>,
            SetHorizontalScrollMode: SetHorizontalScrollMode::<Impl, IMPL_OFFSET>,
            VerticalScrollModeProperty: VerticalScrollModeProperty::<Impl, IMPL_OFFSET>,
            GetVerticalScrollMode: GetVerticalScrollMode::<Impl, IMPL_OFFSET>,
            SetVerticalScrollMode: SetVerticalScrollMode::<Impl, IMPL_OFFSET>,
            ZoomModeProperty: ZoomModeProperty::<Impl, IMPL_OFFSET>,
            GetZoomMode: GetZoomMode::<Impl, IMPL_OFFSET>,
            SetZoomMode: SetZoomMode::<Impl, IMPL_OFFSET>,
            IsDeferredScrollingEnabledProperty: IsDeferredScrollingEnabledProperty::<Impl, IMPL_OFFSET>,
            GetIsDeferredScrollingEnabled: GetIsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            SetIsDeferredScrollingEnabled: SetIsDeferredScrollingEnabled::<Impl, IMPL_OFFSET>,
            BringIntoViewOnFocusChangeProperty: BringIntoViewOnFocusChangeProperty::<Impl, IMPL_OFFSET>,
            GetBringIntoViewOnFocusChange: GetBringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
            SetBringIntoViewOnFocusChange: SetBringIntoViewOnFocusChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStatics2_Impl: Sized {
    fn TopLeftHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopHeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerStatics2_Vtbl {
        unsafe extern "system" fn TopLeftHeaderProperty<Impl: IScrollViewerStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopLeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftHeaderProperty<Impl: IScrollViewerStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopHeaderProperty<Impl: IScrollViewerStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerStatics2, BASE_OFFSET>(),
            TopLeftHeaderProperty: TopLeftHeaderProperty::<Impl, IMPL_OFFSET>,
            LeftHeaderProperty: LeftHeaderProperty::<Impl, IMPL_OFFSET>,
            TopHeaderProperty: TopHeaderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStatics4_Impl: Sized {
    fn ReduceViewportForCoreInputViewOcclusionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalAnchorRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalAnchorRatioProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanContentRenderOutsideBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetCanContentRenderOutsideBounds(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&mut self, element: &::core::option::Option<super::DependencyObject>, cancontentrenderoutsidebounds: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerStatics4_Vtbl {
        unsafe extern "system" fn ReduceViewportForCoreInputViewOcclusionsProperty<Impl: IScrollViewerStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReduceViewportForCoreInputViewOcclusionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalAnchorRatioProperty<Impl: IScrollViewerStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalAnchorRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalAnchorRatioProperty<Impl: IScrollViewerStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalAnchorRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanContentRenderOutsideBoundsProperty<Impl: IScrollViewerStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCanContentRenderOutsideBounds<Impl: IScrollViewerStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCanContentRenderOutsideBounds(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollViewerStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, cancontentrenderoutsidebounds: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), cancontentrenderoutsidebounds).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerStatics4, BASE_OFFSET>(),
            ReduceViewportForCoreInputViewOcclusionsProperty: ReduceViewportForCoreInputViewOcclusionsProperty::<Impl, IMPL_OFFSET>,
            HorizontalAnchorRatioProperty: HorizontalAnchorRatioProperty::<Impl, IMPL_OFFSET>,
            VerticalAnchorRatioProperty: VerticalAnchorRatioProperty::<Impl, IMPL_OFFSET>,
            CanContentRenderOutsideBoundsProperty: CanContentRenderOutsideBoundsProperty::<Impl, IMPL_OFFSET>,
            GetCanContentRenderOutsideBounds: GetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
            SetCanContentRenderOutsideBounds: SetCanContentRenderOutsideBounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerView_Impl: Sized {
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn ZoomFactor(&mut self) -> ::windows::core::Result<f32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerView";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerView_Vtbl {
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollViewerView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollViewerView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomFactor<Impl: IScrollViewerView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerView, BASE_OFFSET>(),
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            ZoomFactor: ZoomFactor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewChangedEventArgs_Impl: Sized {
    fn IsIntermediate(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerViewChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerViewChangedEventArgs_Vtbl {
        unsafe extern "system" fn IsIntermediate<Impl: IScrollViewerViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIntermediate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerViewChangedEventArgs, BASE_OFFSET>(),
            IsIntermediate: IsIntermediate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerViewChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewChangingEventArgs_Impl: Sized {
    fn NextView(&mut self) -> ::windows::core::Result<ScrollViewerView>;
    fn FinalView(&mut self) -> ::windows::core::Result<ScrollViewerView>;
    fn IsInertial(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerViewChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerViewChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScrollViewerViewChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScrollViewerViewChangingEventArgs_Vtbl {
        unsafe extern "system" fn NextView<Impl: IScrollViewerViewChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NextView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FinalView<Impl: IScrollViewerViewChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FinalView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInertial<Impl: IScrollViewerViewChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInertial() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IScrollViewerViewChangingEventArgs, BASE_OFFSET>(),
            NextView: NextView::<Impl, IMPL_OFFSET>,
            FinalView: FinalView::<Impl, IMPL_OFFSET>,
            IsInertial: IsInertial::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScrollViewerViewChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISearchBox_Impl: Sized {
    fn SearchHistoryEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetSearchHistoryEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SearchHistoryContext(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSearchHistoryContext(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetQueryText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FocusOnKeyboardInput(&mut self) -> ::windows::core::Result<bool>;
    fn SetFocusOnKeyboardInput(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ChooseSuggestionOnEnter(&mut self) -> ::windows::core::Result<bool>;
    fn SetChooseSuggestionOnEnter(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn QueryChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQueryChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SuggestionsRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSuggestionsRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn QuerySubmitted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQuerySubmitted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ResultSuggestionChosen(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveResultSuggestionChosen(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PrepareForFocusOnKeyboardInput(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePrepareForFocusOnKeyboardInput(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetLocalContentSuggestionSettings(&mut self, settings: &::core::option::Option<super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBox";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "Foundation", feature = "implement_exclusive"))]
impl ISearchBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBox_Vtbl {
        unsafe extern "system" fn SearchHistoryEnabled<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSearchHistoryEnabled<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSearchHistoryEnabled(value).into()
        }
        unsafe extern "system" fn SearchHistoryContext<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryContext() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSearchHistoryContext<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSearchHistoryContext(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QueryText<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQueryText<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetQueryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusOnKeyboardInput<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusOnKeyboardInput() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusOnKeyboardInput<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocusOnKeyboardInput(value).into()
        }
        unsafe extern "system" fn ChooseSuggestionOnEnter<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChooseSuggestionOnEnter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChooseSuggestionOnEnter<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChooseSuggestionOnEnter(value).into()
        }
        unsafe extern "system" fn QueryChanged<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQueryChanged<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveQueryChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SuggestionsRequested<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SuggestionsRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSuggestionsRequested<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSuggestionsRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QuerySubmitted<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QuerySubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQuerySubmitted<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveQuerySubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ResultSuggestionChosen<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ResultSuggestionChosen(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveResultSuggestionChosen<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveResultSuggestionChosen(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrepareForFocusOnKeyboardInput<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrepareForFocusOnKeyboardInput(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePrepareForFocusOnKeyboardInput<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePrepareForFocusOnKeyboardInput(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetLocalContentSuggestionSettings<Impl: ISearchBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, settings: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalContentSuggestionSettings(&*(&settings as *const <super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings as ::windows::core::Abi>::Abi as *const <super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBox, BASE_OFFSET>(),
            SearchHistoryEnabled: SearchHistoryEnabled::<Impl, IMPL_OFFSET>,
            SetSearchHistoryEnabled: SetSearchHistoryEnabled::<Impl, IMPL_OFFSET>,
            SearchHistoryContext: SearchHistoryContext::<Impl, IMPL_OFFSET>,
            SetSearchHistoryContext: SetSearchHistoryContext::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            SetQueryText: SetQueryText::<Impl, IMPL_OFFSET>,
            FocusOnKeyboardInput: FocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            SetFocusOnKeyboardInput: SetFocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            ChooseSuggestionOnEnter: ChooseSuggestionOnEnter::<Impl, IMPL_OFFSET>,
            SetChooseSuggestionOnEnter: SetChooseSuggestionOnEnter::<Impl, IMPL_OFFSET>,
            QueryChanged: QueryChanged::<Impl, IMPL_OFFSET>,
            RemoveQueryChanged: RemoveQueryChanged::<Impl, IMPL_OFFSET>,
            SuggestionsRequested: SuggestionsRequested::<Impl, IMPL_OFFSET>,
            RemoveSuggestionsRequested: RemoveSuggestionsRequested::<Impl, IMPL_OFFSET>,
            QuerySubmitted: QuerySubmitted::<Impl, IMPL_OFFSET>,
            RemoveQuerySubmitted: RemoveQuerySubmitted::<Impl, IMPL_OFFSET>,
            ResultSuggestionChosen: ResultSuggestionChosen::<Impl, IMPL_OFFSET>,
            RemoveResultSuggestionChosen: RemoveResultSuggestionChosen::<Impl, IMPL_OFFSET>,
            PrepareForFocusOnKeyboardInput: PrepareForFocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            RemovePrepareForFocusOnKeyboardInput: RemovePrepareForFocusOnKeyboardInput::<Impl, IMPL_OFFSET>,
            SetLocalContentSuggestionSettings: SetLocalContentSuggestionSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SearchBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISearchBoxFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
pub trait ISearchBoxQueryChangedEventArgs_Impl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxQueryChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxQueryChangedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ISearchBoxQueryChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxQueryChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxQueryChangedEventArgs_Vtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxQueryChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxQueryChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxQueryChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxQueryChangedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            Language: Language::<Impl, IMPL_OFFSET>,
            LinguisticDetails: LinguisticDetails::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxQueryChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "System", feature = "implement_exclusive"))]
pub trait ISearchBoxQuerySubmittedEventArgs_Impl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
    fn KeyModifiers(&mut self) -> ::windows::core::Result<super::super::super::System::VirtualKeyModifiers>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "System", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxQuerySubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxQuerySubmittedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "System", feature = "implement_exclusive"))]
impl ISearchBoxQuerySubmittedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxQuerySubmittedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxQuerySubmittedEventArgs_Vtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxQuerySubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxQuerySubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxQuerySubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyModifiers<Impl: ISearchBoxQuerySubmittedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::System::VirtualKeyModifiers) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyModifiers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxQuerySubmittedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            Language: Language::<Impl, IMPL_OFFSET>,
            LinguisticDetails: LinguisticDetails::<Impl, IMPL_OFFSET>,
            KeyModifiers: KeyModifiers::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxQuerySubmittedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "System", feature = "implement_exclusive"))]
pub trait ISearchBoxResultSuggestionChosenEventArgs_Impl: Sized {
    fn Tag(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn KeyModifiers(&mut self) -> ::windows::core::Result<super::super::super::System::VirtualKeyModifiers>;
}
#[cfg(all(feature = "System", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxResultSuggestionChosenEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxResultSuggestionChosenEventArgs";
}
#[cfg(all(feature = "System", feature = "implement_exclusive"))]
impl ISearchBoxResultSuggestionChosenEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxResultSuggestionChosenEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxResultSuggestionChosenEventArgs_Vtbl {
        unsafe extern "system" fn Tag<Impl: ISearchBoxResultSuggestionChosenEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Tag() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyModifiers<Impl: ISearchBoxResultSuggestionChosenEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::System::VirtualKeyModifiers) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyModifiers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxResultSuggestionChosenEventArgs, BASE_OFFSET>(),
            Tag: Tag::<Impl, IMPL_OFFSET>,
            KeyModifiers: KeyModifiers::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxResultSuggestionChosenEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxStatics_Impl: Sized {
    fn SearchHistoryEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SearchHistoryContextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn QueryTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusOnKeyboardInputProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChooseSuggestionOnEnterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxStatics_Vtbl {
        unsafe extern "system" fn SearchHistoryEnabledProperty<Impl: ISearchBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SearchHistoryContextProperty<Impl: ISearchBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SearchHistoryContextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ISearchBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryTextProperty<Impl: ISearchBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusOnKeyboardInputProperty<Impl: ISearchBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FocusOnKeyboardInputProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChooseSuggestionOnEnterProperty<Impl: ISearchBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChooseSuggestionOnEnterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxStatics, BASE_OFFSET>(),
            SearchHistoryEnabledProperty: SearchHistoryEnabledProperty::<Impl, IMPL_OFFSET>,
            SearchHistoryContextProperty: SearchHistoryContextProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            QueryTextProperty: QueryTextProperty::<Impl, IMPL_OFFSET>,
            FocusOnKeyboardInputProperty: FocusOnKeyboardInputProperty::<Impl, IMPL_OFFSET>,
            ChooseSuggestionOnEnterProperty: ChooseSuggestionOnEnterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
pub trait ISearchBoxSuggestionsRequestedEventArgs_Impl: Sized {
    fn QueryText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
    fn Request(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchSuggestionsRequest>;
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISearchBoxSuggestionsRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxSuggestionsRequestedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_Search", feature = "implement_exclusive"))]
impl ISearchBoxSuggestionsRequestedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISearchBoxSuggestionsRequestedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISearchBoxSuggestionsRequestedEventArgs_Vtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxSuggestionsRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxSuggestionsRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxSuggestionsRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Request<Impl: ISearchBoxSuggestionsRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Request() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISearchBoxSuggestionsRequestedEventArgs, BASE_OFFSET>(),
            QueryText: QueryText::<Impl, IMPL_OFFSET>,
            Language: Language::<Impl, IMPL_OFFSET>,
            LinguisticDetails: LinguisticDetails::<Impl, IMPL_OFFSET>,
            Request: Request::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISearchBoxSuggestionsRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ISectionsInViewChangedEventArgs_Impl: Sized {
    fn AddedSections(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn RemovedSections(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISectionsInViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ISectionsInViewChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISectionsInViewChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISectionsInViewChangedEventArgs_Vtbl {
        unsafe extern "system" fn AddedSections<Impl: ISectionsInViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedSections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedSections<Impl: ISectionsInViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedSections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISectionsInViewChangedEventArgs, BASE_OFFSET>(),
            AddedSections: AddedSections::<Impl, IMPL_OFFSET>,
            RemovedSections: RemovedSections::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISectionsInViewChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISectionsInViewChangedEventArgsFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISectionsInViewChangedEventArgsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISectionsInViewChangedEventArgsFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISectionsInViewChangedEventArgsFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISectionsInViewChangedEventArgsFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISectionsInViewChangedEventArgsFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISectionsInViewChangedEventArgsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ISelectionChangedEventArgs_Impl: Sized {
    fn AddedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn RemovedItems(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISelectionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgs";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ISelectionChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISelectionChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISelectionChangedEventArgs_Vtbl {
        unsafe extern "system" fn AddedItems<Impl: ISelectionChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedItems<Impl: ISelectionChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemovedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISelectionChangedEventArgs, BASE_OFFSET>(),
            AddedItems: AddedItems::<Impl, IMPL_OFFSET>,
            RemovedItems: RemovedItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISelectionChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ISelectionChangedEventArgsFactory_Impl: Sized {
    fn CreateInstanceWithRemovedItemsAndAddedItems(&mut self, removeditems: &::core::option::Option<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>, addeditems: &::core::option::Option<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SelectionChangedEventArgs>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISelectionChangedEventArgsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgsFactory";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ISelectionChangedEventArgsFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISelectionChangedEventArgsFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISelectionChangedEventArgsFactory_Vtbl {
        unsafe extern "system" fn CreateInstanceWithRemovedItemsAndAddedItems<Impl: ISelectionChangedEventArgsFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, removeditems: ::windows::core::RawPtr, addeditems: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithRemovedItemsAndAddedItems(
                &*(&removeditems as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType),
                &*(&addeditems as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType),
                &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&innerinterface),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISelectionChangedEventArgsFactory, BASE_OFFSET>(),
            CreateInstanceWithRemovedItemsAndAddedItems: CreateInstanceWithRemovedItemsAndAddedItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISelectionChangedEventArgsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISemanticZoom_Impl: Sized {
    fn ZoomedInView(&mut self) -> ::windows::core::Result<ISemanticZoomInformation>;
    fn SetZoomedInView(&mut self, value: &::core::option::Option<ISemanticZoomInformation>) -> ::windows::core::Result<()>;
    fn ZoomedOutView(&mut self) -> ::windows::core::Result<ISemanticZoomInformation>;
    fn SetZoomedOutView(&mut self, value: &::core::option::Option<ISemanticZoomInformation>) -> ::windows::core::Result<()>;
    fn IsZoomedInViewActive(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomedInViewActive(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanChangeViews(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanChangeViews(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ViewChangeStarted(&mut self, handler: &::core::option::Option<SemanticZoomViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChangeStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ViewChangeCompleted(&mut self, handler: &::core::option::Option<SemanticZoomViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChangeCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ToggleActiveView(&mut self) -> ::windows::core::Result<()>;
    fn IsZoomOutButtonEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomOutButtonEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISemanticZoom {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoom";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ISemanticZoom_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoom_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoom_Vtbl {
        unsafe extern "system" fn ZoomedInView<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomedInView<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomedInView(&*(&value as *const <ISemanticZoomInformation as ::windows::core::Abi>::Abi as *const <ISemanticZoomInformation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ZoomedOutView<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedOutView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomedOutView<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomedOutView(&*(&value as *const <ISemanticZoomInformation as ::windows::core::Abi>::Abi as *const <ISemanticZoomInformation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsZoomedInViewActive<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewActive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomedInViewActive<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomedInViewActive(value).into()
        }
        unsafe extern "system" fn CanChangeViews<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanChangeViews() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanChangeViews<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanChangeViews(value).into()
        }
        unsafe extern "system" fn ViewChangeStarted<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChangeStarted(&*(&handler as *const <SemanticZoomViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SemanticZoomViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChangeStarted<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChangeStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ViewChangeCompleted<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ViewChangeCompleted(&*(&handler as *const <SemanticZoomViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SemanticZoomViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChangeCompleted<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveViewChangeCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ToggleActiveView<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ToggleActiveView().into()
        }
        unsafe extern "system" fn IsZoomOutButtonEnabled<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomOutButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomOutButtonEnabled<Impl: ISemanticZoom_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomOutButtonEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoom, BASE_OFFSET>(),
            ZoomedInView: ZoomedInView::<Impl, IMPL_OFFSET>,
            SetZoomedInView: SetZoomedInView::<Impl, IMPL_OFFSET>,
            ZoomedOutView: ZoomedOutView::<Impl, IMPL_OFFSET>,
            SetZoomedOutView: SetZoomedOutView::<Impl, IMPL_OFFSET>,
            IsZoomedInViewActive: IsZoomedInViewActive::<Impl, IMPL_OFFSET>,
            SetIsZoomedInViewActive: SetIsZoomedInViewActive::<Impl, IMPL_OFFSET>,
            CanChangeViews: CanChangeViews::<Impl, IMPL_OFFSET>,
            SetCanChangeViews: SetCanChangeViews::<Impl, IMPL_OFFSET>,
            ViewChangeStarted: ViewChangeStarted::<Impl, IMPL_OFFSET>,
            RemoveViewChangeStarted: RemoveViewChangeStarted::<Impl, IMPL_OFFSET>,
            ViewChangeCompleted: ViewChangeCompleted::<Impl, IMPL_OFFSET>,
            RemoveViewChangeCompleted: RemoveViewChangeCompleted::<Impl, IMPL_OFFSET>,
            ToggleActiveView: ToggleActiveView::<Impl, IMPL_OFFSET>,
            IsZoomOutButtonEnabled: IsZoomOutButtonEnabled::<Impl, IMPL_OFFSET>,
            SetIsZoomOutButtonEnabled: SetIsZoomOutButtonEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoom as ::windows::core::Interface>::IID
    }
}
pub trait ISemanticZoomInformation_Impl: Sized {
    fn SemanticZoomOwner(&mut self) -> ::windows::core::Result<SemanticZoom>;
    fn SetSemanticZoomOwner(&mut self, value: &::core::option::Option<SemanticZoom>) -> ::windows::core::Result<()>;
    fn IsActiveView(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsActiveView(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomedInView(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsZoomedInView(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn InitializeViewChange(&mut self) -> ::windows::core::Result<()>;
    fn CompleteViewChange(&mut self) -> ::windows::core::Result<()>;
    fn MakeVisible(&mut self, item: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn StartViewChangeFrom(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn StartViewChangeTo(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn CompleteViewChangeFrom(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn CompleteViewChangeTo(&mut self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ISemanticZoomInformation {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomInformation";
}
impl ISemanticZoomInformation_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomInformation_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomInformation_Vtbl {
        unsafe extern "system" fn SemanticZoomOwner<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwner() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSemanticZoomOwner<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSemanticZoomOwner(&*(&value as *const <SemanticZoom as ::windows::core::Abi>::Abi as *const <SemanticZoom as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsActiveView<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsActiveView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsActiveView<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsActiveView(value).into()
        }
        unsafe extern "system" fn IsZoomedInView<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomedInView<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsZoomedInView(value).into()
        }
        unsafe extern "system" fn InitializeViewChange<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeViewChange().into()
        }
        unsafe extern "system" fn CompleteViewChange<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompleteViewChange().into()
        }
        unsafe extern "system" fn MakeVisible<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MakeVisible(&*(&item as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn StartViewChangeFrom<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartViewChangeFrom(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn StartViewChangeTo<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartViewChangeTo(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompleteViewChangeFrom<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompleteViewChangeFrom(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompleteViewChangeTo<Impl: ISemanticZoomInformation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompleteViewChangeTo(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomInformation, BASE_OFFSET>(),
            SemanticZoomOwner: SemanticZoomOwner::<Impl, IMPL_OFFSET>,
            SetSemanticZoomOwner: SetSemanticZoomOwner::<Impl, IMPL_OFFSET>,
            IsActiveView: IsActiveView::<Impl, IMPL_OFFSET>,
            SetIsActiveView: SetIsActiveView::<Impl, IMPL_OFFSET>,
            IsZoomedInView: IsZoomedInView::<Impl, IMPL_OFFSET>,
            SetIsZoomedInView: SetIsZoomedInView::<Impl, IMPL_OFFSET>,
            InitializeViewChange: InitializeViewChange::<Impl, IMPL_OFFSET>,
            CompleteViewChange: CompleteViewChange::<Impl, IMPL_OFFSET>,
            MakeVisible: MakeVisible::<Impl, IMPL_OFFSET>,
            StartViewChangeFrom: StartViewChangeFrom::<Impl, IMPL_OFFSET>,
            StartViewChangeTo: StartViewChangeTo::<Impl, IMPL_OFFSET>,
            CompleteViewChangeFrom: CompleteViewChangeFrom::<Impl, IMPL_OFFSET>,
            CompleteViewChangeTo: CompleteViewChangeTo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomInformation as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISemanticZoomLocation_Impl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItem(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Bounds(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
    fn SetBounds(&mut self, value: &super::super::super::Foundation::Rect) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISemanticZoomLocation {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomLocation";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ISemanticZoomLocation_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomLocation_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomLocation_Vtbl {
        unsafe extern "system" fn Item<Impl: ISemanticZoomLocation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: ISemanticZoomLocation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Bounds<Impl: ISemanticZoomLocation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Bounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBounds<Impl: ISemanticZoomLocation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBounds(&*(&value as *const <super::super::super::Foundation::Rect as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Rect as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomLocation, BASE_OFFSET>(),
            Item: Item::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
            Bounds: Bounds::<Impl, IMPL_OFFSET>,
            SetBounds: SetBounds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomLocation as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomStatics_Impl: Sized {
    fn ZoomedInViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomedOutViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewActiveProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanChangeViewsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomOutButtonEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoomStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomStatics_Vtbl {
        unsafe extern "system" fn ZoomedInViewProperty<Impl: ISemanticZoomStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomedOutViewProperty<Impl: ISemanticZoomStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ZoomedOutViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewActiveProperty<Impl: ISemanticZoomStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewActiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanChangeViewsProperty<Impl: ISemanticZoomStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanChangeViewsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomOutButtonEnabledProperty<Impl: ISemanticZoomStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsZoomOutButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomStatics, BASE_OFFSET>(),
            ZoomedInViewProperty: ZoomedInViewProperty::<Impl, IMPL_OFFSET>,
            ZoomedOutViewProperty: ZoomedOutViewProperty::<Impl, IMPL_OFFSET>,
            IsZoomedInViewActiveProperty: IsZoomedInViewActiveProperty::<Impl, IMPL_OFFSET>,
            CanChangeViewsProperty: CanChangeViewsProperty::<Impl, IMPL_OFFSET>,
            IsZoomOutButtonEnabledProperty: IsZoomOutButtonEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomViewChangedEventArgs_Impl: Sized {
    fn IsSourceZoomedInView(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSourceZoomedInView(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SourceItem(&mut self) -> ::windows::core::Result<SemanticZoomLocation>;
    fn SetSourceItem(&mut self, value: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn DestinationItem(&mut self) -> ::windows::core::Result<SemanticZoomLocation>;
    fn SetDestinationItem(&mut self, value: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoomViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomViewChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISemanticZoomViewChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISemanticZoomViewChangedEventArgs_Vtbl {
        unsafe extern "system" fn IsSourceZoomedInView<Impl: ISemanticZoomViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSourceZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSourceZoomedInView<Impl: ISemanticZoomViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSourceZoomedInView(value).into()
        }
        unsafe extern "system" fn SourceItem<Impl: ISemanticZoomViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceItem<Impl: ISemanticZoomViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceItem(&*(&value as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DestinationItem<Impl: ISemanticZoomViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DestinationItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationItem<Impl: ISemanticZoomViewChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationItem(&*(&value as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISemanticZoomViewChangedEventArgs, BASE_OFFSET>(),
            IsSourceZoomedInView: IsSourceZoomedInView::<Impl, IMPL_OFFSET>,
            SetIsSourceZoomedInView: SetIsSourceZoomedInView::<Impl, IMPL_OFFSET>,
            SourceItem: SourceItem::<Impl, IMPL_OFFSET>,
            SetSourceItem: SetSourceItem::<Impl, IMPL_OFFSET>,
            DestinationItem: DestinationItem::<Impl, IMPL_OFFSET>,
            SetDestinationItem: SetDestinationItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISemanticZoomViewChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ISettingsFlyout_Impl: Sized {
    fn Title(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTitle(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn HeaderBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHeaderBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HeaderForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHeaderForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IconSource(&mut self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetIconSource(&mut self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::SettingsFlyoutTemplateSettings>;
    fn BackClick(&mut self, handler: &::core::option::Option<BackClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBackClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Show(&mut self) -> ::windows::core::Result<()>;
    fn ShowIndependent(&mut self) -> ::windows::core::Result<()>;
    fn Hide(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISettingsFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyout";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ISettingsFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISettingsFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISettingsFlyout_Vtbl {
        unsafe extern "system" fn Title<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderBackground<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderBackground<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderForeground<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderForeground<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IconSource<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackClick<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackClick(&*(&handler as *const <BackClickEventHandler as ::windows::core::Abi>::Abi as *const <BackClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBackClick<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBackClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Show<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Show().into()
        }
        unsafe extern "system" fn ShowIndependent<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowIndependent().into()
        }
        unsafe extern "system" fn Hide<Impl: ISettingsFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISettingsFlyout, BASE_OFFSET>(),
            Title: Title::<Impl, IMPL_OFFSET>,
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            HeaderBackground: HeaderBackground::<Impl, IMPL_OFFSET>,
            SetHeaderBackground: SetHeaderBackground::<Impl, IMPL_OFFSET>,
            HeaderForeground: HeaderForeground::<Impl, IMPL_OFFSET>,
            SetHeaderForeground: SetHeaderForeground::<Impl, IMPL_OFFSET>,
            IconSource: IconSource::<Impl, IMPL_OFFSET>,
            SetIconSource: SetIconSource::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            BackClick: BackClick::<Impl, IMPL_OFFSET>,
            RemoveBackClick: RemoveBackClick::<Impl, IMPL_OFFSET>,
            Show: Show::<Impl, IMPL_OFFSET>,
            ShowIndependent: ShowIndependent::<Impl, IMPL_OFFSET>,
            Hide: Hide::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISettingsFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISettingsFlyoutFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SettingsFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISettingsFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISettingsFlyoutFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISettingsFlyoutFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISettingsFlyoutFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISettingsFlyoutFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISettingsFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISettingsFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISettingsFlyoutStatics_Impl: Sized {
    fn TitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISettingsFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISettingsFlyoutStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISettingsFlyoutStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISettingsFlyoutStatics_Vtbl {
        unsafe extern "system" fn TitleProperty<Impl: ISettingsFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderBackgroundProperty<Impl: ISettingsFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderForegroundProperty<Impl: ISettingsFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconSourceProperty<Impl: ISettingsFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISettingsFlyoutStatics, BASE_OFFSET>(),
            TitleProperty: TitleProperty::<Impl, IMPL_OFFSET>,
            HeaderBackgroundProperty: HeaderBackgroundProperty::<Impl, IMPL_OFFSET>,
            HeaderForegroundProperty: HeaderForegroundProperty::<Impl, IMPL_OFFSET>,
            IconSourceProperty: IconSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISettingsFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
pub trait ISlider_Impl: Sized {
    fn IntermediateValue(&mut self) -> ::windows::core::Result<f64>;
    fn SetIntermediateValue(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn StepFrequency(&mut self) -> ::windows::core::Result<f64>;
    fn SetStepFrequency(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn SnapsTo(&mut self) -> ::windows::core::Result<Primitives::SliderSnapsTo>;
    fn SetSnapsTo(&mut self, value: Primitives::SliderSnapsTo) -> ::windows::core::Result<()>;
    fn TickFrequency(&mut self) -> ::windows::core::Result<f64>;
    fn SetTickFrequency(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn TickPlacement(&mut self) -> ::windows::core::Result<Primitives::TickPlacement>;
    fn SetTickPlacement(&mut self, value: Primitives::TickPlacement) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn IsDirectionReversed(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDirectionReversed(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsThumbToolTipEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsThumbToolTipEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ThumbToolTipValueConverter(&mut self) -> ::windows::core::Result<super::Data::IValueConverter>;
    fn SetThumbToolTipValueConverter(&mut self, value: &::core::option::Option<super::Data::IValueConverter>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISlider {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISlider";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Data", feature = "implement_exclusive"))]
impl ISlider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISlider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISlider_Vtbl {
        unsafe extern "system" fn IntermediateValue<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IntermediateValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIntermediateValue<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIntermediateValue(value).into()
        }
        unsafe extern "system" fn StepFrequency<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StepFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStepFrequency<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStepFrequency(value).into()
        }
        unsafe extern "system" fn SnapsTo<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SliderSnapsTo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SnapsTo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSnapsTo<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::SliderSnapsTo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSnapsTo(value).into()
        }
        unsafe extern "system" fn TickFrequency<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTickFrequency<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTickFrequency(value).into()
        }
        unsafe extern "system" fn TickPlacement<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::TickPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTickPlacement<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::TickPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTickPlacement(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn IsDirectionReversed<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDirectionReversed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDirectionReversed<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDirectionReversed(value).into()
        }
        unsafe extern "system" fn IsThumbToolTipEnabled<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsThumbToolTipEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsThumbToolTipEnabled<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsThumbToolTipEnabled(value).into()
        }
        unsafe extern "system" fn ThumbToolTipValueConverter<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ThumbToolTipValueConverter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetThumbToolTipValueConverter<Impl: ISlider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetThumbToolTipValueConverter(&*(&value as *const <super::Data::IValueConverter as ::windows::core::Abi>::Abi as *const <super::Data::IValueConverter as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISlider, BASE_OFFSET>(),
            IntermediateValue: IntermediateValue::<Impl, IMPL_OFFSET>,
            SetIntermediateValue: SetIntermediateValue::<Impl, IMPL_OFFSET>,
            StepFrequency: StepFrequency::<Impl, IMPL_OFFSET>,
            SetStepFrequency: SetStepFrequency::<Impl, IMPL_OFFSET>,
            SnapsTo: SnapsTo::<Impl, IMPL_OFFSET>,
            SetSnapsTo: SetSnapsTo::<Impl, IMPL_OFFSET>,
            TickFrequency: TickFrequency::<Impl, IMPL_OFFSET>,
            SetTickFrequency: SetTickFrequency::<Impl, IMPL_OFFSET>,
            TickPlacement: TickPlacement::<Impl, IMPL_OFFSET>,
            SetTickPlacement: SetTickPlacement::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            IsDirectionReversed: IsDirectionReversed::<Impl, IMPL_OFFSET>,
            SetIsDirectionReversed: SetIsDirectionReversed::<Impl, IMPL_OFFSET>,
            IsThumbToolTipEnabled: IsThumbToolTipEnabled::<Impl, IMPL_OFFSET>,
            SetIsThumbToolTipEnabled: SetIsThumbToolTipEnabled::<Impl, IMPL_OFFSET>,
            ThumbToolTipValueConverter: ThumbToolTipValueConverter::<Impl, IMPL_OFFSET>,
            SetThumbToolTipValueConverter: SetThumbToolTipValueConverter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISlider as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISlider2_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISlider2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISlider2";
}
#[cfg(feature = "implement_exclusive")]
impl ISlider2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISlider2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISlider2_Vtbl {
        unsafe extern "system" fn Header<Impl: ISlider2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ISlider2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ISlider2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ISlider2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISlider2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISlider2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Slider>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISliderFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISliderFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISliderFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISliderFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISliderFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderStatics_Impl: Sized {
    fn IntermediateValueProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StepFrequencyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SnapsToProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TickFrequencyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TickPlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsDirectionReversedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsThumbToolTipEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ThumbToolTipValueConverterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISliderStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISliderStatics_Vtbl {
        unsafe extern "system" fn IntermediateValueProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IntermediateValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StepFrequencyProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StepFrequencyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SnapsToProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SnapsToProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TickFrequencyProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickFrequencyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TickPlacementProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TickPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDirectionReversedProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDirectionReversedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsThumbToolTipEnabledProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsThumbToolTipEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ThumbToolTipValueConverterProperty<Impl: ISliderStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ThumbToolTipValueConverterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISliderStatics, BASE_OFFSET>(),
            IntermediateValueProperty: IntermediateValueProperty::<Impl, IMPL_OFFSET>,
            StepFrequencyProperty: StepFrequencyProperty::<Impl, IMPL_OFFSET>,
            SnapsToProperty: SnapsToProperty::<Impl, IMPL_OFFSET>,
            TickFrequencyProperty: TickFrequencyProperty::<Impl, IMPL_OFFSET>,
            TickPlacementProperty: TickPlacementProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            IsDirectionReversedProperty: IsDirectionReversedProperty::<Impl, IMPL_OFFSET>,
            IsThumbToolTipEnabledProperty: IsThumbToolTipEnabledProperty::<Impl, IMPL_OFFSET>,
            ThumbToolTipValueConverterProperty: ThumbToolTipValueConverterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISliderStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderStatics2_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISliderStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISliderStatics2_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ISliderStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ISliderStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISliderStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISliderStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait ISplitButton_Impl: Sized {
    fn Flyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn Command(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Click(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClick(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISplitButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButton";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ISplitButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButton_Vtbl {
        unsafe extern "system" fn Flyout<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Flyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyout<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Click<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Click(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClick<Impl: ISplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButton, BASE_OFFSET>(),
            Flyout: Flyout::<Impl, IMPL_OFFSET>,
            SetFlyout: SetFlyout::<Impl, IMPL_OFFSET>,
            Command: Command::<Impl, IMPL_OFFSET>,
            SetCommand: SetCommand::<Impl, IMPL_OFFSET>,
            CommandParameter: CommandParameter::<Impl, IMPL_OFFSET>,
            SetCommandParameter: SetCommandParameter::<Impl, IMPL_OFFSET>,
            Click: Click::<Impl, IMPL_OFFSET>,
            RemoveClick: RemoveClick::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonAutomationPeer_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonAutomationPeer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonAutomationPeer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonAutomationPeer_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonAutomationPeer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonAutomationPeer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonAutomationPeerFactory_Impl: Sized {
    fn CreateInstance(&mut self, owner: &::core::option::Option<SplitButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonAutomationPeerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonAutomationPeerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonAutomationPeerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitButtonAutomationPeerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <SplitButton as ::windows::core::Abi>::Abi as *const <SplitButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonAutomationPeerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonAutomationPeerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonClickEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonClickEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonClickEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonClickEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonClickEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonClickEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonStatics_Impl: Sized {
    fn FlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitButtonStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitButtonStatics_Vtbl {
        unsafe extern "system" fn FlyoutProperty<Impl: ISplitButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: ISplitButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: ISplitButtonStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitButtonStatics, BASE_OFFSET>(),
            FlyoutProperty: FlyoutProperty::<Impl, IMPL_OFFSET>,
            CommandProperty: CommandProperty::<Impl, IMPL_OFFSET>,
            CommandParameterProperty: CommandParameterProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitButtonStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ISplitView_Impl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn IsPaneOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsPaneOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn OpenPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetOpenPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&mut self) -> ::windows::core::Result<f64>;
    fn SetCompactPaneLength(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn PanePlacement(&mut self) -> ::windows::core::Result<SplitViewPanePlacement>;
    fn SetPanePlacement(&mut self, value: SplitViewPanePlacement) -> ::windows::core::Result<()>;
    fn DisplayMode(&mut self) -> ::windows::core::Result<SplitViewDisplayMode>;
    fn SetDisplayMode(&mut self, value: SplitViewDisplayMode) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::SplitViewTemplateSettings>;
    fn PaneBackground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPaneBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PaneClosing(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosing(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISplitView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ISplitView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitView_Vtbl {
        unsafe extern "system" fn Content<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPaneOpen<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneOpen<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsPaneOpen(value).into()
        }
        unsafe extern "system" fn OpenPaneLength<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpenPaneLength<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpenPaneLength(value).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactPaneLength<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCompactPaneLength(value).into()
        }
        unsafe extern "system" fn PanePlacement<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SplitViewPanePlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanePlacement<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SplitViewPanePlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanePlacement(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SplitViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SplitViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneBackground<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneBackground<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPaneBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosing<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosing<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosed<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneClosed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosed<Impl: ISplitView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitView, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            Pane: Pane::<Impl, IMPL_OFFSET>,
            SetPane: SetPane::<Impl, IMPL_OFFSET>,
            IsPaneOpen: IsPaneOpen::<Impl, IMPL_OFFSET>,
            SetIsPaneOpen: SetIsPaneOpen::<Impl, IMPL_OFFSET>,
            OpenPaneLength: OpenPaneLength::<Impl, IMPL_OFFSET>,
            SetOpenPaneLength: SetOpenPaneLength::<Impl, IMPL_OFFSET>,
            CompactPaneLength: CompactPaneLength::<Impl, IMPL_OFFSET>,
            SetCompactPaneLength: SetCompactPaneLength::<Impl, IMPL_OFFSET>,
            PanePlacement: PanePlacement::<Impl, IMPL_OFFSET>,
            SetPanePlacement: SetPanePlacement::<Impl, IMPL_OFFSET>,
            DisplayMode: DisplayMode::<Impl, IMPL_OFFSET>,
            SetDisplayMode: SetDisplayMode::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            PaneBackground: PaneBackground::<Impl, IMPL_OFFSET>,
            SetPaneBackground: SetPaneBackground::<Impl, IMPL_OFFSET>,
            PaneClosing: PaneClosing::<Impl, IMPL_OFFSET>,
            RemovePaneClosing: RemovePaneClosing::<Impl, IMPL_OFFSET>,
            PaneClosed: PaneClosed::<Impl, IMPL_OFFSET>,
            RemovePaneClosed: RemovePaneClosed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitView2_Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView2";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitView2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitView2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitView2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ISplitView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ISplitView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitView2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ISplitView3_Impl: Sized {
    fn PaneOpening(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpened(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISplitView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ISplitView3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitView3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitView3_Vtbl {
        unsafe extern "system" fn PaneOpening<Impl: ISplitView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpening(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpening<Impl: ISplitView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpened<Impl: ISplitView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneOpened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpened<Impl: ISplitView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaneOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitView3, BASE_OFFSET>(),
            PaneOpening: PaneOpening::<Impl, IMPL_OFFSET>,
            RemovePaneOpening: RemovePaneOpening::<Impl, IMPL_OFFSET>,
            PaneOpened: PaneOpened::<Impl, IMPL_OFFSET>,
            RemovePaneOpened: RemovePaneOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitView3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewPaneClosingEventArgs_Impl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewPaneClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewPaneClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewPaneClosingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewPaneClosingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewPaneClosingEventArgs_Vtbl {
        unsafe extern "system" fn Cancel<Impl: ISplitViewPaneClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ISplitViewPaneClosingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewPaneClosingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewPaneClosingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewStatics_Impl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpenPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PanePlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneBackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewStatics_Vtbl {
        unsafe extern "system" fn ContentProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneOpenProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsPaneOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenPaneLengthProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanePlacementProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneBackgroundProperty<Impl: ISplitViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaneBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            PaneProperty: PaneProperty::<Impl, IMPL_OFFSET>,
            IsPaneOpenProperty: IsPaneOpenProperty::<Impl, IMPL_OFFSET>,
            OpenPaneLengthProperty: OpenPaneLengthProperty::<Impl, IMPL_OFFSET>,
            CompactPaneLengthProperty: CompactPaneLengthProperty::<Impl, IMPL_OFFSET>,
            PanePlacementProperty: PanePlacementProperty::<Impl, IMPL_OFFSET>,
            DisplayModeProperty: DisplayModeProperty::<Impl, IMPL_OFFSET>,
            TemplateSettingsProperty: TemplateSettingsProperty::<Impl, IMPL_OFFSET>,
            PaneBackgroundProperty: PaneBackgroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewStatics2_Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISplitViewStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISplitViewStatics2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ISplitViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISplitViewStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISplitViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel_Impl: Sized {
    fn AreScrollSnapPointsRegular(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreScrollSnapPointsRegular(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanel_Vtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegular<Impl: IStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegular() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreScrollSnapPointsRegular<Impl: IStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreScrollSnapPointsRegular(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel, BASE_OFFSET>(),
            AreScrollSnapPointsRegular: AreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            SetAreScrollSnapPointsRegular: SetAreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IStackPanel2_Impl: Sized {
    fn BorderBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&mut self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&mut self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IStackPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IStackPanel2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanel2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanel2_Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IStackPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel2, BASE_OFFSET>(),
            BorderBrush: BorderBrush::<Impl, IMPL_OFFSET>,
            SetBorderBrush: SetBorderBrush::<Impl, IMPL_OFFSET>,
            BorderThickness: BorderThickness::<Impl, IMPL_OFFSET>,
            SetBorderThickness: SetBorderThickness::<Impl, IMPL_OFFSET>,
            CornerRadius: CornerRadius::<Impl, IMPL_OFFSET>,
            SetCornerRadius: SetCornerRadius::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel4_Impl: Sized {
    fn Spacing(&mut self) -> ::windows::core::Result<f64>;
    fn SetSpacing(&mut self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel4";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanel4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanel4_Vtbl {
        unsafe extern "system" fn Spacing<Impl: IStackPanel4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Spacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSpacing<Impl: IStackPanel4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSpacing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel4, BASE_OFFSET>(),
            Spacing: Spacing::<Impl, IMPL_OFFSET>,
            SetSpacing: SetSpacing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel5_Impl: Sized {
    fn BackgroundSizing(&mut self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&mut self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel5";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanel5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanel5_Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IStackPanel5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IStackPanel5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanel5, BASE_OFFSET>(),
            BackgroundSizing: BackgroundSizing::<Impl, IMPL_OFFSET>,
            SetBackgroundSizing: SetBackgroundSizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanel5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<StackPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IStackPanelFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics_Impl: Sized {
    fn AreScrollSnapPointsRegularProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStatics_Vtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegularProperty<Impl: IStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegularProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics, BASE_OFFSET>(),
            AreScrollSnapPointsRegularProperty: AreScrollSnapPointsRegularProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics2_Impl: Sized {
    fn BorderBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStatics2_Vtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IStackPanelStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IStackPanelStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IStackPanelStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IStackPanelStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics2, BASE_OFFSET>(),
            BorderBrushProperty: BorderBrushProperty::<Impl, IMPL_OFFSET>,
            BorderThicknessProperty: BorderThicknessProperty::<Impl, IMPL_OFFSET>,
            CornerRadiusProperty: CornerRadiusProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics4_Impl: Sized {
    fn SpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStatics4_Vtbl {
        unsafe extern "system" fn SpacingProperty<Impl: IStackPanelStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics4, BASE_OFFSET>(),
            SpacingProperty: SpacingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics5_Impl: Sized {
    fn BackgroundSizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStackPanelStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStackPanelStatics5_Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IStackPanelStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStackPanelStatics5, BASE_OFFSET>(),
            BackgroundSizingProperty: BackgroundSizingProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStackPanelStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelector_Impl: Sized {
    fn SelectStyle(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::Style>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelector_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStyleSelector_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStyleSelector_Vtbl {
        unsafe extern "system" fn SelectStyle<Impl: IStyleSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectStyle(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IStyleSelector, BASE_OFFSET>(), SelectStyle: SelectStyle::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStyleSelector as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<StyleSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStyleSelectorFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStyleSelectorFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IStyleSelectorFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStyleSelectorFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStyleSelectorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorOverrides_Impl: Sized {
    fn SelectStyleCore(&mut self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::Style>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStyleSelectorOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStyleSelectorOverrides_Vtbl {
        unsafe extern "system" fn SelectStyleCore<Impl: IStyleSelectorOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectStyleCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IStyleSelectorOverrides, BASE_OFFSET>(),
            SelectStyleCore: SelectStyleCore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStyleSelectorOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainBackgroundPanel_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainBackgroundPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainBackgroundPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainBackgroundPanel_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainBackgroundPanel, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainBackgroundPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Core", feature = "implement_exclusive"))]
pub trait ISwapChainBackgroundPanel2_Impl: Sized {
    fn CreateCoreIndependentInputSource(&mut self, devicetypes: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<super::super::Core::CoreIndependentInputSource>;
}
#[cfg(all(feature = "UI_Core", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel2";
}
#[cfg(all(feature = "UI_Core", feature = "implement_exclusive"))]
impl ISwapChainBackgroundPanel2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainBackgroundPanel2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainBackgroundPanel2_Vtbl {
        unsafe extern "system" fn CreateCoreIndependentInputSource<Impl: ISwapChainBackgroundPanel2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, devicetypes: super::super::Core::CoreInputDeviceTypes, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateCoreIndependentInputSource(devicetypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainBackgroundPanel2, BASE_OFFSET>(),
            CreateCoreIndependentInputSource: CreateCoreIndependentInputSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainBackgroundPanel2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainBackgroundPanelFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwapChainBackgroundPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainBackgroundPanelFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainBackgroundPanelFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainBackgroundPanelFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwapChainBackgroundPanelFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainBackgroundPanelFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainBackgroundPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Core", feature = "implement_exclusive"))]
pub trait ISwapChainPanel_Impl: Sized {
    fn CompositionScaleX(&mut self) -> ::windows::core::Result<f32>;
    fn CompositionScaleY(&mut self) -> ::windows::core::Result<f32>;
    fn CompositionScaleChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCompositionScaleChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CreateCoreIndependentInputSource(&mut self, devicetypes: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<super::super::Core::CoreIndependentInputSource>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Core", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISwapChainPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanel";
}
#[cfg(all(feature = "Foundation", feature = "UI_Core", feature = "implement_exclusive"))]
impl ISwapChainPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainPanel_Vtbl {
        unsafe extern "system" fn CompositionScaleX<Impl: ISwapChainPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleX() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleY<Impl: ISwapChainPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleY() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleChanged<Impl: ISwapChainPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCompositionScaleChanged<Impl: ISwapChainPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCompositionScaleChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CreateCoreIndependentInputSource<Impl: ISwapChainPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, devicetypes: super::super::Core::CoreInputDeviceTypes, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateCoreIndependentInputSource(devicetypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainPanel, BASE_OFFSET>(),
            CompositionScaleX: CompositionScaleX::<Impl, IMPL_OFFSET>,
            CompositionScaleY: CompositionScaleY::<Impl, IMPL_OFFSET>,
            CompositionScaleChanged: CompositionScaleChanged::<Impl, IMPL_OFFSET>,
            RemoveCompositionScaleChanged: RemoveCompositionScaleChanged::<Impl, IMPL_OFFSET>,
            CreateCoreIndependentInputSource: CreateCoreIndependentInputSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainPanelFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwapChainPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainPanelFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainPanelFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainPanelFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwapChainPanelFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainPanelFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainPanelStatics_Impl: Sized {
    fn CompositionScaleXProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompositionScaleYProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainPanelStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwapChainPanelStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwapChainPanelStatics_Vtbl {
        unsafe extern "system" fn CompositionScaleXProperty<Impl: ISwapChainPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleXProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleYProperty<Impl: ISwapChainPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompositionScaleYProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwapChainPanelStatics, BASE_OFFSET>(),
            CompositionScaleXProperty: CompositionScaleXProperty::<Impl, IMPL_OFFSET>,
            CompositionScaleYProperty: CompositionScaleYProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwapChainPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControl_Impl: Sized {
    fn LeftItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetLeftItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn RightItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetRightItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn TopItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetTopItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn BottomItems(&mut self) -> ::windows::core::Result<SwipeItems>;
    fn SetBottomItems(&mut self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControl";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeControl_Vtbl {
        unsafe extern "system" fn LeftItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeftItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRightItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TopItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BottomItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBottomItems<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBottomItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Close<Impl: ISwipeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeControl, BASE_OFFSET>(),
            LeftItems: LeftItems::<Impl, IMPL_OFFSET>,
            SetLeftItems: SetLeftItems::<Impl, IMPL_OFFSET>,
            RightItems: RightItems::<Impl, IMPL_OFFSET>,
            SetRightItems: SetRightItems::<Impl, IMPL_OFFSET>,
            TopItems: TopItems::<Impl, IMPL_OFFSET>,
            SetTopItems: SetTopItems::<Impl, IMPL_OFFSET>,
            BottomItems: BottomItems::<Impl, IMPL_OFFSET>,
            SetBottomItems: SetBottomItems::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeControlFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeControlFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeControlFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlStatics_Impl: Sized {
    fn LeftItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BottomItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeControlStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeControlStatics_Vtbl {
        unsafe extern "system" fn LeftItemsProperty<Impl: ISwipeControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LeftItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightItemsProperty<Impl: ISwipeControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RightItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopItemsProperty<Impl: ISwipeControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TopItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BottomItemsProperty<Impl: ISwipeControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BottomItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeControlStatics, BASE_OFFSET>(),
            LeftItemsProperty: LeftItemsProperty::<Impl, IMPL_OFFSET>,
            RightItemsProperty: RightItemsProperty::<Impl, IMPL_OFFSET>,
            TopItemsProperty: TopItemsProperty::<Impl, IMPL_OFFSET>,
            BottomItemsProperty: BottomItemsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ISwipeItem_Impl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IconSource(&mut self) -> ::windows::core::Result<IconSource>;
    fn SetIconSource(&mut self, value: &::core::option::Option<IconSource>) -> ::windows::core::Result<()>;
    fn Background(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn Command(&mut self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&mut self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn BehaviorOnInvoked(&mut self) -> ::windows::core::Result<SwipeBehaviorOnInvoked>;
    fn SetBehaviorOnInvoked(&mut self, value: SwipeBehaviorOnInvoked) -> ::windows::core::Result<()>;
    fn Invoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ISwipeItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItem";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ISwipeItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItem_Vtbl {
        unsafe extern "system" fn Text<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IconSource<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <IconSource as ::windows::core::Abi>::Abi as *const <IconSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Foreground<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BehaviorOnInvoked<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SwipeBehaviorOnInvoked) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BehaviorOnInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBehaviorOnInvoked<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SwipeBehaviorOnInvoked) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBehaviorOnInvoked(value).into()
        }
        unsafe extern "system" fn Invoked<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Invoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveInvoked<Impl: ISwipeItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItem, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            IconSource: IconSource::<Impl, IMPL_OFFSET>,
            SetIconSource: SetIconSource::<Impl, IMPL_OFFSET>,
            Background: Background::<Impl, IMPL_OFFSET>,
            SetBackground: SetBackground::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            Command: Command::<Impl, IMPL_OFFSET>,
            SetCommand: SetCommand::<Impl, IMPL_OFFSET>,
            CommandParameter: CommandParameter::<Impl, IMPL_OFFSET>,
            SetCommandParameter: SetCommandParameter::<Impl, IMPL_OFFSET>,
            BehaviorOnInvoked: BehaviorOnInvoked::<Impl, IMPL_OFFSET>,
            SetBehaviorOnInvoked: SetBehaviorOnInvoked::<Impl, IMPL_OFFSET>,
            Invoked: Invoked::<Impl, IMPL_OFFSET>,
            RemoveInvoked: RemoveInvoked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemInvokedEventArgs_Impl: Sized {
    fn SwipeControl(&mut self) -> ::windows::core::Result<SwipeControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemInvokedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemInvokedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemInvokedEventArgs_Vtbl {
        unsafe extern "system" fn SwipeControl<Impl: ISwipeItemInvokedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SwipeControl() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemInvokedEventArgs, BASE_OFFSET>(),
            SwipeControl: SwipeControl::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemInvokedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemStatics_Impl: Sized {
    fn IconSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BehaviorOnInvokedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemStatics_Vtbl {
        unsafe extern "system" fn IconSourceProperty<Impl: ISwipeItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: ISwipeItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: ISwipeItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: ISwipeItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: ISwipeItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: ISwipeItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BehaviorOnInvokedProperty<Impl: ISwipeItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BehaviorOnInvokedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemStatics, BASE_OFFSET>(),
            IconSourceProperty: IconSourceProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            BackgroundProperty: BackgroundProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            CommandProperty: CommandProperty::<Impl, IMPL_OFFSET>,
            CommandParameterProperty: CommandParameterProperty::<Impl, IMPL_OFFSET>,
            BehaviorOnInvokedProperty: BehaviorOnInvokedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItems_Impl: Sized {
    fn Mode(&mut self) -> ::windows::core::Result<SwipeMode>;
    fn SetMode(&mut self, value: SwipeMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItems {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItems";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItems_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItems_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItems_Vtbl {
        unsafe extern "system" fn Mode<Impl: ISwipeItems_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut SwipeMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: ISwipeItems_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: SwipeMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItems, BASE_OFFSET>(),
            Mode: Mode::<Impl, IMPL_OFFSET>,
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItems as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeItems>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemsFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemsFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeItemsFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemsFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsStatics_Impl: Sized {
    fn ModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISwipeItemsStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISwipeItemsStatics_Vtbl {
        unsafe extern "system" fn ModeProperty<Impl: ISwipeItemsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISwipeItemsStatics, BASE_OFFSET>(), ModeProperty: ModeProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISwipeItemsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIcon_Impl: Sized {
    fn Symbol(&mut self) -> ::windows::core::Result<Symbol>;
    fn SetSymbol(&mut self, value: Symbol) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIcon";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIcon_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIcon_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIcon_Vtbl {
        unsafe extern "system" fn Symbol<Impl: ISymbolIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Symbol() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbol<Impl: ISymbolIcon_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSymbol(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIcon, BASE_OFFSET>(),
            Symbol: Symbol::<Impl, IMPL_OFFSET>,
            SetSymbol: SetSymbol::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIcon as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconFactory_Impl: Sized {
    fn CreateInstanceWithSymbol(&mut self, symbol: Symbol) -> ::windows::core::Result<SymbolIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconFactory_Vtbl {
        unsafe extern "system" fn CreateInstanceWithSymbol<Impl: ISymbolIconFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symbol: Symbol, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithSymbol(symbol) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconFactory, BASE_OFFSET>(),
            CreateInstanceWithSymbol: CreateInstanceWithSymbol::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSource_Impl: Sized {
    fn Symbol(&mut self) -> ::windows::core::Result<Symbol>;
    fn SetSymbol(&mut self, value: Symbol) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSource";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconSource_Vtbl {
        unsafe extern "system" fn Symbol<Impl: ISymbolIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Symbol() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbol<Impl: ISymbolIconSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSymbol(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconSource, BASE_OFFSET>(),
            Symbol: Symbol::<Impl, IMPL_OFFSET>,
            SetSymbol: SetSymbol::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SymbolIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconSourceFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconSourceFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISymbolIconSourceFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconSourceFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconSourceFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceStatics_Impl: Sized {
    fn SymbolProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconSourceStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconSourceStatics_Vtbl {
        unsafe extern "system" fn SymbolProperty<Impl: ISymbolIconSourceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SymbolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconSourceStatics, BASE_OFFSET>(),
            SymbolProperty: SymbolProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconSourceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconStatics_Impl: Sized {
    fn SymbolProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISymbolIconStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISymbolIconStatics_Vtbl {
        unsafe extern "system" fn SymbolProperty<Impl: ISymbolIconStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SymbolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ISymbolIconStatics, BASE_OFFSET>(), SymbolProperty: SymbolProperty::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISymbolIconStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBlock_Impl: Sized {
    fn FontSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&mut self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&mut self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&mut self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&mut self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&mut self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&mut self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&mut self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&mut self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&mut self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn TextTrimming(&mut self) -> ::windows::core::Result<super::TextTrimming>;
    fn SetTextTrimming(&mut self, value: super::TextTrimming) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Inlines(&mut self) -> ::windows::core::Result<super::Documents::InlineCollection>;
    fn Padding(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&mut self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn LineHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&mut self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&mut self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn IsTextSelectionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextSelectionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn SelectedText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ContentStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionStart(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionEnd(&mut self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn Select(&mut self, start: &::core::option::Option<super::Documents::TextPointer>, end: &::core::option::Option<super::Documents::TextPointer>) -> ::windows::core::Result<()>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Text", feature = "UI_Xaml_Documents", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBlock_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock_Vtbl {
        unsafe extern "system" fn FontSize<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn TextTrimming<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimming() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextTrimming<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextTrimming(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn Text<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Inlines<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Inlines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Padding<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineHeight<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn IsTextSelectionEnabled<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSelectionEnabled<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextSelectionEnabled(value).into()
        }
        unsafe extern "system" fn SelectedText<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionStart<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionEnd<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn Select<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: ::windows::core::RawPtr, end: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Select(&*(&start as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType), &*(&end as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Focus<Impl: ITextBlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock, BASE_OFFSET>(),
            FontSize: FontSize::<Impl, IMPL_OFFSET>,
            SetFontSize: SetFontSize::<Impl, IMPL_OFFSET>,
            FontFamily: FontFamily::<Impl, IMPL_OFFSET>,
            SetFontFamily: SetFontFamily::<Impl, IMPL_OFFSET>,
            FontWeight: FontWeight::<Impl, IMPL_OFFSET>,
            SetFontWeight: SetFontWeight::<Impl, IMPL_OFFSET>,
            FontStyle: FontStyle::<Impl, IMPL_OFFSET>,
            SetFontStyle: SetFontStyle::<Impl, IMPL_OFFSET>,
            FontStretch: FontStretch::<Impl, IMPL_OFFSET>,
            SetFontStretch: SetFontStretch::<Impl, IMPL_OFFSET>,
            CharacterSpacing: CharacterSpacing::<Impl, IMPL_OFFSET>,
            SetCharacterSpacing: SetCharacterSpacing::<Impl, IMPL_OFFSET>,
            Foreground: Foreground::<Impl, IMPL_OFFSET>,
            SetForeground: SetForeground::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            TextTrimming: TextTrimming::<Impl, IMPL_OFFSET>,
            SetTextTrimming: SetTextTrimming::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            Inlines: Inlines::<Impl, IMPL_OFFSET>,
            Padding: Padding::<Impl, IMPL_OFFSET>,
            SetPadding: SetPadding::<Impl, IMPL_OFFSET>,
            LineHeight: LineHeight::<Impl, IMPL_OFFSET>,
            SetLineHeight: SetLineHeight::<Impl, IMPL_OFFSET>,
            LineStackingStrategy: LineStackingStrategy::<Impl, IMPL_OFFSET>,
            SetLineStackingStrategy: SetLineStackingStrategy::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabled: IsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextSelectionEnabled: SetIsTextSelectionEnabled::<Impl, IMPL_OFFSET>,
            SelectedText: SelectedText::<Impl, IMPL_OFFSET>,
            ContentStart: ContentStart::<Impl, IMPL_OFFSET>,
            ContentEnd: ContentEnd::<Impl, IMPL_OFFSET>,
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionEnd: SelectionEnd::<Impl, IMPL_OFFSET>,
            BaselineOffset: BaselineOffset::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            Select: Select::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBlock2_Impl: Sized {
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn MaxLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TextLineBounds(&mut self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&mut self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
    fn OpticalMarginAlignment(&mut self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&mut self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock2";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBlock2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock2_Vtbl {
        unsafe extern "system" fn SelectionHighlightColor<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxLines<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        unsafe extern "system" fn OpticalMarginAlignment<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: ITextBlock2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock2, BASE_OFFSET>(),
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            MaxLines: MaxLines::<Impl, IMPL_OFFSET>,
            SetMaxLines: SetMaxLines::<Impl, IMPL_OFFSET>,
            TextLineBounds: TextLineBounds::<Impl, IMPL_OFFSET>,
            SetTextLineBounds: SetTextLineBounds::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignment: OpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            SetOpticalMarginAlignment: SetOpticalMarginAlignment::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock3_Impl: Sized {
    fn IsTextScaleFactorEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock3_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: ITextBlock3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: ITextBlock3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock3, BASE_OFFSET>(),
            IsTextScaleFactorEnabled: IsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextScaleFactorEnabled: SetIsTextScaleFactorEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
pub trait ITextBlock4_Impl: Sized {
    fn GetAlphaMask(&mut self) -> ::windows::core::Result<super::super::Composition::CompositionBrush>;
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock4";
}
#[cfg(all(feature = "UI_Composition", feature = "implement_exclusive"))]
impl ITextBlock4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock4_Vtbl {
        unsafe extern "system" fn GetAlphaMask<Impl: ITextBlock4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlphaMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock4, BASE_OFFSET>(), GetAlphaMask: GetAlphaMask::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
pub trait ITextBlock5_Impl: Sized {
    fn TextDecorations(&mut self) -> ::windows::core::Result<super::super::Text::TextDecorations>;
    fn SetTextDecorations(&mut self, value: super::super::Text::TextDecorations) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock5";
}
#[cfg(all(feature = "UI_Text", feature = "implement_exclusive"))]
impl ITextBlock5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock5_Vtbl {
        unsafe extern "system" fn TextDecorations<Impl: ITextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorations() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextDecorations<Impl: ITextBlock5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextDecorations(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock5, BASE_OFFSET>(),
            TextDecorations: TextDecorations::<Impl, IMPL_OFFSET>,
            SetTextDecorations: SetTextDecorations::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
pub trait ITextBlock6_Impl: Sized {
    fn IsTextTrimmed(&mut self) -> ::windows::core::Result<bool>;
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextHighlighters(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Documents::TextHighlighter>>;
    fn IsTextTrimmedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock6";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Documents", feature = "implement_exclusive"))]
impl ITextBlock6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock6_Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: ITextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignment<Impl: ITextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: ITextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn TextHighlighters<Impl: ITextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextHighlighters() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: ITextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: ITextBlock6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock6, BASE_OFFSET>(),
            IsTextTrimmed: IsTextTrimmed::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            TextHighlighters: TextHighlighters::<Impl, IMPL_OFFSET>,
            IsTextTrimmedChanged: IsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsTextTrimmedChanged: RemoveIsTextTrimmedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait ITextBlock7_Impl: Sized {
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBlock7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock7";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ITextBlock7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlock7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlock7_Vtbl {
        unsafe extern "system" fn SelectionFlyout<Impl: ITextBlock7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: ITextBlock7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: ITextBlock7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlock7, BASE_OFFSET>(),
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            CopySelectionToClipboard: CopySelectionToClipboard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlock7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics_Impl: Sized {
    fn FontSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextTrimmingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSelectionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics_Vtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextTrimmingProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextTrimmingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSelectionEnabledProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedTextProperty<Impl: ITextBlockStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics, BASE_OFFSET>(),
            FontSizeProperty: FontSizeProperty::<Impl, IMPL_OFFSET>,
            FontFamilyProperty: FontFamilyProperty::<Impl, IMPL_OFFSET>,
            FontWeightProperty: FontWeightProperty::<Impl, IMPL_OFFSET>,
            FontStyleProperty: FontStyleProperty::<Impl, IMPL_OFFSET>,
            FontStretchProperty: FontStretchProperty::<Impl, IMPL_OFFSET>,
            CharacterSpacingProperty: CharacterSpacingProperty::<Impl, IMPL_OFFSET>,
            ForegroundProperty: ForegroundProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            TextTrimmingProperty: TextTrimmingProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            PaddingProperty: PaddingProperty::<Impl, IMPL_OFFSET>,
            LineHeightProperty: LineHeightProperty::<Impl, IMPL_OFFSET>,
            LineStackingStrategyProperty: LineStackingStrategyProperty::<Impl, IMPL_OFFSET>,
            IsTextSelectionEnabledProperty: IsTextSelectionEnabledProperty::<Impl, IMPL_OFFSET>,
            SelectedTextProperty: SelectedTextProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics2_Impl: Sized {
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLinesProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpticalMarginAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics2_Vtbl {
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: ITextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLinesProperty<Impl: ITextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: ITextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: ITextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: ITextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: ITextBlockStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics2, BASE_OFFSET>(),
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            MaxLinesProperty: MaxLinesProperty::<Impl, IMPL_OFFSET>,
            TextLineBoundsProperty: TextLineBoundsProperty::<Impl, IMPL_OFFSET>,
            OpticalMarginAlignmentProperty: OpticalMarginAlignmentProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics3_Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics3_Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: ITextBlockStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics3, BASE_OFFSET>(),
            IsTextScaleFactorEnabledProperty: IsTextScaleFactorEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics5_Impl: Sized {
    fn TextDecorationsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics5_Vtbl {
        unsafe extern "system" fn TextDecorationsProperty<Impl: ITextBlockStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextDecorationsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics5, BASE_OFFSET>(),
            TextDecorationsProperty: TextDecorationsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics6_Impl: Sized {
    fn IsTextTrimmedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics6_Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: ITextBlockStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: ITextBlockStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics6, BASE_OFFSET>(),
            IsTextTrimmedProperty: IsTextTrimmedProperty::<Impl, IMPL_OFFSET>,
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics7_Impl: Sized {
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBlockStatics7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBlockStatics7_Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: ITextBlockStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBlockStatics7, BASE_OFFSET>(),
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBlockStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
pub trait ITextBox_Impl: Sized {
    fn Text(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectedText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSelectedText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectionLength(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn SelectionStart(&mut self) -> ::windows::core::Result<i32>;
    fn SetSelectionStart(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn MaxLength(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn IsReadOnly(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn AcceptsReturn(&mut self) -> ::windows::core::Result<bool>;
    fn SetAcceptsReturn(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextWrapping(&mut self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&mut self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn IsSpellCheckEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsSpellCheckEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsTextPredictionEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsTextPredictionEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn InputScope(&mut self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&mut self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
    fn TextChanged(&mut self, handler: &::core::option::Option<TextChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectionChanged(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&mut self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Select(&mut self, start: i32, length: i32) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn GetRectFromCharacterIndex(&mut self, charindex: i32, trailingedge: bool) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Input", feature = "implement_exclusive"))]
impl ITextBox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox_Vtbl {
        unsafe extern "system" fn Text<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedText<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedText<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionLength<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionLength<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionLength(value).into()
        }
        unsafe extern "system" fn SelectionStart<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionStart<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionStart(value).into()
        }
        unsafe extern "system" fn MaxLength<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        unsafe extern "system" fn IsReadOnly<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn AcceptsReturn<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAcceptsReturn<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAcceptsReturn(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn IsSpellCheckEnabled<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSpellCheckEnabled<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsSpellCheckEnabled(value).into()
        }
        unsafe extern "system" fn IsTextPredictionEnabled<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextPredictionEnabled<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsTextPredictionEnabled(value).into()
        }
        unsafe extern "system" fn InputScope<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <TextChangedEventHandler as ::windows::core::Abi>::Abi as *const <TextChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Select<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: i32, length: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Select(start, length).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn GetRectFromCharacterIndex<Impl: ITextBox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, charindex: i32, trailingedge: bool, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRectFromCharacterIndex(charindex, trailingedge) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox, BASE_OFFSET>(),
            Text: Text::<Impl, IMPL_OFFSET>,
            SetText: SetText::<Impl, IMPL_OFFSET>,
            SelectedText: SelectedText::<Impl, IMPL_OFFSET>,
            SetSelectedText: SetSelectedText::<Impl, IMPL_OFFSET>,
            SelectionLength: SelectionLength::<Impl, IMPL_OFFSET>,
            SetSelectionLength: SetSelectionLength::<Impl, IMPL_OFFSET>,
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SetSelectionStart: SetSelectionStart::<Impl, IMPL_OFFSET>,
            MaxLength: MaxLength::<Impl, IMPL_OFFSET>,
            SetMaxLength: SetMaxLength::<Impl, IMPL_OFFSET>,
            IsReadOnly: IsReadOnly::<Impl, IMPL_OFFSET>,
            SetIsReadOnly: SetIsReadOnly::<Impl, IMPL_OFFSET>,
            AcceptsReturn: AcceptsReturn::<Impl, IMPL_OFFSET>,
            SetAcceptsReturn: SetAcceptsReturn::<Impl, IMPL_OFFSET>,
            TextAlignment: TextAlignment::<Impl, IMPL_OFFSET>,
            SetTextAlignment: SetTextAlignment::<Impl, IMPL_OFFSET>,
            TextWrapping: TextWrapping::<Impl, IMPL_OFFSET>,
            SetTextWrapping: SetTextWrapping::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabled: IsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            SetIsSpellCheckEnabled: SetIsSpellCheckEnabled::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabled: IsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            SetIsTextPredictionEnabled: SetIsTextPredictionEnabled::<Impl, IMPL_OFFSET>,
            InputScope: InputScope::<Impl, IMPL_OFFSET>,
            SetInputScope: SetInputScope::<Impl, IMPL_OFFSET>,
            TextChanged: TextChanged::<Impl, IMPL_OFFSET>,
            RemoveTextChanged: RemoveTextChanged::<Impl, IMPL_OFFSET>,
            SelectionChanged: SelectionChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanged: RemoveSelectionChanged::<Impl, IMPL_OFFSET>,
            ContextMenuOpening: ContextMenuOpening::<Impl, IMPL_OFFSET>,
            RemoveContextMenuOpening: RemoveContextMenuOpening::<Impl, IMPL_OFFSET>,
            Select: Select::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            GetRectFromCharacterIndex: GetRectFromCharacterIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBox2_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&mut self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&mut self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox2";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBox2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox2_Vtbl {
        unsafe extern "system" fn Header<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn Paste<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: ITextBox2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox2, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            PlaceholderText: PlaceholderText::<Impl, IMPL_OFFSET>,
            SetPlaceholderText: SetPlaceholderText::<Impl, IMPL_OFFSET>,
            SelectionHighlightColor: SelectionHighlightColor::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColor: SetSelectionHighlightColor::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus: PreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus: SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, IMPL_OFFSET>,
            IsColorFontEnabled: IsColorFontEnabled::<Impl, IMPL_OFFSET>,
            SetIsColorFontEnabled: SetIsColorFontEnabled::<Impl, IMPL_OFFSET>,
            Paste: Paste::<Impl, IMPL_OFFSET>,
            RemovePaste: RemovePaste::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITextBox3_Impl: Sized {
    fn TextCompositionStarted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionStarted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionEnded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionEnded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&mut self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&mut self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn DesiredCandidateWindowAlignment(&mut self) -> ::windows::core::Result<CandidateWindowAlignment>;
    fn SetDesiredCandidateWindowAlignment(&mut self, value: CandidateWindowAlignment) -> ::windows::core::Result<()>;
    fn CandidateWindowBoundsChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidateWindowBoundsChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITextBox3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox3_Vtbl {
        unsafe extern "system" fn TextCompositionStarted<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionStarted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionStarted<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionChanged<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionChanged<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionEnded<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextCompositionEnded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionEnded<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn DesiredCandidateWindowAlignment<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDesiredCandidateWindowAlignment<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDesiredCandidateWindowAlignment(value).into()
        }
        unsafe extern "system" fn CandidateWindowBoundsChanged<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CandidateWindowBoundsChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidateWindowBoundsChanged<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCandidateWindowBoundsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanging<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanging<Impl: ITextBox3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox3, BASE_OFFSET>(),
            TextCompositionStarted: TextCompositionStarted::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionStarted: RemoveTextCompositionStarted::<Impl, IMPL_OFFSET>,
            TextCompositionChanged: TextCompositionChanged::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionChanged: RemoveTextCompositionChanged::<Impl, IMPL_OFFSET>,
            TextCompositionEnded: TextCompositionEnded::<Impl, IMPL_OFFSET>,
            RemoveTextCompositionEnded: RemoveTextCompositionEnded::<Impl, IMPL_OFFSET>,
            TextReadingOrder: TextReadingOrder::<Impl, IMPL_OFFSET>,
            SetTextReadingOrder: SetTextReadingOrder::<Impl, IMPL_OFFSET>,
            DesiredCandidateWindowAlignment: DesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            SetDesiredCandidateWindowAlignment: SetDesiredCandidateWindowAlignment::<Impl, IMPL_OFFSET>,
            CandidateWindowBoundsChanged: CandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            RemoveCandidateWindowBoundsChanged: RemoveCandidateWindowBoundsChanged::<Impl, IMPL_OFFSET>,
            TextChanging: TextChanging::<Impl, IMPL_OFFSET>,
            RemoveTextChanging: RemoveTextChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITextBox4_Impl: Sized {
    fn GetLinguisticAlternativesAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITextBox4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox4_Vtbl {
        unsafe extern "system" fn GetLinguisticAlternativesAsync<Impl: ITextBox4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLinguisticAlternativesAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox4, BASE_OFFSET>(),
            GetLinguisticAlternativesAsync: GetLinguisticAlternativesAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBox5_Impl: Sized {
    fn SelectionHighlightColorWhenNotFocused(&mut self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColorWhenNotFocused(&mut self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox5";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBox5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox5_Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocused<Impl: ITextBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColorWhenNotFocused<Impl: ITextBox5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColorWhenNotFocused(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocused: SelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
            SetSelectionHighlightColorWhenNotFocused: SetSelectionHighlightColorWhenNotFocused::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITextBox6_Impl: Sized {
    fn HorizontalTextAlignment(&mut self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&mut self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn CharacterCasing(&mut self) -> ::windows::core::Result<CharacterCasing>;
    fn SetCharacterCasing(&mut self, value: CharacterCasing) -> ::windows::core::Result<()>;
    fn PlaceholderForeground(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPlaceholderForeground(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CopyingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCopyingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CuttingToClipboard(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCuttingToClipboard(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn BeforeTextChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBeforeTextChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox6";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITextBox6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox6_Vtbl {
        unsafe extern "system" fn HorizontalTextAlignment<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn CharacterCasing<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterCasing<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCharacterCasing(value).into()
        }
        unsafe extern "system" fn PlaceholderForeground<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderForeground<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaceholderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopyingToClipboard<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CopyingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCopyingToClipboard<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCopyingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CuttingToClipboard<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CuttingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCuttingToClipboard<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCuttingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BeforeTextChanging<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BeforeTextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBeforeTextChanging<Impl: ITextBox6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBeforeTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox6, BASE_OFFSET>(),
            HorizontalTextAlignment: HorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalTextAlignment: SetHorizontalTextAlignment::<Impl, IMPL_OFFSET>,
            CharacterCasing: CharacterCasing::<Impl, IMPL_OFFSET>,
            SetCharacterCasing: SetCharacterCasing::<Impl, IMPL_OFFSET>,
            PlaceholderForeground: PlaceholderForeground::<Impl, IMPL_OFFSET>,
            SetPlaceholderForeground: SetPlaceholderForeground::<Impl, IMPL_OFFSET>,
            CopyingToClipboard: CopyingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCopyingToClipboard: RemoveCopyingToClipboard::<Impl, IMPL_OFFSET>,
            CuttingToClipboard: CuttingToClipboard::<Impl, IMPL_OFFSET>,
            RemoveCuttingToClipboard: RemoveCuttingToClipboard::<Impl, IMPL_OFFSET>,
            BeforeTextChanging: BeforeTextChanging::<Impl, IMPL_OFFSET>,
            RemoveBeforeTextChanging: RemoveBeforeTextChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox7_Impl: Sized {
    fn HandwritingView(&mut self) -> ::windows::core::Result<HandwritingView>;
    fn SetHandwritingView(&mut self, value: &::core::option::Option<HandwritingView>) -> ::windows::core::Result<()>;
    fn IsHandwritingViewEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsHandwritingViewEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox7_Vtbl {
        unsafe extern "system" fn HandwritingView<Impl: ITextBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandwritingView<Impl: ITextBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandwritingView(&*(&value as *const <HandwritingView as ::windows::core::Abi>::Abi as *const <HandwritingView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHandwritingViewEnabled<Impl: ITextBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHandwritingViewEnabled<Impl: ITextBox7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsHandwritingViewEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox7, BASE_OFFSET>(),
            HandwritingView: HandwritingView::<Impl, IMPL_OFFSET>,
            SetHandwritingView: SetHandwritingView::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabled: IsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
            SetIsHandwritingViewEnabled: SetIsHandwritingViewEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox7 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait ITextBox8_Impl: Sized {
    fn CanPasteClipboardContent(&mut self) -> ::windows::core::Result<bool>;
    fn CanUndo(&mut self) -> ::windows::core::Result<bool>;
    fn CanRedo(&mut self) -> ::windows::core::Result<bool>;
    fn SelectionFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&mut self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn ProofingMenuFlyout(&mut self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn Description(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectionChanging(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanging(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Undo(&mut self) -> ::windows::core::Result<()>;
    fn Redo(&mut self) -> ::windows::core::Result<()>;
    fn PasteFromClipboard(&mut self) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
    fn CutSelectionToClipboard(&mut self) -> ::windows::core::Result<()>;
    fn ClearUndoRedoHistory(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITextBox8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox8";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ITextBox8_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBox8_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBox8_Vtbl {
        unsafe extern "system" fn CanPasteClipboardContent<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUndo<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanUndo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanRedo<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanRedo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ProofingMenuFlyout<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanging<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanging<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Undo<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Undo().into()
        }
        unsafe extern "system" fn Redo<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Redo().into()
        }
        unsafe extern "system" fn PasteFromClipboard<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PasteFromClipboard().into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        unsafe extern "system" fn CutSelectionToClipboard<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CutSelectionToClipboard().into()
        }
        unsafe extern "system" fn ClearUndoRedoHistory<Impl: ITextBox8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearUndoRedoHistory().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBox8, BASE_OFFSET>(),
            CanPasteClipboardContent: CanPasteClipboardContent::<Impl, IMPL_OFFSET>,
            CanUndo: CanUndo::<Impl, IMPL_OFFSET>,
            CanRedo: CanRedo::<Impl, IMPL_OFFSET>,
            SelectionFlyout: SelectionFlyout::<Impl, IMPL_OFFSET>,
            SetSelectionFlyout: SetSelectionFlyout::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyout: ProofingMenuFlyout::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            SelectionChanging: SelectionChanging::<Impl, IMPL_OFFSET>,
            RemoveSelectionChanging: RemoveSelectionChanging::<Impl, IMPL_OFFSET>,
            Undo: Undo::<Impl, IMPL_OFFSET>,
            Redo: Redo::<Impl, IMPL_OFFSET>,
            PasteFromClipboard: PasteFromClipboard::<Impl, IMPL_OFFSET>,
            CopySelectionToClipboard: CopySelectionToClipboard::<Impl, IMPL_OFFSET>,
            CutSelectionToClipboard: CutSelectionToClipboard::<Impl, IMPL_OFFSET>,
            ClearUndoRedoHistory: ClearUndoRedoHistory::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBox8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxBeforeTextChangingEventArgs_Impl: Sized {
    fn NewText(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxBeforeTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxBeforeTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxBeforeTextChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxBeforeTextChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxBeforeTextChangingEventArgs_Vtbl {
        unsafe extern "system" fn NewText<Impl: ITextBoxBeforeTextChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ITextBoxBeforeTextChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITextBoxBeforeTextChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxBeforeTextChangingEventArgs, BASE_OFFSET>(),
            NewText: NewText::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxBeforeTextChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TextBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITextBoxFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxSelectionChangingEventArgs_Impl: Sized {
    fn SelectionStart(&mut self) -> ::windows::core::Result<i32>;
    fn SelectionLength(&mut self) -> ::windows::core::Result<i32>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxSelectionChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxSelectionChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxSelectionChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxSelectionChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxSelectionChangingEventArgs_Vtbl {
        unsafe extern "system" fn SelectionStart<Impl: ITextBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionLength<Impl: ITextBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ITextBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITextBoxSelectionChangingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxSelectionChangingEventArgs, BASE_OFFSET>(),
            SelectionStart: SelectionStart::<Impl, IMPL_OFFSET>,
            SelectionLength: SelectionLength::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxSelectionChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics_Impl: Sized {
    fn TextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsReadOnlyProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AcceptsReturnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSpellCheckEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextPredictionEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics_Vtbl {
        unsafe extern "system" fn TextProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsReadOnlyProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptsReturnProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AcceptsReturnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSpellCheckEnabledProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextPredictionEnabledProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: ITextBoxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics, BASE_OFFSET>(),
            TextProperty: TextProperty::<Impl, IMPL_OFFSET>,
            MaxLengthProperty: MaxLengthProperty::<Impl, IMPL_OFFSET>,
            IsReadOnlyProperty: IsReadOnlyProperty::<Impl, IMPL_OFFSET>,
            AcceptsReturnProperty: AcceptsReturnProperty::<Impl, IMPL_OFFSET>,
            TextAlignmentProperty: TextAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextWrappingProperty: TextWrappingProperty::<Impl, IMPL_OFFSET>,
            IsSpellCheckEnabledProperty: IsSpellCheckEnabledProperty::<Impl, IMPL_OFFSET>,
            IsTextPredictionEnabledProperty: IsTextPredictionEnabledProperty::<Impl, IMPL_OFFSET>,
            InputScopeProperty: InputScopeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics2_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics2_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ITextBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ITextBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ITextBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: ITextBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: ITextBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: ITextBoxStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics2, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            PlaceholderTextProperty: PlaceholderTextProperty::<Impl, IMPL_OFFSET>,
            SelectionHighlightColorProperty: SelectionHighlightColorProperty::<Impl, IMPL_OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocusProperty: PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, IMPL_OFFSET>,
            IsColorFontEnabledProperty: IsColorFontEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics3_Impl: Sized {
    fn DesiredCandidateWindowAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics3_Vtbl {
        unsafe extern "system" fn DesiredCandidateWindowAlignmentProperty<Impl: ITextBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: ITextBoxStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics3, BASE_OFFSET>(),
            DesiredCandidateWindowAlignmentProperty: DesiredCandidateWindowAlignmentProperty::<Impl, IMPL_OFFSET>,
            TextReadingOrderProperty: TextReadingOrderProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics5_Impl: Sized {
    fn SelectionHighlightColorWhenNotFocusedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics5_Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocusedProperty<Impl: ITextBoxStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocusedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics5, BASE_OFFSET>(),
            SelectionHighlightColorWhenNotFocusedProperty: SelectionHighlightColorWhenNotFocusedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics6_Impl: Sized {
    fn HorizontalTextAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterCasingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderForegroundProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics6_Vtbl {
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: ITextBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterCasingProperty<Impl: ITextBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CharacterCasingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderForegroundProperty<Impl: ITextBoxStatics6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlaceholderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics6, BASE_OFFSET>(),
            HorizontalTextAlignmentProperty: HorizontalTextAlignmentProperty::<Impl, IMPL_OFFSET>,
            CharacterCasingProperty: CharacterCasingProperty::<Impl, IMPL_OFFSET>,
            PlaceholderForegroundProperty: PlaceholderForegroundProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics6 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics7_Impl: Sized {
    fn HandwritingViewProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHandwritingViewEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics7_Vtbl {
        unsafe extern "system" fn HandwritingViewProperty<Impl: ITextBoxStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HandwritingViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHandwritingViewEnabledProperty<Impl: ITextBoxStatics7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics7, BASE_OFFSET>(),
            HandwritingViewProperty: HandwritingViewProperty::<Impl, IMPL_OFFSET>,
            IsHandwritingViewEnabledProperty: IsHandwritingViewEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics8_Impl: Sized {
    fn CanPasteClipboardContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanUndoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanRedoProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProofingMenuFlyoutProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics8";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics8_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxStatics8_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxStatics8_Vtbl {
        unsafe extern "system" fn CanPasteClipboardContentProperty<Impl: ITextBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUndoProperty<Impl: ITextBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanUndoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanRedoProperty<Impl: ITextBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanRedoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: ITextBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProofingMenuFlyoutProperty<Impl: ITextBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: ITextBoxStatics8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxStatics8, BASE_OFFSET>(),
            CanPasteClipboardContentProperty: CanPasteClipboardContentProperty::<Impl, IMPL_OFFSET>,
            CanUndoProperty: CanUndoProperty::<Impl, IMPL_OFFSET>,
            CanRedoProperty: CanRedoProperty::<Impl, IMPL_OFFSET>,
            SelectionFlyoutProperty: SelectionFlyoutProperty::<Impl, IMPL_OFFSET>,
            ProofingMenuFlyoutProperty: ProofingMenuFlyoutProperty::<Impl, IMPL_OFFSET>,
            DescriptionProperty: DescriptionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxStatics8 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxTextChangingEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxTextChangingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxTextChangingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxTextChangingEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxTextChangingEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxTextChangingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxTextChangingEventArgs2_Impl: Sized {
    fn IsContentChanging(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxTextChangingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxTextChangingEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextBoxTextChangingEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextBoxTextChangingEventArgs2_Vtbl {
        unsafe extern "system" fn IsContentChanging<Impl: ITextBoxTextChangingEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextBoxTextChangingEventArgs2, BASE_OFFSET>(),
            IsContentChanging: IsContentChanging::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextBoxTextChangingEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextChangedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextChangedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextChangedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCommandBarFlyout_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCommandBarFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCommandBarFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCommandBarFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCommandBarFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCommandBarFlyout_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCommandBarFlyout, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCommandBarFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCommandBarFlyoutFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TextCommandBarFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCommandBarFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCommandBarFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCommandBarFlyoutFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCommandBarFlyoutFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCommandBarFlyoutFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITextCommandBarFlyoutFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCommandBarFlyoutFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCommandBarFlyoutFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionChangedEventArgs_Impl: Sized {
    fn StartIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Length(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCompositionChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCompositionChangedEventArgs_Vtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCompositionChangedEventArgs, BASE_OFFSET>(),
            StartIndex: StartIndex::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCompositionChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionEndedEventArgs_Impl: Sized {
    fn StartIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Length(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionEndedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionEndedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionEndedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCompositionEndedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCompositionEndedEventArgs_Vtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionEndedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionEndedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCompositionEndedEventArgs, BASE_OFFSET>(),
            StartIndex: StartIndex::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCompositionEndedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionStartedEventArgs_Impl: Sized {
    fn StartIndex(&mut self) -> ::windows::core::Result<i32>;
    fn Length(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionStartedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionStartedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionStartedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextCompositionStartedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextCompositionStartedEventArgs_Vtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionStartedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionStartedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextCompositionStartedEventArgs, BASE_OFFSET>(),
            StartIndex: StartIndex::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextCompositionStartedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlCopyingToClipboardEventArgs_Impl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlCopyingToClipboardEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlCopyingToClipboardEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlCopyingToClipboardEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextControlCopyingToClipboardEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextControlCopyingToClipboardEventArgs_Vtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlCopyingToClipboardEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlCopyingToClipboardEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextControlCopyingToClipboardEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextControlCopyingToClipboardEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlCuttingToClipboardEventArgs_Impl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlCuttingToClipboardEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlCuttingToClipboardEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlCuttingToClipboardEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextControlCuttingToClipboardEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextControlCuttingToClipboardEventArgs_Vtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlCuttingToClipboardEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlCuttingToClipboardEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextControlCuttingToClipboardEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextControlCuttingToClipboardEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlPasteEventArgs_Impl: Sized {
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlPasteEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlPasteEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlPasteEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITextControlPasteEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITextControlPasteEventArgs_Vtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlPasteEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlPasteEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITextControlPasteEventArgs, BASE_OFFSET>(),
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITextControlPasteEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickedEventArgs_Impl: Sized {
    fn OldTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn NewTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickedEventArgs_Vtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickedEventArgs, BASE_OFFSET>(),
            OldTime: OldTime::<Impl, IMPL_OFFSET>,
            NewTime: NewTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePicker_Impl: Sized {
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ClockIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetClockIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MinuteIncrement(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinuteIncrement(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn Time(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetTime(&mut self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn TimeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTimeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePicker_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePicker_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePicker_Vtbl {
        unsafe extern "system" fn Header<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ClockIdentifier<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockIdentifier<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClockIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinuteIncrement<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinuteIncrement<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinuteIncrement(value).into()
        }
        unsafe extern "system" fn Time<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Time() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTime(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TimeChanged<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimeChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTimeChanged<Impl: ITimePicker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTimeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePicker, BASE_OFFSET>(),
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            ClockIdentifier: ClockIdentifier::<Impl, IMPL_OFFSET>,
            SetClockIdentifier: SetClockIdentifier::<Impl, IMPL_OFFSET>,
            MinuteIncrement: MinuteIncrement::<Impl, IMPL_OFFSET>,
            SetMinuteIncrement: SetMinuteIncrement::<Impl, IMPL_OFFSET>,
            Time: Time::<Impl, IMPL_OFFSET>,
            SetTime: SetTime::<Impl, IMPL_OFFSET>,
            TimeChanged: TimeChanged::<Impl, IMPL_OFFSET>,
            RemoveTimeChanged: RemoveTimeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePicker as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePicker2_Impl: Sized {
    fn LightDismissOverlayMode(&mut self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&mut self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePicker2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePicker2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePicker2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ITimePicker2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ITimePicker2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePicker2, BASE_OFFSET>(),
            LightDismissOverlayMode: LightDismissOverlayMode::<Impl, IMPL_OFFSET>,
            SetLightDismissOverlayMode: SetLightDismissOverlayMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePicker2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePicker3_Impl: Sized {
    fn SelectedTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
    fn SetSelectedTime(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>) -> ::windows::core::Result<()>;
    fn SelectedTimeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedTimeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePicker3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePicker3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePicker3_Vtbl {
        unsafe extern "system" fn SelectedTime<Impl: ITimePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedTime<Impl: ITimePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedTime(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedTimeChanged<Impl: ITimePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTimeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedTimeChanged<Impl: ITimePicker3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSelectedTimeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePicker3, BASE_OFFSET>(),
            SelectedTime: SelectedTime::<Impl, IMPL_OFFSET>,
            SetSelectedTime: SetSelectedTime::<Impl, IMPL_OFFSET>,
            SelectedTimeChanged: SelectedTimeChanged::<Impl, IMPL_OFFSET>,
            RemoveSelectedTimeChanged: RemoveSelectedTimeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePicker3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TimePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITimePickerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickerFlyout_Impl: Sized {
    fn ClockIdentifier(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetClockIdentifier(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Time(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetTime(&mut self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn MinuteIncrement(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinuteIncrement(&mut self, value: i32) -> ::windows::core::Result<()>;
    fn TimePicked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTimePicked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&mut self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyout";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickerFlyout_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyout_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyout_Vtbl {
        unsafe extern "system" fn ClockIdentifier<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockIdentifier<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClockIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Time<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Time() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTime(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinuteIncrement<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinuteIncrement<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinuteIncrement(value).into()
        }
        unsafe extern "system" fn TimePicked<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimePicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTimePicked<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTimePicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: ITimePickerFlyout_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyout, BASE_OFFSET>(),
            ClockIdentifier: ClockIdentifier::<Impl, IMPL_OFFSET>,
            SetClockIdentifier: SetClockIdentifier::<Impl, IMPL_OFFSET>,
            Time: Time::<Impl, IMPL_OFFSET>,
            SetTime: SetTime::<Impl, IMPL_OFFSET>,
            MinuteIncrement: MinuteIncrement::<Impl, IMPL_OFFSET>,
            SetMinuteIncrement: SetMinuteIncrement::<Impl, IMPL_OFFSET>,
            TimePicked: TimePicked::<Impl, IMPL_OFFSET>,
            RemoveTimePicked: RemoveTimePicked::<Impl, IMPL_OFFSET>,
            ShowAtAsync: ShowAtAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyout as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenter_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutPresenter_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutPresenter, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenter2_Impl: Sized {
    fn IsDefaultShadowEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutPresenter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutPresenter2_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: ITimePickerFlyoutPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: ITimePickerFlyoutPresenter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutPresenter2, BASE_OFFSET>(),
            IsDefaultShadowEnabled: IsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
            SetIsDefaultShadowEnabled: SetIsDefaultShadowEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutPresenter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenterStatics2_Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenterStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutPresenterStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutPresenterStatics2_Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: ITimePickerFlyoutPresenterStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutPresenterStatics2, BASE_OFFSET>(),
            IsDefaultShadowEnabledProperty: IsDefaultShadowEnabledProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutPresenterStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutStatics_Impl: Sized {
    fn ClockIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TimeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinuteIncrementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerFlyoutStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerFlyoutStatics_Vtbl {
        unsafe extern "system" fn ClockIdentifierProperty<Impl: ITimePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeProperty<Impl: ITimePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinuteIncrementProperty<Impl: ITimePickerFlyoutStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerFlyoutStatics, BASE_OFFSET>(),
            ClockIdentifierProperty: ClockIdentifierProperty::<Impl, IMPL_OFFSET>,
            TimeProperty: TimeProperty::<Impl, IMPL_OFFSET>,
            MinuteIncrementProperty: MinuteIncrementProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerFlyoutStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickerSelectedValueChangedEventArgs_Impl: Sized {
    fn OldTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
    fn NewTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickerSelectedValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerSelectedValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickerSelectedValueChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerSelectedValueChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerSelectedValueChangedEventArgs_Vtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickerSelectedValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickerSelectedValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerSelectedValueChangedEventArgs, BASE_OFFSET>(),
            OldTime: OldTime::<Impl, IMPL_OFFSET>,
            NewTime: NewTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerSelectedValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStatics_Impl: Sized {
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ClockIdentifierProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinuteIncrementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TimeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerStatics_Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ITimePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ITimePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClockIdentifierProperty<Impl: ITimePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClockIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinuteIncrementProperty<Impl: ITimePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinuteIncrementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeProperty<Impl: ITimePickerStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerStatics, BASE_OFFSET>(),
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            ClockIdentifierProperty: ClockIdentifierProperty::<Impl, IMPL_OFFSET>,
            MinuteIncrementProperty: MinuteIncrementProperty::<Impl, IMPL_OFFSET>,
            TimeProperty: TimeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStatics2_Impl: Sized {
    fn LightDismissOverlayModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerStatics2_Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ITimePickerStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerStatics2, BASE_OFFSET>(),
            LightDismissOverlayModeProperty: LightDismissOverlayModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStatics3_Impl: Sized {
    fn SelectedTimeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerStatics3_Vtbl {
        unsafe extern "system" fn SelectedTimeProperty<Impl: ITimePickerStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedTimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerStatics3, BASE_OFFSET>(),
            SelectedTimeProperty: SelectedTimeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITimePickerValueChangedEventArgs_Impl: Sized {
    fn OldTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn NewTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITimePickerValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerValueChangedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITimePickerValueChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITimePickerValueChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITimePickerValueChangedEventArgs_Vtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickerValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickerValueChangedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITimePickerValueChangedEventArgs, BASE_OFFSET>(),
            OldTime: OldTime::<Impl, IMPL_OFFSET>,
            NewTime: NewTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITimePickerValueChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItem_Impl: Sized {
    fn IsChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleMenuFlyoutItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleMenuFlyoutItem_Vtbl {
        unsafe extern "system" fn IsChecked<Impl: IToggleMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IToggleMenuFlyoutItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleMenuFlyoutItem, BASE_OFFSET>(),
            IsChecked: IsChecked::<Impl, IMPL_OFFSET>,
            SetIsChecked: SetIsChecked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleMenuFlyoutItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleMenuFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleMenuFlyoutItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleMenuFlyoutItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleMenuFlyoutItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleMenuFlyoutItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleMenuFlyoutItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemStatics_Impl: Sized {
    fn IsCheckedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleMenuFlyoutItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleMenuFlyoutItemStatics_Vtbl {
        unsafe extern "system" fn IsCheckedProperty<Impl: IToggleMenuFlyoutItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleMenuFlyoutItemStatics, BASE_OFFSET>(),
            IsCheckedProperty: IsCheckedProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleMenuFlyoutItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IToggleSplitButton_Impl: Sized {
    fn IsChecked(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsCheckedChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsCheckedChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToggleSplitButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButton";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IToggleSplitButton_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButton_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButton_Vtbl {
        unsafe extern "system" fn IsChecked<Impl: IToggleSplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IToggleSplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        unsafe extern "system" fn IsCheckedChanged<Impl: IToggleSplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsCheckedChanged<Impl: IToggleSplitButton_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveIsCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButton, BASE_OFFSET>(),
            IsChecked: IsChecked::<Impl, IMPL_OFFSET>,
            SetIsChecked: SetIsChecked::<Impl, IMPL_OFFSET>,
            IsCheckedChanged: IsCheckedChanged::<Impl, IMPL_OFFSET>,
            RemoveIsCheckedChanged: RemoveIsCheckedChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButton as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonAutomationPeer_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonAutomationPeer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonAutomationPeer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonAutomationPeer_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonAutomationPeer, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonAutomationPeer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonAutomationPeerFactory_Impl: Sized {
    fn CreateInstance(&mut self, owner: &::core::option::Option<ToggleSplitButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleSplitButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonAutomationPeerFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonAutomationPeerFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonAutomationPeerFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleSplitButtonAutomationPeerFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <ToggleSplitButton as ::windows::core::Abi>::Abi as *const <ToggleSplitButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonAutomationPeerFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonAutomationPeerFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleSplitButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleSplitButtonFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonIsCheckedChangedEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonIsCheckedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonIsCheckedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonIsCheckedChangedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSplitButtonIsCheckedChangedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSplitButtonIsCheckedChangedEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSplitButtonIsCheckedChangedEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSplitButtonIsCheckedChangedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IToggleSwitch_Impl: Sized {
    fn IsOn(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOn(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Header(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContent(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetOnContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetOnContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OffContent(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetOffContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OffContentTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetOffContentTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ToggleSwitchTemplateSettings>;
    fn Toggled(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveToggled(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToggleSwitch {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitch";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IToggleSwitch_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSwitch_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSwitch_Vtbl {
        unsafe extern "system" fn IsOn<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOn<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOn(value).into()
        }
        unsafe extern "system" fn Header<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContent<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOnContent<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOnContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplate<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOnContentTemplate<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOnContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OffContent<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOffContent<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOffContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OffContentTemplate<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOffContentTemplate<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOffContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Toggled<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Toggled(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveToggled<Impl: IToggleSwitch_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveToggled(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSwitch, BASE_OFFSET>(),
            IsOn: IsOn::<Impl, IMPL_OFFSET>,
            SetIsOn: SetIsOn::<Impl, IMPL_OFFSET>,
            Header: Header::<Impl, IMPL_OFFSET>,
            SetHeader: SetHeader::<Impl, IMPL_OFFSET>,
            HeaderTemplate: HeaderTemplate::<Impl, IMPL_OFFSET>,
            SetHeaderTemplate: SetHeaderTemplate::<Impl, IMPL_OFFSET>,
            OnContent: OnContent::<Impl, IMPL_OFFSET>,
            SetOnContent: SetOnContent::<Impl, IMPL_OFFSET>,
            OnContentTemplate: OnContentTemplate::<Impl, IMPL_OFFSET>,
            SetOnContentTemplate: SetOnContentTemplate::<Impl, IMPL_OFFSET>,
            OffContent: OffContent::<Impl, IMPL_OFFSET>,
            SetOffContent: SetOffContent::<Impl, IMPL_OFFSET>,
            OffContentTemplate: OffContentTemplate::<Impl, IMPL_OFFSET>,
            SetOffContentTemplate: SetOffContentTemplate::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            Toggled: Toggled::<Impl, IMPL_OFFSET>,
            RemoveToggled: RemoveToggled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSwitch as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSwitchOverrides_Impl: Sized {
    fn OnToggled(&mut self) -> ::windows::core::Result<()>;
    fn OnOnContentChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOffContentChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnHeaderChanged(&mut self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSwitchOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitchOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSwitchOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSwitchOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSwitchOverrides_Vtbl {
        unsafe extern "system" fn OnToggled<Impl: IToggleSwitchOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnToggled().into()
        }
        unsafe extern "system" fn OnOnContentChanged<Impl: IToggleSwitchOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOnContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOffContentChanged<Impl: IToggleSwitchOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOffContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnHeaderChanged<Impl: IToggleSwitchOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnHeaderChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSwitchOverrides, BASE_OFFSET>(),
            OnToggled: OnToggled::<Impl, IMPL_OFFSET>,
            OnOnContentChanged: OnOnContentChanged::<Impl, IMPL_OFFSET>,
            OnOffContentChanged: OnOffContentChanged::<Impl, IMPL_OFFSET>,
            OnHeaderChanged: OnHeaderChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSwitchOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSwitchStatics_Impl: Sized {
    fn IsOnProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OnContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OnContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OffContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OffContentTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSwitchStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitchStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSwitchStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToggleSwitchStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToggleSwitchStatics_Vtbl {
        unsafe extern "system" fn IsOnProperty<Impl: IToggleSwitchStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IToggleSwitchStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IToggleSwitchStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnContentProperty<Impl: IToggleSwitchStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnContentTemplateProperty<Impl: IToggleSwitchStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OffContentProperty<Impl: IToggleSwitchStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OffContentTemplateProperty<Impl: IToggleSwitchStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OffContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToggleSwitchStatics, BASE_OFFSET>(),
            IsOnProperty: IsOnProperty::<Impl, IMPL_OFFSET>,
            HeaderProperty: HeaderProperty::<Impl, IMPL_OFFSET>,
            HeaderTemplateProperty: HeaderTemplateProperty::<Impl, IMPL_OFFSET>,
            OnContentProperty: OnContentProperty::<Impl, IMPL_OFFSET>,
            OnContentTemplateProperty: OnContentTemplateProperty::<Impl, IMPL_OFFSET>,
            OffContentProperty: OffContentProperty::<Impl, IMPL_OFFSET>,
            OffContentTemplateProperty: OffContentTemplateProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToggleSwitchStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IToolTip_Impl: Sized {
    fn HorizontalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetHorizontalOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsOpen(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsOpen(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Placement(&mut self) -> ::windows::core::Result<Primitives::PlacementMode>;
    fn SetPlacement(&mut self, value: Primitives::PlacementMode) -> ::windows::core::Result<()>;
    fn PlacementTarget(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn VerticalOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetVerticalOffset(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn TemplateSettings(&mut self) -> ::windows::core::Result<Primitives::ToolTipTemplateSettings>;
    fn Closed(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&mut self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToolTip {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTip";
}
#[cfg(all(feature = "Foundation", feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IToolTip_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTip_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTip_Vtbl {
        unsafe extern "system" fn HorizontalOffset<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalOffset<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalOffset(value).into()
        }
        unsafe extern "system" fn IsOpen<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOpen<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsOpen(value).into()
        }
        unsafe extern "system" fn Placement<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Placement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacement<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacement(value).into()
        }
        unsafe extern "system" fn PlacementTarget<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VerticalOffset<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalOffset<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalOffset(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Closed<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IToolTip_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTip, BASE_OFFSET>(),
            HorizontalOffset: HorizontalOffset::<Impl, IMPL_OFFSET>,
            SetHorizontalOffset: SetHorizontalOffset::<Impl, IMPL_OFFSET>,
            IsOpen: IsOpen::<Impl, IMPL_OFFSET>,
            SetIsOpen: SetIsOpen::<Impl, IMPL_OFFSET>,
            Placement: Placement::<Impl, IMPL_OFFSET>,
            SetPlacement: SetPlacement::<Impl, IMPL_OFFSET>,
            PlacementTarget: PlacementTarget::<Impl, IMPL_OFFSET>,
            SetPlacementTarget: SetPlacementTarget::<Impl, IMPL_OFFSET>,
            VerticalOffset: VerticalOffset::<Impl, IMPL_OFFSET>,
            SetVerticalOffset: SetVerticalOffset::<Impl, IMPL_OFFSET>,
            TemplateSettings: TemplateSettings::<Impl, IMPL_OFFSET>,
            Closed: Closed::<Impl, IMPL_OFFSET>,
            RemoveClosed: RemoveClosed::<Impl, IMPL_OFFSET>,
            Opened: Opened::<Impl, IMPL_OFFSET>,
            RemoveOpened: RemoveOpened::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTip as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IToolTip2_Impl: Sized {
    fn PlacementRect(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::Rect>>;
    fn SetPlacementRect(&mut self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::Rect>>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToolTip2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTip2";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IToolTip2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTip2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTip2_Vtbl {
        unsafe extern "system" fn PlacementRect<Impl: IToolTip2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementRect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementRect<Impl: IToolTip2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementRect(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::Rect> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::Rect> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTip2, BASE_OFFSET>(),
            PlacementRect: PlacementRect::<Impl, IMPL_OFFSET>,
            SetPlacementRect: SetPlacementRect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTip2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToolTip>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToolTipFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipService_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipService {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipService";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipService_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipService, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipService as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IToolTipServiceStatics_Impl: Sized {
    fn PlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetPlacement(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<Primitives::PlacementMode>;
    fn SetPlacement(&mut self, element: &::core::option::Option<super::DependencyObject>, value: Primitives::PlacementMode) -> ::windows::core::Result<()>;
    fn PlacementTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetPlacementTarget(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&mut self, element: &::core::option::Option<super::DependencyObject>, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ToolTipProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetToolTip(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetToolTip(&mut self, element: &::core::option::Option<super::DependencyObject>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IToolTipServiceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipServiceStatics";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IToolTipServiceStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipServiceStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipServiceStatics_Vtbl {
        unsafe extern "system" fn PlacementProperty<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlacement<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPlacement(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacement<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacement(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn PlacementTargetProperty<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlacementTarget<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPlacementTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ToolTipProperty<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ToolTipProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToolTip<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetToolTip(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetToolTip<Impl: IToolTipServiceStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetToolTip(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipServiceStatics, BASE_OFFSET>(),
            PlacementProperty: PlacementProperty::<Impl, IMPL_OFFSET>,
            GetPlacement: GetPlacement::<Impl, IMPL_OFFSET>,
            SetPlacement: SetPlacement::<Impl, IMPL_OFFSET>,
            PlacementTargetProperty: PlacementTargetProperty::<Impl, IMPL_OFFSET>,
            GetPlacementTarget: GetPlacementTarget::<Impl, IMPL_OFFSET>,
            SetPlacementTarget: SetPlacementTarget::<Impl, IMPL_OFFSET>,
            ToolTipProperty: ToolTipProperty::<Impl, IMPL_OFFSET>,
            GetToolTip: GetToolTip::<Impl, IMPL_OFFSET>,
            SetToolTip: SetToolTip::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipServiceStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipStatics_Impl: Sized {
    fn HorizontalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOpenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementTargetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalOffsetProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipStatics_Vtbl {
        unsafe extern "system" fn HorizontalOffsetProperty<Impl: IToolTipStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOpenProperty<Impl: IToolTipStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementProperty<Impl: IToolTipStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementTargetProperty<Impl: IToolTipStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffsetProperty<Impl: IToolTipStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipStatics, BASE_OFFSET>(),
            HorizontalOffsetProperty: HorizontalOffsetProperty::<Impl, IMPL_OFFSET>,
            IsOpenProperty: IsOpenProperty::<Impl, IMPL_OFFSET>,
            PlacementProperty: PlacementProperty::<Impl, IMPL_OFFSET>,
            PlacementTargetProperty: PlacementTargetProperty::<Impl, IMPL_OFFSET>,
            VerticalOffsetProperty: VerticalOffsetProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipStatics2_Impl: Sized {
    fn PlacementRectProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToolTipStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToolTipStatics2_Vtbl {
        unsafe extern "system" fn PlacementRectProperty<Impl: IToolTipStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlacementRectProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IToolTipStatics2, BASE_OFFSET>(),
            PlacementRectProperty: PlacementRectProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToolTipStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeView_Impl: Sized {
    fn RootNodes(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
    fn SelectionMode(&mut self) -> ::windows::core::Result<TreeViewSelectionMode>;
    fn SetSelectionMode(&mut self, value: TreeViewSelectionMode) -> ::windows::core::Result<()>;
    fn SelectedNodes(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
    fn Expand(&mut self, value: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<()>;
    fn Collapse(&mut self, value: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<()>;
    fn SelectAll(&mut self) -> ::windows::core::Result<()>;
    fn ItemInvoked(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemInvoked(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Expanding(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveExpanding(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Collapsed(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCollapsed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeView";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeView_Vtbl {
        unsafe extern "system" fn RootNodes<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RootNodes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TreeViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TreeViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn SelectedNodes<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectedNodes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Expand<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Expand(&*(&value as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Collapse<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Collapse(&*(&value as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn ItemInvoked<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemInvoked<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveItemInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Expanding<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Expanding(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveExpanding<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveExpanding(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Collapsed<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Collapsed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCollapsed<Impl: ITreeView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCollapsed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeView, BASE_OFFSET>(),
            RootNodes: RootNodes::<Impl, IMPL_OFFSET>,
            SelectionMode: SelectionMode::<Impl, IMPL_OFFSET>,
            SetSelectionMode: SetSelectionMode::<Impl, IMPL_OFFSET>,
            SelectedNodes: SelectedNodes::<Impl, IMPL_OFFSET>,
            Expand: Expand::<Impl, IMPL_OFFSET>,
            Collapse: Collapse::<Impl, IMPL_OFFSET>,
            SelectAll: SelectAll::<Impl, IMPL_OFFSET>,
            ItemInvoked: ItemInvoked::<Impl, IMPL_OFFSET>,
            RemoveItemInvoked: RemoveItemInvoked::<Impl, IMPL_OFFSET>,
            Expanding: Expanding::<Impl, IMPL_OFFSET>,
            RemoveExpanding: RemoveExpanding::<Impl, IMPL_OFFSET>,
            Collapsed: Collapsed::<Impl, IMPL_OFFSET>,
            RemoveCollapsed: RemoveCollapsed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
pub trait ITreeView2_Impl: Sized {
    fn NodeFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<TreeViewNode>;
    fn ContainerFromNode(&mut self, node: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<super::DependencyObject>;
    fn ItemFromContainer(&mut self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&mut self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn CanDragItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanDragItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn CanReorderItems(&mut self) -> ::windows::core::Result<bool>;
    fn SetCanReorderItems(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ItemTemplate(&mut self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&mut self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ItemTemplateSelector(&mut self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetItemTemplateSelector(&mut self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerStyle(&mut self) -> ::windows::core::Result<super::Style>;
    fn SetItemContainerStyle(&mut self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ItemContainerStyleSelector(&mut self) -> ::windows::core::Result<StyleSelector>;
    fn SetItemContainerStyleSelector(&mut self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerTransitions(&mut self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetItemContainerTransitions(&mut self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn DragItemsStarting(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DragItemsCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeView2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Media_Animation", feature = "implement_exclusive"))]
impl ITreeView2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeView2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeView2_Vtbl {
        unsafe extern "system" fn NodeFromContainer<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NodeFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromNode<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, node: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromNode(&*(&node as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemFromContainer<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanDragItems<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanDragItems<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanDragItems(value).into()
        }
        unsafe extern "system" fn CanReorderItems<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanReorderItems<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCanReorderItems(value).into()
        }
        unsafe extern "system" fn ItemTemplate<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplateSelector<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplateSelector<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyle<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyle<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyleSelector<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyleSelector<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerTransitions<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerTransitions<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemContainerTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemsSource<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsStarting<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsStarting<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsCompleted<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsCompleted<Impl: ITreeView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeView2, BASE_OFFSET>(),
            NodeFromContainer: NodeFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromNode: ContainerFromNode::<Impl, IMPL_OFFSET>,
            ItemFromContainer: ItemFromContainer::<Impl, IMPL_OFFSET>,
            ContainerFromItem: ContainerFromItem::<Impl, IMPL_OFFSET>,
            CanDragItems: CanDragItems::<Impl, IMPL_OFFSET>,
            SetCanDragItems: SetCanDragItems::<Impl, IMPL_OFFSET>,
            CanReorderItems: CanReorderItems::<Impl, IMPL_OFFSET>,
            SetCanReorderItems: SetCanReorderItems::<Impl, IMPL_OFFSET>,
            ItemTemplate: ItemTemplate::<Impl, IMPL_OFFSET>,
            SetItemTemplate: SetItemTemplate::<Impl, IMPL_OFFSET>,
            ItemTemplateSelector: ItemTemplateSelector::<Impl, IMPL_OFFSET>,
            SetItemTemplateSelector: SetItemTemplateSelector::<Impl, IMPL_OFFSET>,
            ItemContainerStyle: ItemContainerStyle::<Impl, IMPL_OFFSET>,
            SetItemContainerStyle: SetItemContainerStyle::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelector: ItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            SetItemContainerStyleSelector: SetItemContainerStyleSelector::<Impl, IMPL_OFFSET>,
            ItemContainerTransitions: ItemContainerTransitions::<Impl, IMPL_OFFSET>,
            SetItemContainerTransitions: SetItemContainerTransitions::<Impl, IMPL_OFFSET>,
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
            DragItemsStarting: DragItemsStarting::<Impl, IMPL_OFFSET>,
            RemoveDragItemsStarting: RemoveDragItemsStarting::<Impl, IMPL_OFFSET>,
            DragItemsCompleted: DragItemsCompleted::<Impl, IMPL_OFFSET>,
            RemoveDragItemsCompleted: RemoveDragItemsCompleted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewCollapsedEventArgs_Impl: Sized {
    fn Node(&mut self) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewCollapsedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewCollapsedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewCollapsedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewCollapsedEventArgs_Vtbl {
        unsafe extern "system" fn Node<Impl: ITreeViewCollapsedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Node() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewCollapsedEventArgs, BASE_OFFSET>(), Node: Node::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewCollapsedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewCollapsedEventArgs2_Impl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewCollapsedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewCollapsedEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewCollapsedEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewCollapsedEventArgs2_Vtbl {
        unsafe extern "system" fn Item<Impl: ITreeViewCollapsedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewCollapsedEventArgs2, BASE_OFFSET>(), Item: Item::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewCollapsedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeViewDragItemsCompletedEventArgs_Impl: Sized {
    fn DropResult(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackageOperation>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewDragItemsCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewDragItemsCompletedEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeViewDragItemsCompletedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewDragItemsCompletedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewDragItemsCompletedEventArgs_Vtbl {
        unsafe extern "system" fn DropResult<Impl: ITreeViewDragItemsCompletedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::ApplicationModel::DataTransfer::DataPackageOperation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DropResult() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Items<Impl: ITreeViewDragItemsCompletedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewDragItemsCompletedEventArgs, BASE_OFFSET>(),
            DropResult: DropResult::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewDragItemsCompletedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeViewDragItemsStartingEventArgs_Impl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Data(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
    fn Items(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewDragItemsStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewDragItemsStartingEventArgs";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeViewDragItemsStartingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewDragItemsStartingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewDragItemsStartingEventArgs_Vtbl {
        unsafe extern "system" fn Cancel<Impl: ITreeViewDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITreeViewDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn Data<Impl: ITreeViewDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Items<Impl: ITreeViewDragItemsStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewDragItemsStartingEventArgs, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
            Data: Data::<Impl, IMPL_OFFSET>,
            Items: Items::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewDragItemsStartingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewExpandingEventArgs_Impl: Sized {
    fn Node(&mut self) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewExpandingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewExpandingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewExpandingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewExpandingEventArgs_Vtbl {
        unsafe extern "system" fn Node<Impl: ITreeViewExpandingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Node() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewExpandingEventArgs, BASE_OFFSET>(), Node: Node::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewExpandingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewExpandingEventArgs2_Impl: Sized {
    fn Item(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewExpandingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewExpandingEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewExpandingEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewExpandingEventArgs2_Vtbl {
        unsafe extern "system" fn Item<Impl: ITreeViewExpandingEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewExpandingEventArgs2, BASE_OFFSET>(), Item: Item::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewExpandingEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewFactory, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait ITreeViewItem_Impl: Sized {
    fn GlyphOpacity(&mut self) -> ::windows::core::Result<f64>;
    fn SetGlyphOpacity(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn GlyphBrush(&mut self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetGlyphBrush(&mut self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn ExpandedGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetExpandedGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CollapsedGlyph(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCollapsedGlyph(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn GlyphSize(&mut self) -> ::windows::core::Result<f64>;
    fn SetGlyphSize(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn IsExpanded(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExpanded(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn TreeViewItemTemplateSettings(&mut self) -> ::windows::core::Result<TreeViewItemTemplateSettings>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItem";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ITreeViewItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItem_Vtbl {
        unsafe extern "system" fn GlyphOpacity<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphOpacity() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphOpacity<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyphOpacity(value).into()
        }
        unsafe extern "system" fn GlyphBrush<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphBrush<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyphBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ExpandedGlyph<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExpandedGlyph<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetExpandedGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CollapsedGlyph<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCollapsedGlyph<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCollapsedGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GlyphSize<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphSize<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGlyphSize(value).into()
        }
        unsafe extern "system" fn IsExpanded<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpanded() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExpanded<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExpanded(value).into()
        }
        unsafe extern "system" fn TreeViewItemTemplateSettings<Impl: ITreeViewItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TreeViewItemTemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItem, BASE_OFFSET>(),
            GlyphOpacity: GlyphOpacity::<Impl, IMPL_OFFSET>,
            SetGlyphOpacity: SetGlyphOpacity::<Impl, IMPL_OFFSET>,
            GlyphBrush: GlyphBrush::<Impl, IMPL_OFFSET>,
            SetGlyphBrush: SetGlyphBrush::<Impl, IMPL_OFFSET>,
            ExpandedGlyph: ExpandedGlyph::<Impl, IMPL_OFFSET>,
            SetExpandedGlyph: SetExpandedGlyph::<Impl, IMPL_OFFSET>,
            CollapsedGlyph: CollapsedGlyph::<Impl, IMPL_OFFSET>,
            SetCollapsedGlyph: SetCollapsedGlyph::<Impl, IMPL_OFFSET>,
            GlyphSize: GlyphSize::<Impl, IMPL_OFFSET>,
            SetGlyphSize: SetGlyphSize::<Impl, IMPL_OFFSET>,
            IsExpanded: IsExpanded::<Impl, IMPL_OFFSET>,
            SetIsExpanded: SetIsExpanded::<Impl, IMPL_OFFSET>,
            TreeViewItemTemplateSettings: TreeViewItemTemplateSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItem2_Impl: Sized {
    fn HasUnrealizedChildren(&mut self) -> ::windows::core::Result<bool>;
    fn SetHasUnrealizedChildren(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn ItemsSource(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItem2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItem2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItem2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItem2_Vtbl {
        unsafe extern "system" fn HasUnrealizedChildren<Impl: ITreeViewItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHasUnrealizedChildren<Impl: ITreeViewItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHasUnrealizedChildren(value).into()
        }
        unsafe extern "system" fn ItemsSource<Impl: ITreeViewItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: ITreeViewItem2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItem2, BASE_OFFSET>(),
            HasUnrealizedChildren: HasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            SetHasUnrealizedChildren: SetHasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            ItemsSource: ItemsSource::<Impl, IMPL_OFFSET>,
            SetItemsSource: SetItemsSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItem2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewItemFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemInvokedEventArgs_Impl: Sized {
    fn InvokedItem(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemInvokedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemInvokedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemInvokedEventArgs_Vtbl {
        unsafe extern "system" fn InvokedItem<Impl: ITreeViewItemInvokedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITreeViewItemInvokedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn Handled<Impl: ITreeViewItemInvokedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemInvokedEventArgs, BASE_OFFSET>(),
            InvokedItem: InvokedItem::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemInvokedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemStatics_Impl: Sized {
    fn GlyphOpacityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphBrushProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExpandedGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CollapsedGlyphProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphSizeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsExpandedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TreeViewItemTemplateSettingsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemStatics_Vtbl {
        unsafe extern "system" fn GlyphOpacityProperty<Impl: ITreeViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphOpacityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphBrushProperty<Impl: ITreeViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExpandedGlyphProperty<Impl: ITreeViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphProperty<Impl: ITreeViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphSizeProperty<Impl: ITreeViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GlyphSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpandedProperty<Impl: ITreeViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpandedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TreeViewItemTemplateSettingsProperty<Impl: ITreeViewItemStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TreeViewItemTemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemStatics, BASE_OFFSET>(),
            GlyphOpacityProperty: GlyphOpacityProperty::<Impl, IMPL_OFFSET>,
            GlyphBrushProperty: GlyphBrushProperty::<Impl, IMPL_OFFSET>,
            ExpandedGlyphProperty: ExpandedGlyphProperty::<Impl, IMPL_OFFSET>,
            CollapsedGlyphProperty: CollapsedGlyphProperty::<Impl, IMPL_OFFSET>,
            GlyphSizeProperty: GlyphSizeProperty::<Impl, IMPL_OFFSET>,
            IsExpandedProperty: IsExpandedProperty::<Impl, IMPL_OFFSET>,
            TreeViewItemTemplateSettingsProperty: TreeViewItemTemplateSettingsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemStatics2_Impl: Sized {
    fn HasUnrealizedChildrenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemStatics2_Vtbl {
        unsafe extern "system" fn HasUnrealizedChildrenProperty<Impl: ITreeViewItemStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsSourceProperty<Impl: ITreeViewItemStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemStatics2, BASE_OFFSET>(),
            HasUnrealizedChildrenProperty: HasUnrealizedChildrenProperty::<Impl, IMPL_OFFSET>,
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettings_Impl: Sized {
    fn ExpandedGlyphVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn CollapsedGlyphVisibility(&mut self) -> ::windows::core::Result<super::Visibility>;
    fn Indentation(&mut self) -> ::windows::core::Result<super::Thickness>;
    fn DragItemsCount(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettings_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemTemplateSettings_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemTemplateSettings_Vtbl {
        unsafe extern "system" fn ExpandedGlyphVisibility<Impl: ITreeViewItemTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphVisibility<Impl: ITreeViewItemTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Indentation<Impl: ITreeViewItemTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Indentation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DragItemsCount<Impl: ITreeViewItemTemplateSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemTemplateSettings, BASE_OFFSET>(),
            ExpandedGlyphVisibility: ExpandedGlyphVisibility::<Impl, IMPL_OFFSET>,
            CollapsedGlyphVisibility: CollapsedGlyphVisibility::<Impl, IMPL_OFFSET>,
            Indentation: Indentation::<Impl, IMPL_OFFSET>,
            DragItemsCount: DragItemsCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemTemplateSettings as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewItemTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettingsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemTemplateSettingsFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemTemplateSettingsFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewItemTemplateSettingsFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemTemplateSettingsFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemTemplateSettingsFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsStatics_Impl: Sized {
    fn ExpandedGlyphVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CollapsedGlyphVisibilityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IndentationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DragItemsCountProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettingsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewItemTemplateSettingsStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewItemTemplateSettingsStatics_Vtbl {
        unsafe extern "system" fn ExpandedGlyphVisibilityProperty<Impl: ITreeViewItemTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphVisibilityProperty<Impl: ITreeViewItemTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndentationProperty<Impl: ITreeViewItemTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IndentationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DragItemsCountProperty<Impl: ITreeViewItemTemplateSettingsStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DragItemsCountProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewItemTemplateSettingsStatics, BASE_OFFSET>(),
            ExpandedGlyphVisibilityProperty: ExpandedGlyphVisibilityProperty::<Impl, IMPL_OFFSET>,
            CollapsedGlyphVisibilityProperty: CollapsedGlyphVisibilityProperty::<Impl, IMPL_OFFSET>,
            IndentationProperty: IndentationProperty::<Impl, IMPL_OFFSET>,
            DragItemsCountProperty: DragItemsCountProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewItemTemplateSettingsStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewList_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewList {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewList";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewList_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewList, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewListFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewList>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewListFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewListFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewListFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewListFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewListFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewListFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewListFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewListFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait ITreeViewNode_Impl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&mut self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Parent(&mut self) -> ::windows::core::Result<TreeViewNode>;
    fn IsExpanded(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsExpanded(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn HasChildren(&mut self) -> ::windows::core::Result<bool>;
    fn Depth(&mut self) -> ::windows::core::Result<i32>;
    fn HasUnrealizedChildren(&mut self) -> ::windows::core::Result<bool>;
    fn SetHasUnrealizedChildren(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Children(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITreeViewNode {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNode";
}
#[cfg(all(feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ITreeViewNode_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewNode_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewNode_Vtbl {
        unsafe extern "system" fn Content<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Parent<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Parent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpanded<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpanded() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExpanded<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsExpanded(value).into()
        }
        unsafe extern "system" fn HasChildren<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Depth<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Depth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasUnrealizedChildren<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHasUnrealizedChildren<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHasUnrealizedChildren(value).into()
        }
        unsafe extern "system" fn Children<Impl: ITreeViewNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewNode, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
            Parent: Parent::<Impl, IMPL_OFFSET>,
            IsExpanded: IsExpanded::<Impl, IMPL_OFFSET>,
            SetIsExpanded: SetIsExpanded::<Impl, IMPL_OFFSET>,
            HasChildren: HasChildren::<Impl, IMPL_OFFSET>,
            Depth: Depth::<Impl, IMPL_OFFSET>,
            HasUnrealizedChildren: HasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            SetHasUnrealizedChildren: SetHasUnrealizedChildren::<Impl, IMPL_OFFSET>,
            Children: Children::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewNode as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewNodeFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewNodeFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNodeFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewNodeFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewNodeFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewNodeFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewNodeFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewNodeFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewNodeFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewNodeStatics_Impl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DepthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsExpandedProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasChildrenProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewNodeStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNodeStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewNodeStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewNodeStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewNodeStatics_Vtbl {
        unsafe extern "system" fn ContentProperty<Impl: ITreeViewNodeStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DepthProperty<Impl: ITreeViewNodeStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DepthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpandedProperty<Impl: ITreeViewNodeStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsExpandedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasChildrenProperty<Impl: ITreeViewNodeStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewNodeStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
            DepthProperty: DepthProperty::<Impl, IMPL_OFFSET>,
            IsExpandedProperty: IsExpandedProperty::<Impl, IMPL_OFFSET>,
            HasChildrenProperty: HasChildrenProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewNodeStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewStatics_Impl: Sized {
    fn SelectionModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewStatics_Vtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: ITreeViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewStatics, BASE_OFFSET>(),
            SelectionModeProperty: SelectionModeProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewStatics2_Impl: Sized {
    fn CanDragItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanReorderItemsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleSelectorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerTransitionsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsSourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITreeViewStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITreeViewStatics2_Vtbl {
        unsafe extern "system" fn CanDragItemsProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanDragItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanReorderItemsProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanReorderItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateSelectorProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleSelectorProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitionsProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsSourceProperty<Impl: ITreeViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITreeViewStatics2, BASE_OFFSET>(),
            CanDragItemsProperty: CanDragItemsProperty::<Impl, IMPL_OFFSET>,
            CanReorderItemsProperty: CanReorderItemsProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateProperty: ItemTemplateProperty::<Impl, IMPL_OFFSET>,
            ItemTemplateSelectorProperty: ItemTemplateSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleProperty: ItemContainerStyleProperty::<Impl, IMPL_OFFSET>,
            ItemContainerStyleSelectorProperty: ItemContainerStyleSelectorProperty::<Impl, IMPL_OFFSET>,
            ItemContainerTransitionsProperty: ItemContainerTransitionsProperty::<Impl, IMPL_OFFSET>,
            ItemsSourceProperty: ItemsSourceProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITreeViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait ITwoPaneView_Impl: Sized {
    fn Pane1(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane1(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane2(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane2(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane1Length(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetPane1Length(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn Pane2Length(&mut self) -> ::windows::core::Result<super::GridLength>;
    fn SetPane2Length(&mut self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn PanePriority(&mut self) -> ::windows::core::Result<TwoPaneViewPriority>;
    fn SetPanePriority(&mut self, value: TwoPaneViewPriority) -> ::windows::core::Result<()>;
    fn Mode(&mut self) -> ::windows::core::Result<TwoPaneViewMode>;
    fn WideModeConfiguration(&mut self) -> ::windows::core::Result<TwoPaneViewWideModeConfiguration>;
    fn SetWideModeConfiguration(&mut self, value: TwoPaneViewWideModeConfiguration) -> ::windows::core::Result<()>;
    fn TallModeConfiguration(&mut self) -> ::windows::core::Result<TwoPaneViewTallModeConfiguration>;
    fn SetTallModeConfiguration(&mut self, value: TwoPaneViewTallModeConfiguration) -> ::windows::core::Result<()>;
    fn MinWideModeWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinWideModeWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn MinTallModeHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetMinTallModeHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ModeChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveModeChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for ITwoPaneView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneView";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ITwoPaneView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITwoPaneView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITwoPaneView_Vtbl {
        unsafe extern "system" fn Pane1<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane1<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane1(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane2<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane2<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane2(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane1Length<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane1Length<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane1Length(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane2Length<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane2Length<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPane2Length(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PanePriority<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewPriority) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePriority() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanePriority<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewPriority) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanePriority(value).into()
        }
        unsafe extern "system" fn Mode<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WideModeConfiguration<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewWideModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WideModeConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWideModeConfiguration<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewWideModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWideModeConfiguration(value).into()
        }
        unsafe extern "system" fn TallModeConfiguration<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewTallModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TallModeConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTallModeConfiguration<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewTallModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTallModeConfiguration(value).into()
        }
        unsafe extern "system" fn MinWideModeWidth<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWideModeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinWideModeWidth<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinWideModeWidth(value).into()
        }
        unsafe extern "system" fn MinTallModeHeight<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinTallModeHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinTallModeHeight<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinTallModeHeight(value).into()
        }
        unsafe extern "system" fn ModeChanged<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ModeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveModeChanged<Impl: ITwoPaneView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveModeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITwoPaneView, BASE_OFFSET>(),
            Pane1: Pane1::<Impl, IMPL_OFFSET>,
            SetPane1: SetPane1::<Impl, IMPL_OFFSET>,
            Pane2: Pane2::<Impl, IMPL_OFFSET>,
            SetPane2: SetPane2::<Impl, IMPL_OFFSET>,
            Pane1Length: Pane1Length::<Impl, IMPL_OFFSET>,
            SetPane1Length: SetPane1Length::<Impl, IMPL_OFFSET>,
            Pane2Length: Pane2Length::<Impl, IMPL_OFFSET>,
            SetPane2Length: SetPane2Length::<Impl, IMPL_OFFSET>,
            PanePriority: PanePriority::<Impl, IMPL_OFFSET>,
            SetPanePriority: SetPanePriority::<Impl, IMPL_OFFSET>,
            Mode: Mode::<Impl, IMPL_OFFSET>,
            WideModeConfiguration: WideModeConfiguration::<Impl, IMPL_OFFSET>,
            SetWideModeConfiguration: SetWideModeConfiguration::<Impl, IMPL_OFFSET>,
            TallModeConfiguration: TallModeConfiguration::<Impl, IMPL_OFFSET>,
            SetTallModeConfiguration: SetTallModeConfiguration::<Impl, IMPL_OFFSET>,
            MinWideModeWidth: MinWideModeWidth::<Impl, IMPL_OFFSET>,
            SetMinWideModeWidth: SetMinWideModeWidth::<Impl, IMPL_OFFSET>,
            MinTallModeHeight: MinTallModeHeight::<Impl, IMPL_OFFSET>,
            SetMinTallModeHeight: SetMinTallModeHeight::<Impl, IMPL_OFFSET>,
            ModeChanged: ModeChanged::<Impl, IMPL_OFFSET>,
            RemoveModeChanged: RemoveModeChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITwoPaneView as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITwoPaneViewFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TwoPaneView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITwoPaneViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITwoPaneViewFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITwoPaneViewFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITwoPaneViewFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITwoPaneViewFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITwoPaneViewFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITwoPaneViewFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITwoPaneViewStatics_Impl: Sized {
    fn Pane1Property(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane2Property(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane1LengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane2LengthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PanePriorityProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn WideModeConfigurationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TallModeConfigurationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinWideModeWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinTallModeHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITwoPaneViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITwoPaneViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITwoPaneViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITwoPaneViewStatics_Vtbl {
        unsafe extern "system" fn Pane1Property<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1Property() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane2Property<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2Property() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane1LengthProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane1LengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane2LengthProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pane2LengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanePriorityProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PanePriorityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ModeProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WideModeConfigurationProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WideModeConfigurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TallModeConfigurationProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TallModeConfigurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinWideModeWidthProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinWideModeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinTallModeHeightProperty<Impl: ITwoPaneViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinTallModeHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, ITwoPaneViewStatics, BASE_OFFSET>(),
            Pane1Property: Pane1Property::<Impl, IMPL_OFFSET>,
            Pane2Property: Pane2Property::<Impl, IMPL_OFFSET>,
            Pane1LengthProperty: Pane1LengthProperty::<Impl, IMPL_OFFSET>,
            Pane2LengthProperty: Pane2LengthProperty::<Impl, IMPL_OFFSET>,
            PanePriorityProperty: PanePriorityProperty::<Impl, IMPL_OFFSET>,
            ModeProperty: ModeProperty::<Impl, IMPL_OFFSET>,
            WideModeConfigurationProperty: WideModeConfigurationProperty::<Impl, IMPL_OFFSET>,
            TallModeConfigurationProperty: TallModeConfigurationProperty::<Impl, IMPL_OFFSET>,
            MinWideModeWidthProperty: MinWideModeWidthProperty::<Impl, IMPL_OFFSET>,
            MinTallModeHeightProperty: MinTallModeHeightProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITwoPaneViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUIElementCollection_Impl: Sized {
    fn Move(&mut self, oldindex: u32, newindex: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUIElementCollection {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUIElementCollection";
}
#[cfg(feature = "implement_exclusive")]
impl IUIElementCollection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUIElementCollection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUIElementCollection_Vtbl {
        unsafe extern "system" fn Move<Impl: IUIElementCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, oldindex: u32, newindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Move(oldindex, newindex).into()
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IUIElementCollection, BASE_OFFSET>(), Move: Move::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUIElementCollection as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControl_Impl: Sized {
    fn Content(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControl";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUserControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUserControl_Vtbl {
        unsafe extern "system" fn Content<Impl: IUserControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IUserControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IUserControl, BASE_OFFSET>(),
            Content: Content::<Impl, IMPL_OFFSET>,
            SetContent: SetContent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUserControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlFactory_Impl: Sized {
    fn CreateInstance(&mut self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<UserControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUserControlFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUserControlFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IUserControlFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IUserControlFactory, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUserControlFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlStatics_Impl: Sized {
    fn ContentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IUserControlStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IUserControlStatics_Vtbl {
        unsafe extern "system" fn ContentProperty<Impl: IUserControlStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IUserControlStatics, BASE_OFFSET>(),
            ContentProperty: ContentProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IUserControlStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVariableSizedWrapGrid_Impl: Sized {
    fn ItemHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn HorizontalChildrenAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalChildrenAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalChildrenAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalChildrenAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVariableSizedWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVariableSizedWrapGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IVariableSizedWrapGrid_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVariableSizedWrapGrid_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVariableSizedWrapGrid_Vtbl {
        unsafe extern "system" fn ItemHeight<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn ItemWidth<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn HorizontalChildrenAlignment<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalChildrenAlignment<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn VerticalChildrenAlignment<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalChildrenAlignment<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IVariableSizedWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVariableSizedWrapGrid, BASE_OFFSET>(),
            ItemHeight: ItemHeight::<Impl, IMPL_OFFSET>,
            SetItemHeight: SetItemHeight::<Impl, IMPL_OFFSET>,
            ItemWidth: ItemWidth::<Impl, IMPL_OFFSET>,
            SetItemWidth: SetItemWidth::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignment: HorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalChildrenAlignment: SetHorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignment: VerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalChildrenAlignment: SetVerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumns: MaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            SetMaximumRowsOrColumns: SetMaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVariableSizedWrapGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVariableSizedWrapGridStatics_Impl: Sized {
    fn ItemHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RowSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRowSpan(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetRowSpan(&mut self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnSpanProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumnSpan(&mut self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetColumnSpan(&mut self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVariableSizedWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IVariableSizedWrapGridStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVariableSizedWrapGridStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVariableSizedWrapGridStatics_Vtbl {
        unsafe extern "system" fn ItemHeightProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemWidthProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalChildrenAlignmentProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalChildrenAlignmentProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RowSpanProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RowSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRowSpan<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRowSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpan<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRowSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnSpanProperty<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColumnSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumnSpan<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColumnSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpan<Impl: IVariableSizedWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColumnSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVariableSizedWrapGridStatics, BASE_OFFSET>(),
            ItemHeightProperty: ItemHeightProperty::<Impl, IMPL_OFFSET>,
            ItemWidthProperty: ItemWidthProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignmentProperty: HorizontalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignmentProperty: VerticalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumnsProperty: MaximumRowsOrColumnsProperty::<Impl, IMPL_OFFSET>,
            RowSpanProperty: RowSpanProperty::<Impl, IMPL_OFFSET>,
            GetRowSpan: GetRowSpan::<Impl, IMPL_OFFSET>,
            SetRowSpan: SetRowSpan::<Impl, IMPL_OFFSET>,
            ColumnSpanProperty: ColumnSpanProperty::<Impl, IMPL_OFFSET>,
            GetColumnSpan: GetColumnSpan::<Impl, IMPL_OFFSET>,
            SetColumnSpan: SetColumnSpan::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVariableSizedWrapGridStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
pub trait IViewbox_Impl: Sized {
    fn Child(&mut self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&mut self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Stretch(&mut self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&mut self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn StretchDirection(&mut self) -> ::windows::core::Result<StretchDirection>;
    fn SetStretchDirection(&mut self, value: StretchDirection) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IViewbox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IViewbox";
}
#[cfg(all(feature = "UI_Xaml_Media", feature = "implement_exclusive"))]
impl IViewbox_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IViewbox_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IViewbox_Vtbl {
        unsafe extern "system" fn Child<Impl: IViewbox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IViewbox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IViewbox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IViewbox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn StretchDirection<Impl: IViewbox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut StretchDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretchDirection<Impl: IViewbox_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: StretchDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStretchDirection(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IViewbox, BASE_OFFSET>(),
            Child: Child::<Impl, IMPL_OFFSET>,
            SetChild: SetChild::<Impl, IMPL_OFFSET>,
            Stretch: Stretch::<Impl, IMPL_OFFSET>,
            SetStretch: SetStretch::<Impl, IMPL_OFFSET>,
            StretchDirection: StretchDirection::<Impl, IMPL_OFFSET>,
            SetStretchDirection: SetStretchDirection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IViewbox as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IViewboxStatics_Impl: Sized {
    fn StretchProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchDirectionProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IViewboxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IViewboxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IViewboxStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IViewboxStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IViewboxStatics_Vtbl {
        unsafe extern "system" fn StretchProperty<Impl: IViewboxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchDirectionProperty<Impl: IViewboxStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StretchDirectionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IViewboxStatics, BASE_OFFSET>(),
            StretchProperty: StretchProperty::<Impl, IMPL_OFFSET>,
            StretchDirectionProperty: StretchDirectionProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IViewboxStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanel_Impl: Sized {
    fn ItemContainerGenerator(&mut self) -> ::windows::core::Result<ItemContainerGenerator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanel_Vtbl {
        unsafe extern "system" fn ItemContainerGenerator<Impl: IVirtualizingPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemContainerGenerator() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanel, BASE_OFFSET>(),
            ItemContainerGenerator: ItemContainerGenerator::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelFactory_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanelFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanelFactory_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanelFactory, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanelFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
pub trait IVirtualizingPanelOverrides_Impl: Sized {
    fn OnItemsChanged(&mut self, sender: &::core::option::Option<::windows::core::IInspectable>, args: &::core::option::Option<Primitives::ItemsChangedEventArgs>) -> ::windows::core::Result<()>;
    fn OnClearChildren(&mut self) -> ::windows::core::Result<()>;
    fn BringIndexIntoView(&mut self, index: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IVirtualizingPanelOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides";
}
#[cfg(all(feature = "UI_Xaml_Controls_Primitives", feature = "implement_exclusive"))]
impl IVirtualizingPanelOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanelOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanelOverrides_Vtbl {
        unsafe extern "system" fn OnItemsChanged<Impl: IVirtualizingPanelOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sender: *mut ::core::ffi::c_void, args: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnItemsChanged(&*(&sender as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&args as *const <Primitives::ItemsChangedEventArgs as ::windows::core::Abi>::Abi as *const <Primitives::ItemsChangedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnClearChildren<Impl: IVirtualizingPanelOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClearChildren().into()
        }
        unsafe extern "system" fn BringIndexIntoView<Impl: IVirtualizingPanelOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BringIndexIntoView(index).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanelOverrides, BASE_OFFSET>(),
            OnItemsChanged: OnItemsChanged::<Impl, IMPL_OFFSET>,
            OnClearChildren: OnClearChildren::<Impl, IMPL_OFFSET>,
            BringIndexIntoView: BringIndexIntoView::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanelOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelProtected_Impl: Sized {
    fn AddInternalChild(&mut self, child: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn InsertInternalChild(&mut self, index: i32, child: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn RemoveInternalChildRange(&mut self, index: i32, range: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanelProtected {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelProtected";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelProtected_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingPanelProtected_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingPanelProtected_Vtbl {
        unsafe extern "system" fn AddInternalChild<Impl: IVirtualizingPanelProtected_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, child: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddInternalChild(&*(&child as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InsertInternalChild<Impl: IVirtualizingPanelProtected_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, child: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InsertInternalChild(index, &*(&child as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveInternalChildRange<Impl: IVirtualizingPanelProtected_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, range: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveInternalChildRange(index, range).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingPanelProtected, BASE_OFFSET>(),
            AddInternalChild: AddInternalChild::<Impl, IMPL_OFFSET>,
            InsertInternalChild: InsertInternalChild::<Impl, IMPL_OFFSET>,
            RemoveInternalChildRange: RemoveInternalChildRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingPanelProtected as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IVirtualizingStackPanel_Impl: Sized {
    fn AreScrollSnapPointsRegular(&mut self) -> ::windows::core::Result<bool>;
    fn SetAreScrollSnapPointsRegular(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn CleanUpVirtualizedItemEvent(&mut self, handler: &::core::option::Option<CleanUpVirtualizedItemEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCleanUpVirtualizedItemEvent(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IVirtualizingStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanel";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IVirtualizingStackPanel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingStackPanel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingStackPanel_Vtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegular<Impl: IVirtualizingStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegular() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreScrollSnapPointsRegular<Impl: IVirtualizingStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAreScrollSnapPointsRegular(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IVirtualizingStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IVirtualizingStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn CleanUpVirtualizedItemEvent<Impl: IVirtualizingStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CleanUpVirtualizedItemEvent(&*(&handler as *const <CleanUpVirtualizedItemEventHandler as ::windows::core::Abi>::Abi as *const <CleanUpVirtualizedItemEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCleanUpVirtualizedItemEvent<Impl: IVirtualizingStackPanel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCleanUpVirtualizedItemEvent(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingStackPanel, BASE_OFFSET>(),
            AreScrollSnapPointsRegular: AreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            SetAreScrollSnapPointsRegular: SetAreScrollSnapPointsRegular::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            CleanUpVirtualizedItemEvent: CleanUpVirtualizedItemEvent::<Impl, IMPL_OFFSET>,
            RemoveCleanUpVirtualizedItemEvent: RemoveCleanUpVirtualizedItemEvent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingStackPanel as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingStackPanelOverrides_Impl: Sized {
    fn OnCleanUpVirtualizedItem(&mut self, e: &::core::option::Option<CleanUpVirtualizedItemEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingStackPanelOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingStackPanelOverrides_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingStackPanelOverrides_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingStackPanelOverrides_Vtbl {
        unsafe extern "system" fn OnCleanUpVirtualizedItem<Impl: IVirtualizingStackPanelOverrides_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnCleanUpVirtualizedItem(&*(&e as *const <CleanUpVirtualizedItemEventArgs as ::windows::core::Abi>::Abi as *const <CleanUpVirtualizedItemEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingStackPanelOverrides, BASE_OFFSET>(),
            OnCleanUpVirtualizedItem: OnCleanUpVirtualizedItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingStackPanelOverrides as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingStackPanelStatics_Impl: Sized {
    fn AreScrollSnapPointsRegularProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VirtualizationModeProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVirtualizationMode(&mut self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<VirtualizationMode>;
    fn SetVirtualizationMode(&mut self, element: &::core::option::Option<super::DependencyObject>, value: VirtualizationMode) -> ::windows::core::Result<()>;
    fn IsVirtualizingProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVirtualizing(&mut self, o: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingStackPanelStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVirtualizingStackPanelStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVirtualizingStackPanelStatics_Vtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegularProperty<Impl: IVirtualizingStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegularProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IVirtualizingStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VirtualizationModeProperty<Impl: IVirtualizingStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VirtualizationModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVirtualizationMode<Impl: IVirtualizingStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut VirtualizationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVirtualizationMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVirtualizationMode<Impl: IVirtualizingStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: VirtualizationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVirtualizationMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn IsVirtualizingProperty<Impl: IVirtualizingStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsVirtualizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVirtualizing<Impl: IVirtualizingStackPanelStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, o: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIsVirtualizing(&*(&o as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IVirtualizingStackPanelStatics, BASE_OFFSET>(),
            AreScrollSnapPointsRegularProperty: AreScrollSnapPointsRegularProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            VirtualizationModeProperty: VirtualizationModeProperty::<Impl, IMPL_OFFSET>,
            GetVirtualizationMode: GetVirtualizationMode::<Impl, IMPL_OFFSET>,
            SetVirtualizationMode: SetVirtualizationMode::<Impl, IMPL_OFFSET>,
            IsVirtualizingProperty: IsVirtualizingProperty::<Impl, IMPL_OFFSET>,
            GetIsVirtualizing: GetIsVirtualizing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVirtualizingStackPanelStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
pub trait IWebView_Impl: Sized {
    fn Source(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetSource(&mut self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn AllowedScriptNotifyUris(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>;
    fn SetAllowedScriptNotifyUris(&mut self, value: &::core::option::Option<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>) -> ::windows::core::Result<()>;
    fn DataTransferPackage(&mut self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
    fn LoadCompleted(&mut self, handler: &::core::option::Option<super::Navigation::LoadCompletedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveLoadCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScriptNotify(&mut self, handler: &::core::option::Option<NotifyEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveScriptNotify(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationFailed(&mut self, handler: &::core::option::Option<WebViewNavigationFailedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationFailed(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn InvokeScript(&mut self, scriptname: &::windows::core::HSTRING, arguments: &[<::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType]) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Navigate(&mut self, source: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn NavigateToString(&mut self, text: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView";
}
#[cfg(all(feature = "ApplicationModel_DataTransfer", feature = "Foundation", feature = "Foundation_Collections", feature = "UI_Xaml_Navigation", feature = "implement_exclusive"))]
impl IWebView_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView_Vtbl {
        unsafe extern "system" fn Source<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AllowedScriptNotifyUris<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AllowedScriptNotifyUris() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllowedScriptNotifyUris<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllowedScriptNotifyUris(&*(&value as *const <super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DataTransferPackage<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataTransferPackage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LoadCompleted<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LoadCompleted(&*(&handler as *const <super::Navigation::LoadCompletedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::LoadCompletedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveLoadCompleted<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveLoadCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScriptNotify<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ScriptNotify(&*(&handler as *const <NotifyEventHandler as ::windows::core::Abi>::Abi as *const <NotifyEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveScriptNotify<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveScriptNotify(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationFailed<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationFailed(&*(&handler as *const <WebViewNavigationFailedEventHandler as ::windows::core::Abi>::Abi as *const <WebViewNavigationFailedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationFailed<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InvokeScript<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, scriptname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, arguments_array_size: u32, arguments: *const ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokeScript(&*(&scriptname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), ::core::slice::from_raw_parts(::core::mem::transmute_copy(&arguments), arguments_array_size as _)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigate<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Navigate(&*(&source as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigateToString<Impl: IWebView_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, text: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NavigateToString(&*(&text as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView, BASE_OFFSET>(),
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            AllowedScriptNotifyUris: AllowedScriptNotifyUris::<Impl, IMPL_OFFSET>,
            SetAllowedScriptNotifyUris: SetAllowedScriptNotifyUris::<Impl, IMPL_OFFSET>,
            DataTransferPackage: DataTransferPackage::<Impl, IMPL_OFFSET>,
            LoadCompleted: LoadCompleted::<Impl, IMPL_OFFSET>,
            RemoveLoadCompleted: RemoveLoadCompleted::<Impl, IMPL_OFFSET>,
            ScriptNotify: ScriptNotify::<Impl, IMPL_OFFSET>,
            RemoveScriptNotify: RemoveScriptNotify::<Impl, IMPL_OFFSET>,
            NavigationFailed: NavigationFailed::<Impl, IMPL_OFFSET>,
            RemoveNavigationFailed: RemoveNavigationFailed::<Impl, IMPL_OFFSET>,
            InvokeScript: InvokeScript::<Impl, IMPL_OFFSET>,
            Navigate: Navigate::<Impl, IMPL_OFFSET>,
            NavigateToString: NavigateToString::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Storage_Streams", feature = "Web", feature = "Web_Http", feature = "implement_exclusive"))]
pub trait IWebView2_Impl: Sized {
    fn CanGoBack(&mut self) -> ::windows::core::Result<bool>;
    fn CanGoForward(&mut self) -> ::windows::core::Result<bool>;
    fn DocumentTitle(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn NavigationStarting(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContentLoading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLoading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DOMContentLoaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDOMContentLoaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GoForward(&mut self) -> ::windows::core::Result<()>;
    fn GoBack(&mut self) -> ::windows::core::Result<()>;
    fn Refresh(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn CapturePreviewToStreamAsync(&mut self, stream: &::core::option::Option<super::super::super::Storage::Streams::IRandomAccessStream>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
    fn InvokeScriptAsync(&mut self, scriptname: &::windows::core::HSTRING, arguments: &::core::option::Option<super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING>>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<::windows::core::HSTRING>>;
    fn CaptureSelectedContentToDataPackageAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::ApplicationModel::DataTransfer::DataPackage>>;
    fn NavigateToLocalStreamUri(&mut self, source: &::core::option::Option<super::super::super::Foundation::Uri>, streamresolver: &::core::option::Option<super::super::super::Web::IUriToStreamResolver>) -> ::windows::core::Result<()>;
    fn BuildLocalStreamUri(&mut self, contentidentifier: &::windows::core::HSTRING, relativepath: &::windows::core::HSTRING) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn DefaultBackgroundColor(&mut self) -> ::windows::core::Result<super::super::Color>;
    fn SetDefaultBackgroundColor(&mut self, value: &super::super::Color) -> ::windows::core::Result<()>;
    fn NavigationCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameNavigationStarting(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameNavigationStarting(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameContentLoading(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameContentLoading(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameDOMContentLoaded(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameDOMContentLoaded(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameNavigationCompleted(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameNavigationCompleted(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn LongRunningScriptDetected(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveLongRunningScriptDetected(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn UnsafeContentWarningDisplaying(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnsafeContentWarningDisplaying(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn UnviewableContentIdentified(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnviewableContentIdentified(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigateWithHttpRequestMessage(&mut self, requestmessage: &::core::option::Option<super::super::super::Web::Http::HttpRequestMessage>) -> ::windows::core::Result<()>;
    fn Focus(&mut self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Storage_Streams", feature = "Web", feature = "Web_Http", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView2";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "Storage_Streams", feature = "Web", feature = "Web_Http", feature = "implement_exclusive"))]
impl IWebView2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView2_Vtbl {
        unsafe extern "system" fn CanGoBack<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForward<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForward() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DocumentTitle<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DocumentTitle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigationStarting<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationStarting<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLoading<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLoading<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContentLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DOMContentLoaded<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DOMContentLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDOMContentLoaded<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveDOMContentLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GoForward<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoForward().into()
        }
        unsafe extern "system" fn GoBack<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoBack().into()
        }
        unsafe extern "system" fn Refresh<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Refresh().into()
        }
        unsafe extern "system" fn Stop<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn CapturePreviewToStreamAsync<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stream: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CapturePreviewToStreamAsync(&*(&stream as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::Abi>::Abi as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InvokeScriptAsync<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, scriptname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, arguments: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InvokeScriptAsync(&*(&scriptname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&arguments as *const <super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CaptureSelectedContentToDataPackageAsync<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CaptureSelectedContentToDataPackageAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigateToLocalStreamUri<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, streamresolver: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NavigateToLocalStreamUri(&*(&source as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType), &*(&streamresolver as *const <super::super::super::Web::IUriToStreamResolver as ::windows::core::Abi>::Abi as *const <super::super::super::Web::IUriToStreamResolver as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BuildLocalStreamUri<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, contentidentifier: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, relativepath: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BuildLocalStreamUri(&*(&contentidentifier as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&relativepath as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultBackgroundColor<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultBackgroundColor<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultBackgroundColor(&*(&value as *const <super::super::Color as ::windows::core::Abi>::Abi as *const <super::super::Color as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationCompleted<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NavigationCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationCompleted<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNavigationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameNavigationStarting<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameNavigationStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameNavigationStarting<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameNavigationStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameContentLoading<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameContentLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameContentLoading<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameContentLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameDOMContentLoaded<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameDOMContentLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameDOMContentLoaded<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameDOMContentLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameNavigationCompleted<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrameNavigationCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameNavigationCompleted<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFrameNavigationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LongRunningScriptDetected<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LongRunningScriptDetected(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveLongRunningScriptDetected<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveLongRunningScriptDetected(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsafeContentWarningDisplaying<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsafeContentWarningDisplaying(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnsafeContentWarningDisplaying<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnsafeContentWarningDisplaying(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnviewableContentIdentified<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnviewableContentIdentified(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnviewableContentIdentified<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnviewableContentIdentified(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigateWithHttpRequestMessage<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, requestmessage: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NavigateWithHttpRequestMessage(&*(&requestmessage as *const <super::super::super::Web::Http::HttpRequestMessage as ::windows::core::Abi>::Abi as *const <super::super::super::Web::Http::HttpRequestMessage as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Focus<Impl: IWebView2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView2, BASE_OFFSET>(),
            CanGoBack: CanGoBack::<Impl, IMPL_OFFSET>,
            CanGoForward: CanGoForward::<Impl, IMPL_OFFSET>,
            DocumentTitle: DocumentTitle::<Impl, IMPL_OFFSET>,
            NavigationStarting: NavigationStarting::<Impl, IMPL_OFFSET>,
            RemoveNavigationStarting: RemoveNavigationStarting::<Impl, IMPL_OFFSET>,
            ContentLoading: ContentLoading::<Impl, IMPL_OFFSET>,
            RemoveContentLoading: RemoveContentLoading::<Impl, IMPL_OFFSET>,
            DOMContentLoaded: DOMContentLoaded::<Impl, IMPL_OFFSET>,
            RemoveDOMContentLoaded: RemoveDOMContentLoaded::<Impl, IMPL_OFFSET>,
            GoForward: GoForward::<Impl, IMPL_OFFSET>,
            GoBack: GoBack::<Impl, IMPL_OFFSET>,
            Refresh: Refresh::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            CapturePreviewToStreamAsync: CapturePreviewToStreamAsync::<Impl, IMPL_OFFSET>,
            InvokeScriptAsync: InvokeScriptAsync::<Impl, IMPL_OFFSET>,
            CaptureSelectedContentToDataPackageAsync: CaptureSelectedContentToDataPackageAsync::<Impl, IMPL_OFFSET>,
            NavigateToLocalStreamUri: NavigateToLocalStreamUri::<Impl, IMPL_OFFSET>,
            BuildLocalStreamUri: BuildLocalStreamUri::<Impl, IMPL_OFFSET>,
            DefaultBackgroundColor: DefaultBackgroundColor::<Impl, IMPL_OFFSET>,
            SetDefaultBackgroundColor: SetDefaultBackgroundColor::<Impl, IMPL_OFFSET>,
            NavigationCompleted: NavigationCompleted::<Impl, IMPL_OFFSET>,
            RemoveNavigationCompleted: RemoveNavigationCompleted::<Impl, IMPL_OFFSET>,
            FrameNavigationStarting: FrameNavigationStarting::<Impl, IMPL_OFFSET>,
            RemoveFrameNavigationStarting: RemoveFrameNavigationStarting::<Impl, IMPL_OFFSET>,
            FrameContentLoading: FrameContentLoading::<Impl, IMPL_OFFSET>,
            RemoveFrameContentLoading: RemoveFrameContentLoading::<Impl, IMPL_OFFSET>,
            FrameDOMContentLoaded: FrameDOMContentLoaded::<Impl, IMPL_OFFSET>,
            RemoveFrameDOMContentLoaded: RemoveFrameDOMContentLoaded::<Impl, IMPL_OFFSET>,
            FrameNavigationCompleted: FrameNavigationCompleted::<Impl, IMPL_OFFSET>,
            RemoveFrameNavigationCompleted: RemoveFrameNavigationCompleted::<Impl, IMPL_OFFSET>,
            LongRunningScriptDetected: LongRunningScriptDetected::<Impl, IMPL_OFFSET>,
            RemoveLongRunningScriptDetected: RemoveLongRunningScriptDetected::<Impl, IMPL_OFFSET>,
            UnsafeContentWarningDisplaying: UnsafeContentWarningDisplaying::<Impl, IMPL_OFFSET>,
            RemoveUnsafeContentWarningDisplaying: RemoveUnsafeContentWarningDisplaying::<Impl, IMPL_OFFSET>,
            UnviewableContentIdentified: UnviewableContentIdentified::<Impl, IMPL_OFFSET>,
            RemoveUnviewableContentIdentified: RemoveUnviewableContentIdentified::<Impl, IMPL_OFFSET>,
            NavigateWithHttpRequestMessage: NavigateWithHttpRequestMessage::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebView3_Impl: Sized {
    fn ContainsFullScreenElement(&mut self) -> ::windows::core::Result<bool>;
    fn ContainsFullScreenElementChanged(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContainsFullScreenElementChanged(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView3";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebView3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView3_Vtbl {
        unsafe extern "system" fn ContainsFullScreenElement<Impl: IWebView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainsFullScreenElementChanged<Impl: IWebView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElementChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContainsFullScreenElementChanged<Impl: IWebView3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveContainsFullScreenElementChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView3, BASE_OFFSET>(),
            ContainsFullScreenElement: ContainsFullScreenElement::<Impl, IMPL_OFFSET>,
            ContainsFullScreenElementChanged: ContainsFullScreenElementChanged::<Impl, IMPL_OFFSET>,
            RemoveContainsFullScreenElementChanged: RemoveContainsFullScreenElementChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IWebView4_Impl: Sized {
    fn ExecutionMode(&mut self) -> ::windows::core::Result<WebViewExecutionMode>;
    fn DeferredPermissionRequests(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<WebViewDeferredPermissionRequest>>;
    fn Settings(&mut self) -> ::windows::core::Result<WebViewSettings>;
    fn UnsupportedUriSchemeIdentified(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnsupportedUriSchemeIdentified(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NewWindowRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNewWindowRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PermissionRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePermissionRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn AddWebAllowedObject(&mut self, name: &::windows::core::HSTRING, pobject: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn DeferredPermissionRequestById(&mut self, id: u32) -> ::windows::core::Result<WebViewDeferredPermissionRequest>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView4";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IWebView4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView4_Vtbl {
        unsafe extern "system" fn ExecutionMode<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewExecutionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExecutionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeferredPermissionRequests<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DeferredPermissionRequests() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Settings<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Settings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsupportedUriSchemeIdentified<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UnsupportedUriSchemeIdentified(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnsupportedUriSchemeIdentified<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveUnsupportedUriSchemeIdentified(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NewWindowRequested<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NewWindowRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNewWindowRequested<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNewWindowRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PermissionRequested<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePermissionRequested<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePermissionRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AddWebAllowedObject<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, pobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddWebAllowedObject(&*(&name as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&pobject as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DeferredPermissionRequestById<Impl: IWebView4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DeferredPermissionRequestById(id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView4, BASE_OFFSET>(),
            ExecutionMode: ExecutionMode::<Impl, IMPL_OFFSET>,
            DeferredPermissionRequests: DeferredPermissionRequests::<Impl, IMPL_OFFSET>,
            Settings: Settings::<Impl, IMPL_OFFSET>,
            UnsupportedUriSchemeIdentified: UnsupportedUriSchemeIdentified::<Impl, IMPL_OFFSET>,
            RemoveUnsupportedUriSchemeIdentified: RemoveUnsupportedUriSchemeIdentified::<Impl, IMPL_OFFSET>,
            NewWindowRequested: NewWindowRequested::<Impl, IMPL_OFFSET>,
            RemoveNewWindowRequested: RemoveNewWindowRequested::<Impl, IMPL_OFFSET>,
            PermissionRequested: PermissionRequested::<Impl, IMPL_OFFSET>,
            RemovePermissionRequested: RemovePermissionRequested::<Impl, IMPL_OFFSET>,
            AddWebAllowedObject: AddWebAllowedObject::<Impl, IMPL_OFFSET>,
            DeferredPermissionRequestById: DeferredPermissionRequestById::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView5_Impl: Sized {
    fn XYFocusLeft(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusLeft(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusRight(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusRight(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusUp(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusUp(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusDown(&mut self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusDown(&mut self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView5";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView5_Vtbl {
        unsafe extern "system" fn XYFocusLeft<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusLeft<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusLeft(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusRight<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusRight<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusRight(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusUp<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusUp<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusUp(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusDown<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusDown<Impl: IWebView5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXYFocusDown(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView5, BASE_OFFSET>(),
            XYFocusLeft: XYFocusLeft::<Impl, IMPL_OFFSET>,
            SetXYFocusLeft: SetXYFocusLeft::<Impl, IMPL_OFFSET>,
            XYFocusRight: XYFocusRight::<Impl, IMPL_OFFSET>,
            SetXYFocusRight: SetXYFocusRight::<Impl, IMPL_OFFSET>,
            XYFocusUp: XYFocusUp::<Impl, IMPL_OFFSET>,
            SetXYFocusUp: SetXYFocusUp::<Impl, IMPL_OFFSET>,
            XYFocusDown: XYFocusDown::<Impl, IMPL_OFFSET>,
            SetXYFocusDown: SetXYFocusDown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebView6_Impl: Sized {
    fn SeparateProcessLost(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSeparateProcessLost(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView6";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebView6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView6_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView6_Vtbl {
        unsafe extern "system" fn SeparateProcessLost<Impl: IWebView6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SeparateProcessLost(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSeparateProcessLost<Impl: IWebView6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSeparateProcessLost(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView6, BASE_OFFSET>(),
            SeparateProcessLost: SeparateProcessLost::<Impl, IMPL_OFFSET>,
            RemoveSeparateProcessLost: RemoveSeparateProcessLost::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView6 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebView7_Impl: Sized {
    fn WebResourceRequested(&mut self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveWebResourceRequested(&mut self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebView7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView7";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebView7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebView7_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebView7_Vtbl {
        unsafe extern "system" fn WebResourceRequested<Impl: IWebView7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WebResourceRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveWebResourceRequested<Impl: IWebView7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveWebResourceRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebView7, BASE_OFFSET>(),
            WebResourceRequested: WebResourceRequested::<Impl, IMPL_OFFSET>,
            RemoveWebResourceRequested: RemoveWebResourceRequested::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebView7 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewBrush_Impl: Sized {
    fn SourceName(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSourceName(&mut self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Redraw(&mut self) -> ::windows::core::Result<()>;
    fn SetSource(&mut self, source: &::core::option::Option<WebView>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewBrush {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewBrush";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewBrush_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewBrush_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewBrush_Vtbl {
        unsafe extern "system" fn SourceName<Impl: IWebViewBrush_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceName<Impl: IWebViewBrush_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Redraw<Impl: IWebViewBrush_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Redraw().into()
        }
        unsafe extern "system" fn SetSource<Impl: IWebViewBrush_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&source as *const <WebView as ::windows::core::Abi>::Abi as *const <WebView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewBrush, BASE_OFFSET>(),
            SourceName: SourceName::<Impl, IMPL_OFFSET>,
            SetSourceName: SetSourceName::<Impl, IMPL_OFFSET>,
            Redraw: Redraw::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewBrush as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewBrushStatics_Impl: Sized {
    fn SourceNameProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewBrushStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewBrushStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewBrushStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewBrushStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewBrushStatics_Vtbl {
        unsafe extern "system" fn SourceNameProperty<Impl: IWebViewBrushStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewBrushStatics, BASE_OFFSET>(),
            SourceNameProperty: SourceNameProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewBrushStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewContentLoadingEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewContentLoadingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewContentLoadingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewContentLoadingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewContentLoadingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewContentLoadingEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewContentLoadingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewContentLoadingEventArgs, BASE_OFFSET>(), Uri: Uri::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewContentLoadingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewDOMContentLoadedEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewDOMContentLoadedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewDOMContentLoadedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewDOMContentLoadedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewDOMContentLoadedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewDOMContentLoadedEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewDOMContentLoadedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewDOMContentLoadedEventArgs, BASE_OFFSET>(), Uri: Uri::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewDOMContentLoadedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewDeferredPermissionRequest_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn PermissionType(&mut self) -> ::windows::core::Result<WebViewPermissionType>;
    fn Id(&mut self) -> ::windows::core::Result<u32>;
    fn Allow(&mut self) -> ::windows::core::Result<()>;
    fn Deny(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewDeferredPermissionRequest {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewDeferredPermissionRequest";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewDeferredPermissionRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewDeferredPermissionRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewDeferredPermissionRequest_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewDeferredPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PermissionType<Impl: IWebViewDeferredPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Id<Impl: IWebViewDeferredPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Id() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Allow<Impl: IWebViewDeferredPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Allow().into()
        }
        unsafe extern "system" fn Deny<Impl: IWebViewDeferredPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Deny().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewDeferredPermissionRequest, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            PermissionType: PermissionType::<Impl, IMPL_OFFSET>,
            Id: Id::<Impl, IMPL_OFFSET>,
            Allow: Allow::<Impl, IMPL_OFFSET>,
            Deny: Deny::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewDeferredPermissionRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewFactory4_Impl: Sized {
    fn CreateInstanceWithExecutionMode(&mut self, executionmode: WebViewExecutionMode) -> ::windows::core::Result<WebView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewFactory4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewFactory4";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewFactory4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewFactory4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewFactory4_Vtbl {
        unsafe extern "system" fn CreateInstanceWithExecutionMode<Impl: IWebViewFactory4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, executionmode: WebViewExecutionMode, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithExecutionMode(executionmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewFactory4, BASE_OFFSET>(),
            CreateInstanceWithExecutionMode: CreateInstanceWithExecutionMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewFactory4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewLongRunningScriptDetectedEventArgs_Impl: Sized {
    fn ExecutionTime(&mut self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn StopPageScriptExecution(&mut self) -> ::windows::core::Result<bool>;
    fn SetStopPageScriptExecution(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewLongRunningScriptDetectedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewLongRunningScriptDetectedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewLongRunningScriptDetectedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewLongRunningScriptDetectedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewLongRunningScriptDetectedEventArgs_Vtbl {
        unsafe extern "system" fn ExecutionTime<Impl: IWebViewLongRunningScriptDetectedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExecutionTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopPageScriptExecution<Impl: IWebViewLongRunningScriptDetectedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StopPageScriptExecution() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStopPageScriptExecution<Impl: IWebViewLongRunningScriptDetectedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStopPageScriptExecution(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewLongRunningScriptDetectedEventArgs, BASE_OFFSET>(),
            ExecutionTime: ExecutionTime::<Impl, IMPL_OFFSET>,
            StopPageScriptExecution: StopPageScriptExecution::<Impl, IMPL_OFFSET>,
            SetStopPageScriptExecution: SetStopPageScriptExecution::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewLongRunningScriptDetectedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
pub trait IWebViewNavigationCompletedEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn IsSuccess(&mut self) -> ::windows::core::Result<bool>;
    fn WebErrorStatus(&mut self) -> ::windows::core::Result<super::super::super::Web::WebErrorStatus>;
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNavigationCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationCompletedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl IWebViewNavigationCompletedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNavigationCompletedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNavigationCompletedEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationCompletedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSuccess<Impl: IWebViewNavigationCompletedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSuccess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WebErrorStatus<Impl: IWebViewNavigationCompletedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Web::WebErrorStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WebErrorStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNavigationCompletedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            IsSuccess: IsSuccess::<Impl, IMPL_OFFSET>,
            WebErrorStatus: WebErrorStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNavigationCompletedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
pub trait IWebViewNavigationFailedEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn WebErrorStatus(&mut self) -> ::windows::core::Result<super::super::super::Web::WebErrorStatus>;
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNavigationFailedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationFailedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Web", feature = "implement_exclusive"))]
impl IWebViewNavigationFailedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNavigationFailedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNavigationFailedEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationFailedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WebErrorStatus<Impl: IWebViewNavigationFailedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Web::WebErrorStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WebErrorStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNavigationFailedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            WebErrorStatus: WebErrorStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNavigationFailedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewNavigationStartingEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Cancel(&mut self) -> ::windows::core::Result<bool>;
    fn SetCancel(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNavigationStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationStartingEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewNavigationStartingEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNavigationStartingEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNavigationStartingEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IWebViewNavigationStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IWebViewNavigationStartingEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNavigationStartingEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            SetCancel: SetCancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNavigationStartingEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewNewWindowRequestedEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Referrer(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewNewWindowRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNewWindowRequestedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewNewWindowRequestedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewNewWindowRequestedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewNewWindowRequestedEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNewWindowRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Referrer<Impl: IWebViewNewWindowRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Referrer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IWebViewNewWindowRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IWebViewNewWindowRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewNewWindowRequestedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Referrer: Referrer::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewNewWindowRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewPermissionRequest_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn PermissionType(&mut self) -> ::windows::core::Result<WebViewPermissionType>;
    fn Id(&mut self) -> ::windows::core::Result<u32>;
    fn State(&mut self) -> ::windows::core::Result<WebViewPermissionState>;
    fn Defer(&mut self) -> ::windows::core::Result<()>;
    fn Allow(&mut self) -> ::windows::core::Result<()>;
    fn Deny(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewPermissionRequest {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewPermissionRequest";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewPermissionRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewPermissionRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewPermissionRequest_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PermissionType<Impl: IWebViewPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Id<Impl: IWebViewPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Id() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn State<Impl: IWebViewPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).State() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Defer<Impl: IWebViewPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Defer().into()
        }
        unsafe extern "system" fn Allow<Impl: IWebViewPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Allow().into()
        }
        unsafe extern "system" fn Deny<Impl: IWebViewPermissionRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Deny().into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewPermissionRequest, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            PermissionType: PermissionType::<Impl, IMPL_OFFSET>,
            Id: Id::<Impl, IMPL_OFFSET>,
            State: State::<Impl, IMPL_OFFSET>,
            Defer: Defer::<Impl, IMPL_OFFSET>,
            Allow: Allow::<Impl, IMPL_OFFSET>,
            Deny: Deny::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewPermissionRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewPermissionRequestedEventArgs_Impl: Sized {
    fn PermissionRequest(&mut self) -> ::windows::core::Result<WebViewPermissionRequest>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewPermissionRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewPermissionRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewPermissionRequestedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewPermissionRequestedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewPermissionRequestedEventArgs_Vtbl {
        unsafe extern "system" fn PermissionRequest<Impl: IWebViewPermissionRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PermissionRequest() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewPermissionRequestedEventArgs, BASE_OFFSET>(),
            PermissionRequest: PermissionRequest::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewPermissionRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewSeparateProcessLostEventArgs_Impl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewSeparateProcessLostEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewSeparateProcessLostEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewSeparateProcessLostEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewSeparateProcessLostEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewSeparateProcessLostEventArgs_Vtbl {
        Self { base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewSeparateProcessLostEventArgs, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewSeparateProcessLostEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewSettings_Impl: Sized {
    fn IsJavaScriptEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsJavaScriptEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
    fn IsIndexedDBEnabled(&mut self) -> ::windows::core::Result<bool>;
    fn SetIsIndexedDBEnabled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewSettings";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewSettings_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewSettings_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewSettings_Vtbl {
        unsafe extern "system" fn IsJavaScriptEnabled<Impl: IWebViewSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsJavaScriptEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsJavaScriptEnabled<Impl: IWebViewSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsJavaScriptEnabled(value).into()
        }
        unsafe extern "system" fn IsIndexedDBEnabled<Impl: IWebViewSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsIndexedDBEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsIndexedDBEnabled<Impl: IWebViewSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsIndexedDBEnabled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewSettings, BASE_OFFSET>(),
            IsJavaScriptEnabled: IsJavaScriptEnabled::<Impl, IMPL_OFFSET>,
            SetIsJavaScriptEnabled: SetIsJavaScriptEnabled::<Impl, IMPL_OFFSET>,
            IsIndexedDBEnabled: IsIndexedDBEnabled::<Impl, IMPL_OFFSET>,
            SetIsIndexedDBEnabled: SetIsIndexedDBEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewSettings as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
pub trait IWebViewStatics_Impl: Sized {
    fn AnyScriptNotifyUri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>;
    fn SourceProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AllowedScriptNotifyUrisProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DataTransferPackageProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics";
}
#[cfg(all(feature = "Foundation", feature = "Foundation_Collections", feature = "implement_exclusive"))]
impl IWebViewStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics_Vtbl {
        unsafe extern "system" fn AnyScriptNotifyUri<Impl: IWebViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnyScriptNotifyUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IWebViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllowedScriptNotifyUrisProperty<Impl: IWebViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AllowedScriptNotifyUrisProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DataTransferPackageProperty<Impl: IWebViewStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataTransferPackageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics, BASE_OFFSET>(),
            AnyScriptNotifyUri: AnyScriptNotifyUri::<Impl, IMPL_OFFSET>,
            SourceProperty: SourceProperty::<Impl, IMPL_OFFSET>,
            AllowedScriptNotifyUrisProperty: AllowedScriptNotifyUrisProperty::<Impl, IMPL_OFFSET>,
            DataTransferPackageProperty: DataTransferPackageProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics2_Impl: Sized {
    fn CanGoBackProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoForwardProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DocumentTitleProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultBackgroundColorProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics2_Vtbl {
        unsafe extern "system" fn CanGoBackProperty<Impl: IWebViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoBackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForwardProperty<Impl: IWebViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanGoForwardProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DocumentTitleProperty<Impl: IWebViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DocumentTitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultBackgroundColorProperty<Impl: IWebViewStatics2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultBackgroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics2, BASE_OFFSET>(),
            CanGoBackProperty: CanGoBackProperty::<Impl, IMPL_OFFSET>,
            CanGoForwardProperty: CanGoForwardProperty::<Impl, IMPL_OFFSET>,
            DocumentTitleProperty: DocumentTitleProperty::<Impl, IMPL_OFFSET>,
            DefaultBackgroundColorProperty: DefaultBackgroundColorProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics3_Impl: Sized {
    fn ContainsFullScreenElementProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics3_Vtbl {
        unsafe extern "system" fn ContainsFullScreenElementProperty<Impl: IWebViewStatics3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics3, BASE_OFFSET>(),
            ContainsFullScreenElementProperty: ContainsFullScreenElementProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewStatics4_Impl: Sized {
    fn DefaultExecutionMode(&mut self) -> ::windows::core::Result<WebViewExecutionMode>;
    fn ClearTemporaryWebDataAsync(&mut self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics4";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewStatics4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics4_Vtbl {
        unsafe extern "system" fn DefaultExecutionMode<Impl: IWebViewStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewExecutionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultExecutionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearTemporaryWebDataAsync<Impl: IWebViewStatics4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClearTemporaryWebDataAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics4, BASE_OFFSET>(),
            DefaultExecutionMode: DefaultExecutionMode::<Impl, IMPL_OFFSET>,
            ClearTemporaryWebDataAsync: ClearTemporaryWebDataAsync::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics5_Impl: Sized {
    fn XYFocusLeftProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusRightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusUpProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusDownProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewStatics5_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewStatics5_Vtbl {
        unsafe extern "system" fn XYFocusLeftProperty<Impl: IWebViewStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusRightProperty<Impl: IWebViewStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusRightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusUpProperty<Impl: IWebViewStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusUpProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusDownProperty<Impl: IWebViewStatics5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XYFocusDownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewStatics5, BASE_OFFSET>(),
            XYFocusLeftProperty: XYFocusLeftProperty::<Impl, IMPL_OFFSET>,
            XYFocusRightProperty: XYFocusRightProperty::<Impl, IMPL_OFFSET>,
            XYFocusUpProperty: XYFocusUpProperty::<Impl, IMPL_OFFSET>,
            XYFocusDownProperty: XYFocusDownProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewStatics5 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Handled(&mut self) -> ::windows::core::Result<bool>;
    fn SetHandled(&mut self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewUnsupportedUriSchemeIdentifiedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnsupportedUriSchemeIdentifiedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewUnsupportedUriSchemeIdentifiedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Handled: Handled::<Impl, IMPL_OFFSET>,
            SetHandled: SetHandled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewUnsupportedUriSchemeIdentifiedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
pub trait IWebViewUnviewableContentIdentifiedEventArgs_Impl: Sized {
    fn Uri(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Referrer(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewUnviewableContentIdentifiedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "implement_exclusive"))]
impl IWebViewUnviewableContentIdentifiedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewUnviewableContentIdentifiedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewUnviewableContentIdentifiedEventArgs_Vtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewUnviewableContentIdentifiedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Referrer<Impl: IWebViewUnviewableContentIdentifiedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Referrer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewUnviewableContentIdentifiedEventArgs, BASE_OFFSET>(),
            Uri: Uri::<Impl, IMPL_OFFSET>,
            Referrer: Referrer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewUnviewableContentIdentifiedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewUnviewableContentIdentifiedEventArgs2_Impl: Sized {
    fn MediaType(&mut self) -> ::windows::core::Result<::windows::core::HSTRING>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewUnviewableContentIdentifiedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewUnviewableContentIdentifiedEventArgs2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewUnviewableContentIdentifiedEventArgs2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewUnviewableContentIdentifiedEventArgs2_Vtbl {
        unsafe extern "system" fn MediaType<Impl: IWebViewUnviewableContentIdentifiedEventArgs2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewUnviewableContentIdentifiedEventArgs2, BASE_OFFSET>(),
            MediaType: MediaType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewUnviewableContentIdentifiedEventArgs2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Foundation", feature = "Web_Http", feature = "implement_exclusive"))]
pub trait IWebViewWebResourceRequestedEventArgs_Impl: Sized {
    fn Request(&mut self) -> ::windows::core::Result<super::super::super::Web::Http::HttpRequestMessage>;
    fn Response(&mut self) -> ::windows::core::Result<super::super::super::Web::Http::HttpResponseMessage>;
    fn SetResponse(&mut self, value: &::core::option::Option<super::super::super::Web::Http::HttpResponseMessage>) -> ::windows::core::Result<()>;
    fn GetDeferral(&mut self) -> ::windows::core::Result<super::super::super::Foundation::Deferral>;
}
#[cfg(all(feature = "Foundation", feature = "Web_Http", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IWebViewWebResourceRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewWebResourceRequestedEventArgs";
}
#[cfg(all(feature = "Foundation", feature = "Web_Http", feature = "implement_exclusive"))]
impl IWebViewWebResourceRequestedEventArgs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWebViewWebResourceRequestedEventArgs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWebViewWebResourceRequestedEventArgs_Vtbl {
        unsafe extern "system" fn Request<Impl: IWebViewWebResourceRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Request() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Response<Impl: IWebViewWebResourceRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Response() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetResponse<Impl: IWebViewWebResourceRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetResponse(&*(&value as *const <super::super::super::Web::Http::HttpResponseMessage as ::windows::core::Abi>::Abi as *const <super::super::super::Web::Http::HttpResponseMessage as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IWebViewWebResourceRequestedEventArgs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWebViewWebResourceRequestedEventArgs, BASE_OFFSET>(),
            Request: Request::<Impl, IMPL_OFFSET>,
            Response: Response::<Impl, IMPL_OFFSET>,
            SetResponse: SetResponse::<Impl, IMPL_OFFSET>,
            GetDeferral: GetDeferral::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWebViewWebResourceRequestedEventArgs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWrapGrid_Impl: Sized {
    fn ItemWidth(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn ItemHeight(&mut self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&mut self, value: f64) -> ::windows::core::Result<()>;
    fn Orientation(&mut self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&mut self, value: Orientation) -> ::windows::core::Result<()>;
    fn HorizontalChildrenAlignment(&mut self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalChildrenAlignment(&mut self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalChildrenAlignment(&mut self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalChildrenAlignment(&mut self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWrapGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IWrapGrid_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWrapGrid_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWrapGrid_Vtbl {
        unsafe extern "system" fn ItemWidth<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn ItemHeight<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn HorizontalChildrenAlignment<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalChildrenAlignment<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHorizontalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn VerticalChildrenAlignment<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalChildrenAlignment<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVerticalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IWrapGrid_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWrapGrid, BASE_OFFSET>(),
            ItemWidth: ItemWidth::<Impl, IMPL_OFFSET>,
            SetItemWidth: SetItemWidth::<Impl, IMPL_OFFSET>,
            ItemHeight: ItemHeight::<Impl, IMPL_OFFSET>,
            SetItemHeight: SetItemHeight::<Impl, IMPL_OFFSET>,
            Orientation: Orientation::<Impl, IMPL_OFFSET>,
            SetOrientation: SetOrientation::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignment: HorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetHorizontalChildrenAlignment: SetHorizontalChildrenAlignment::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignment: VerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            SetVerticalChildrenAlignment: SetVerticalChildrenAlignment::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumns: MaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
            SetMaximumRowsOrColumns: SetMaximumRowsOrColumns::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWrapGrid as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWrapGridStatics_Impl: Sized {
    fn ItemWidthProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemHeightProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalChildrenAlignmentProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&mut self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IWrapGridStatics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWrapGridStatics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWrapGridStatics_Vtbl {
        unsafe extern "system" fn ItemWidthProperty<Impl: IWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemHeightProperty<Impl: IWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalChildrenAlignmentProperty<Impl: IWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalChildrenAlignmentProperty<Impl: IWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IWrapGridStatics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IInspectableVtbl::new::<Identity, IWrapGridStatics, BASE_OFFSET>(),
            ItemWidthProperty: ItemWidthProperty::<Impl, IMPL_OFFSET>,
            ItemHeightProperty: ItemHeightProperty::<Impl, IMPL_OFFSET>,
            OrientationProperty: OrientationProperty::<Impl, IMPL_OFFSET>,
            HorizontalChildrenAlignmentProperty: HorizontalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            VerticalChildrenAlignmentProperty: VerticalChildrenAlignmentProperty::<Impl, IMPL_OFFSET>,
            MaximumRowsOrColumnsProperty: MaximumRowsOrColumnsProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWrapGridStatics as ::windows::core::Interface>::IID
    }
}
